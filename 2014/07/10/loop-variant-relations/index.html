<!doctype html><html lang=en><head><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta property="og:title" content="Loop Variant Relations"><meta name=twitter:title content="Loop Variant Relations"><meta property="og:url" content="https://whileydave.com/2014/07/10/loop-variant-relations/"><title>David J. Pearce
(Loop Variant Relations)</title><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css><link rel=stylesheet href=https://whileydave.com/css/page.css><link rel=stylesheet href=https://whileydave.com/css/menu.css><link rel=stylesheet href=https://whileydave.com/css/style.css></head><body><script>"use strict";function clearMenu(){var q=window.matchMedia("(max-width: 992px)");if(q.matches){var c=document.getElementById("menu-content");var m=document.getElementById("menu");c.style.display='none';m.style.filter='';}}
function toggleMenu(){var q=window.matchMedia("(max-width: 992px)");if(q.matches){var c=document.getElementById("menu-content");var m=document.getElementById("menu");if(c.style.display==='block'){c.style.display='none';m.style.filter='';}else{c.style.display='block';m.style.filter="brightness(0.8)";}}}
function toggleList(element){element.style.display="none";var parent=element.parentNode;var items=parent.childNodes;for(var i=0;i<items.length;++i){var item=items[i];if(item.classList&&item.classList.contains("hidden")){if(item.style.display==='block'){item.style.display="none";}else{item.style.display="block";}}}}</script><header class=topbar><div class=topbar-header onclick=clearMenu()><div class=topbar-title>Dr. David J. Pearce</div><div class=topbar-subtitle></div></div><div class=topbar-social onclick=clearMenu()><a href=https://github.com/DavePearce><i class="fa fa-github" aria-hidden=true></i></a><a href=https://twitter.com/WhileyDave><i class="fa fa-twitter" aria-hidden=true></i></a><a href=https://www.youtube.com/user/redjamjar/><i class="fa fa-youtube-play" aria-hidden=true></i></a><a href=https://www.linkedin.com/in/david-pearce-8592647/><i class="fa fa-linkedin-square" aria-hidden=true></i></a></div><div class=topbar-menu><div id=menu onclick=toggleMenu()><div id=menu-icon><img src=https://whileydave.com/images/menu.png alt=Menu></div><div id=menu-content><a href=https://whileydave.com/blog/>Blog</a>
<a href=https://whileydave.com/projects/>Projects</a>
<a href=https://whileydave.com/publications/>Publications</a>
<a href=https://whileydave.com/talks/>Talks</a>
<a href=https://whileydave.com/>Home</a></div></div></div></header><div class=container onclick=clearMenu()><div class=content><h1 class=post-title>Loop Variant Relations</h1><div class=post-date>Thursday, July
10th,
2014</div><hr><p>Proving that a loop always terminates is a common requirement when verifying software. The usual approach to doing this is to provide a <a href=http://en.wikipedia.org/wiki/Loop_variant>loop variant</a> function. This is typically an integer expression which decreases on every iteration of the loop. Consider the following loop:</p><pre><code class=language-whiley data-lang=whiley>function contains([int] items, int item) =&gt; bool:
    int i = 0
    //
    while i &lt; |items|:
        if items[i] == item:
            return true
        i=i+1
    //
    return false
</code></pre><p>In this case, a suitable loop variant would be <code>|items| - i</code> which is guaranteed to decrease on each iteration of the loop. Furthermore, we know that when this reaches zero the loop will terminate (if it hasn&rsquo;t already).</p><h2 id=overview-of-relations>Overview of Relations</h2><p>An alternative to a loop variant function is to use what I&rsquo;m calling a <em>loop variant relation</em>.  The essential idea is to have an expression which relates the state before the loop body to that after it (which is not dissimilar, in fact, to a post-condition).   In particular, we can refer to a variables state before and after the body has executed within the same expression.  For example, if <code>x</code> is a variable modified in the loop then <code>x'</code> is the value that holds after the loop body.</p><p>Let&rsquo;s reconsider our simple example from above:</p><pre><code class=language-whiley data-lang=whiley>function contains([int] items, int item) =&gt; bool:
    int i = 0
    //
    while i &lt; |items| variant i &lt; i':
        if items[i] == item:
            return true
        i=i+1
    //
    return false
</code></pre><p>Here, I&rsquo;ve included the loop variant relation <code>i &lt; i'</code> which dictates that <code>i</code> is strictly increased by the loop. Using this relation, which can also establish that the loop terminates (more on this later).</p><h2 id=why-relations>Why Relations?</h2><p>An important question here is: <em>why consider loop variant relations over loop variant functions?</em> The answer is simply that, with a loop variant relation, we can everything we could with a loop variant function <em>and more</em>.  For example, loop variant relations can be used to show <em>the absence of change</em>.  Whilst this might seem odd, consider the following example:</p><pre><code class=language-whiley data-lang=whiley>function add([int] v1, int c) =&gt; ([int] v2)
ensures |v1| == |v2|:
   //
   int i = 0
   //
   while i &lt; |vs| invariant i &gt;= 0:
       v1[i] = v1[i] + c
       i = i + 1
   //
   return v1
</code></pre><p>This function simply adds a constant onto every element of an integer list. Unfortunately, this will not verify as is because the postcondition cannot be established. I have previously discussed this problem <a href=/2014/06/20/understanding-ghost-variables-in-software-verification/>here</a> and proposed a solution using <em>ghost variables</em>. However, loop variant relations gives us a better solution. The problem in verifying this function is that the verifier knows nothing about variables modified in a loop, except for what is specified in the loop invariant. Since <code>v1</code> is modified in the loop and nothing is given about it in the loop invariant, the verifier does not know that its size remains unchanged. Using a loop variant relation, we can expression this as follows:</p><pre><code class=language-whiley data-lang=whiley>function add([int] v1, int c) =&gt; ([int] v2)
ensures |v1| == |v2|:
   //
   int i = 0
   //
   while i &lt; |vs| invariant i &gt;= 0 variant |v1| == |v1'|:
       v1[i] = v1[i] + c
       i = i + 1
   //
   return v1
</code></pre><p>Here, the loop variant relation <code>|v1| == |v1'|</code> simply establishes that the size of <code>v1</code> is unchanged by the loop and, using this, the verifier can (in principle) verify this function.</p><h2 id=another-example>Another Example</h2><p>Another common situation where loop variants can be helpful is related to the partial update of records.  For example, consider this simple parsing function:</p><pre><code class=language-whiley data-lang=whiley>type State is { string input, int pos } where 0 &lt;= pos &amp;&amp; pos &lt;= |input|

function parseNumber(State s) =&gt; State
// input being parsed is not modified
ensures s.input == r.input:
    //
    while s.pos &lt; |s.input| &amp;&amp; isNumericAt(s):         
	   s.pos = s.pos + 1
    //
    return s

function isNumericAt(State s) =&gt; bool
requires s.pos &lt; |s.input|:
    //
    char c = s.input[s.pos]
    return '0' &lt;= c &amp;&amp; c &lt;= '9'
</code></pre><p>Intuitively, we can see that this function meets its postcondition (i.e. returns a valid instance of <code>State</code> over the same input <code>string</code>). Surprisingly, this function will not verify as is. The reason for this is that, since variable <code>s</code> is modified in the loop, all information connecting the value of <code>s.input</code> before the loop with that after the loop is lost. We can resolve this by adding the loop variant <code>s.input == s'.input</code> (note, it can also be resolved using a ghost variable).</p><h2 id=challenges>Challenges</h2><p>Unfortunately, loop variant relations are not completely straightforward to understand and implement.  For example, based on the above discussion, one might think that the loop variant holds after the loop (as the invariant does). Whilst this is in some sense true, we must be careful to interpret it correctly. The following illustrates:</p><pre><code class=language-whiley data-lang=whiley>function alt(int x, int n) =&gt; (int r)
ensures x != r:
    //
    int i = 0
    //
    while i &lt; n variant x != x':
        x = -x
        i = i + 1
    //
    return x
</code></pre><p>For the loop variant given, one might conclude that this function is correct and should verify. However, in fact, it cannot pass verification because the postcondition does not hold for even values of <code>n</code>. The problem is that the loop variant holds after the loop, in the sense that <code>x != x'</code> where <code>x</code> is the value of <code>x</code> at the beginning of the last iteration and <code>x'</code> the value at the end of the last iteration. Unfortunately, this is not enough to connect the value of <code>x``before</code> the loop with that from <code>after</code> the loop.</p><h2 id=termination>Termination</h2><p>An important reason for using loop variant functions is to ensure that a loop terminates.  *Therefore, the question is whether or not we can use loop variant relations like this as well? *Certainly, the answer to this is &ldquo;yes&rdquo; if we are reasoning by hand.  However, I&rsquo;m looking for a more general (i.e. mechanical) rule which we can apply.  Indeed, a way to extend the existing <a href=http://en.wikipedia.org/wiki/Hoare_logic>Hoare Logic</a> rule for <code>while</code> loops.</p><p>One approach might be to exploit the loop condition and ariant to show, in such case, the loop <em>won&rsquo;t</em> terminate.  For example, consider this loop:</p><pre><code class=language-whiley data-lang=whiley>function f(int n) =&gt; int:
    int i = 0
    //
    while i &lt; n variant i' &lt; i:
        i = i - 1
    //
    return i
</code></pre><p>Here, it follows that <code>i &lt; n && i' &lt; i</code> implies <code>i' &lt; n</code> and, hence, we can conclude the loop does not terminate. In contrast, for this loop:</p><pre><code class=language-whiley data-lang=whiley>function f(int n) =&gt; int:
    int i = 0
    //
    while i &lt; n variant i &lt; i':
        i = i + 1
    //
    return i
</code></pre><p>It follows that <code>i &lt; n && i &lt; i'</code> does <em>not</em> imply <code>i' &lt; n</code> and, hence, we can conclude the loop <em>might</em> terminate. The real question is whether we can establish anything stronger than this &mldr;</p><h2 id=further-reading>Further Reading</h2><p>There are lots of interesting papers which discuss loop invariants and variants.  However, I haven&rsquo;t found so many which consider loop variants as relations in this way.  Here are those I&rsquo;ve found (so far):</p><ul><li><p><strong>Invariant relations, invariant functions, and loop functions</strong>, Lamia Labed Jilani and Asma Louhichi and Olfa Mraihi and Ali Mili.  <em>Innovations in Systems and Software Engineering</em>, 8(3), pp. 195-212, 2012. (<a href=http://link.springer.com/article/10.1007%2Fs11334-012-0189-0>Link</a>)</p></li><li><p><strong>Invariant Relations: An Alternative Tool to Analyze Loops</strong>Asma Louhichi, Olfa Mraihi, Wided Ghardallou, LamiaLabed Jilani, Khaled Bsaies and Ali Mili.  Technical Report. (<a href=http://web.njit.edu/~mili/tac.pdf>Link</a>).</p></li><li><p><strong>Transition Invariants</strong>, Andreas Podelski and Andrey Rybalchenko.  In Proceedings of Conference on Logic in Computer Science (LICS), 2004. (<a href=http://www.avacs.org/Publikationen/Open/podelski.lics.04.draft.pdf>Link</a>)</p></li><li><p><strong>Elimination of Ghost Variables in Program Logics,</strong> Martin Hofmann and Mariela Pavlova.  In <em>Proceedings of the Symposium on Trustworthy Computing</em>, pages 1&ndash;20, 2008. (<a href=http://link.springer.com/chapter/10.1007%2F978-3-540-78663-4_1>Link</a>)</p></li><li><p><strong>An Improved Rule for While Loops in Deductive Program Verification</strong>, Bernhard Beckert and Steffen Schlager and Peter H. Schmitt.  In Proceedings of the International Conference on Formal Engineering Methods, 2005. (<a href=http://digbib.ubka.uni-karlsruhe.de/volltexte/documents/2839>Link</a>)</p></li></ul><hr></div></div><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-5582165-7','auto');ga('send','pageview');}</script></body></html>