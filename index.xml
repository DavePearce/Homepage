<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Dave's Homepage</title><link>http://whileydave.com/</link><description>Recent content on Dave's Homepage</description><generator>Hugo -- gohugo.io</generator><language>en-nz</language><lastBuildDate>Tue, 04 Aug 2020 00:00:00 +0000</lastBuildDate><atom:link href="http://whileydave.com/index.xml" rel="self" type="application/rss+xml"/><item><title>Putting the Semantics into Semantic Versioning</title><link>http://whileydave.com/publications/ldp20/</link><pubDate>Tue, 04 Aug 2020 00:00:00 +0000</pubDate><guid>http://whileydave.com/publications/ldp20/</guid><description>Abstract: The long-standing aspiration for software reuse has made astonishing strides in the past few years. Many modern software development ecosystems now come with rich sets of publicly-available components contributed by the community. Downstream developers can leverage these upstream components, boosting their productivity. However, components evolve at their own pace. This imposes obligations on and yields benefits for downstream developers, especially since changes can be breaking, requiring additional downstream work to adapt to.</description></item><item><title>Computational Resources</title><link>http://whileydave.com/publications/rp2020_crc/</link><pubDate>Wed, 01 Jan 2020 00:00:00 +0000</pubDate><guid>http://whileydave.com/publications/rp2020_crc/</guid><description/></item><item><title>AtmoVis: Visualization of Air Quality Data</title><link>http://whileydave.com/publications/powley19_msc/</link><pubDate>Tue, 01 Jan 2019 00:00:00 +0000</pubDate><guid>http://whileydave.com/publications/powley19_msc/</guid><description>Abstract: Air quality has an adverse impact on the health of people living in areas with poor quality air. Monitoring is needed to understand the effects of poor air quality. It is difficult to compare measurements to find trends and patterns between different monitoring sites when data is contained in separate data stores. Data visualization can make analyzing air quality more effective by making the data more understandable. The purpose of this research is to design and build a prototype for visualizing spatio-temporal data from multiple sources related to air quality and to evaluate the effectiveness of the prototype against criteria by conducting a user study.</description></item><item><title>Compiling Whiley for the Ethereum Virtial Machine</title><link>http://whileydave.com/publications/kumar19_engr489/</link><pubDate>Tue, 01 Jan 2019 00:00:00 +0000</pubDate><guid>http://whileydave.com/publications/kumar19_engr489/</guid><description>Abstract. Ethereum is a blockchain based platform that supports a Turing complete contract language. However, methods of writing smart contracts have been error prone. This has resulted in many historically expensive bugs such as the DAO. Whiley is a programming language which allows you to verify code. This project looks at compiling Whiley to Ethereum bytecode in order to utilise Whiley&amp;rsquo;s verification tools to make writing smart contracts safer. Finally, we run some coverage tests to see how the developed method adheres to the Whiley language.</description></item><item><title>Compiling Whiley for WebAssembly</title><link>http://whileydave.com/publications/hua19_comp489/</link><pubDate>Tue, 01 Jan 2019 00:00:00 +0000</pubDate><guid>http://whileydave.com/publications/hua19_comp489/</guid><description>Abstract. Whiley is a multi-paradigm programming language which supports Extended Static Checking through formal specification. At compile time, Whiley can identify common errors which are uncaught by a type checker, including division by zero, null reference and array out of bounds errors. WebAssembly is a portable binary code format supported by major browsers. WebAssembly is designed to enable high-performance applications on web pages. This project is about developing a Whiley Compiler back-end plugin which translates Whiley Intermediate Language into WebAssembly.</description></item><item><title>Dependency Versioning in the Wild</title><link>http://whileydave.com/publications/dpstb19_msr/</link><pubDate>Tue, 01 Jan 2019 00:00:00 +0000</pubDate><guid>http://whileydave.com/publications/dpstb19_msr/</guid><description>Abstract: Many modern software systems are built on top of existing packages (modules, components, libraries). The increasing number and complexity of dependencies has given rise to automated dependency management where package managers resolve symbolic dependencies against a central repository. When declaring dependencies, developers face various choices, such as whether or not to declare a fixed version or a range of versions. The former results in runtime behaviour that is easier to predict, whilst the latter enables flexibility in resolution that can, for example, prevent different versions of the same package being included and facilitates the automated deployment of bug fixes.</description></item><item><title>Efficient compilation of a verification-friendly programming language</title><link>http://whileydave.com/publications/weng19_phd/</link><pubDate>Tue, 01 Jan 2019 00:00:00 +0000</pubDate><guid>http://whileydave.com/publications/weng19_phd/</guid><description>Abstract. This thesis develops a compiler to convert a program written in the verification friendly programming language Whiley into an efficient implementation in C. Our compiler uses a mixture of static analysis, run-time monitoring and a code generator to and faster integer types, eliminate unnecessary array copies and de-allocate unused memory without garbage collection, so that Whiley programs can be translated into C code to run fast and for long periods on general operating systems as well as limited-resource embedded devices.</description></item><item><title>On the Architecture of a (Verifying) Compiler</title><link/><pubDate>Sun, 16 Dec 2018 00:00:00 +0000</pubDate><guid/><description/></item><item><title>A Symmetry Metric for Graphs and Line Diagrams</title><link>http://whileydave.com/publications/kmp18_diagrams/</link><pubDate>Mon, 01 Jan 2018 00:00:00 +0000</pubDate><guid>http://whileydave.com/publications/kmp18_diagrams/</guid><description/></item><item><title>An Introduction to Software Verification with Whiley</title><link>http://whileydave.com/publications/pug18_etss/</link><pubDate>Mon, 01 Jan 2018 00:00:00 +0000</pubDate><guid>http://whileydave.com/publications/pug18_etss/</guid><description>Abstract: This tutorial introduces the basic ideas of software specification and verification, which are important techniques for assuring the quality of software and eliminating common kinds of errors such as buffer overflow. The tutorial takes a practical hands-on approach using the Whiley language and its verifying compiler. This verifying compiler uses an automated proof engine to try to prove that the code will execute without errors and will satisfy its specifications.</description></item><item><title>Inferring invariants from postconditions in Whiley</title><link>http://whileydave.com/publications/pope18_engr489/</link><pubDate>Mon, 01 Jan 2018 00:00:00 +0000</pubDate><guid>http://whileydave.com/publications/pope18_engr489/</guid><description>Abstract. For the formal verification of programs, loop invariants must be used to ensure the verifier understands the properties of a loop. These invariants are often trivial, and many are common between loops. It would be easier for programmers if these types of invariants did not have to be written into code, but were instead generated by the compiler. One way to do this is to infer the loop invariants from the postconditions of the containing function or method.</description></item><item><title>On Declarative Rewriting for Sound and Complete Union, Intersection and Negation Types</title><link>http://whileydave.com/publications/pea18_jvlc/</link><pubDate>Mon, 01 Jan 2018 00:00:00 +0000</pubDate><guid>http://whileydave.com/publications/pea18_jvlc/</guid><description>Abstract. Implementing the type system of a programming language is a critical task that is oftendone in an ad-hoc fashion. Whilst this makes it hard to ensure the system is sound, italso makes it difficult to extend as the language evolves. We are interested in describing type systems using rewrite rules from which an implementation can be automaticallygenerated. Whilst not all type systems are easily expressed in this manner, those involving unions, intersections and negations are well-suited for this.</description></item><item><title>QuickCheck for Whiley</title><link>http://whileydave.com/publications/chin18_engr489/</link><pubDate>Mon, 01 Jan 2018 00:00:00 +0000</pubDate><guid>http://whileydave.com/publications/chin18_engr489/</guid><description>Abstract. Whiley is a programming language that verifies code using formal specifications to improve software quality. Whiley contains a verifying compiler which can identify common bugs. However, the compiler is limited in its ability to discover bugs and may take a long time to verify large programs. Testing is another approach to find bugs. However, testing Whiley programs requires users to manually write code which can be a valuable but time-consuming process.</description></item><item><title>Rewriting for Sound and Complete Union, Intersection and Negation Types</title><link>http://whileydave.com/publications/pea18_gpce/</link><pubDate>Mon, 01 Jan 2018 00:00:00 +0000</pubDate><guid>http://whileydave.com/publications/pea18_gpce/</guid><description>Abstract: Implementing the type system of a programming language is a critical task that is often done in an ad-hoc fashion. Whilst this makes it hard to ensure the system is sound, it also makes it difficult to extend as the language evolves. We are interested in describing type systems using declarative rewrite rules from which an implementation can be automatically generated. Whilst not all type systems are easily expressed in this manner, those involving unions, intersections and negations are well-suited for this.</description></item><item><title>Towards Compilation of an Imperative Language for FPGAs</title><link>http://whileydave.com/publications/ppp18_vmil/</link><pubDate>Mon, 01 Jan 2018 00:00:00 +0000</pubDate><guid>http://whileydave.com/publications/ppp18_vmil/</guid><description>Abstract: Field-Programmable Gate Arrays (FPGA’s) have been around since the early 1980s and have now achieved relatively widespread use. For example, FPGAs are routinely used for high-performance computing, financial applications, seismic modelling, DNA sequence alignment, software defined networking and, occasionally, are even found in smartphones. And yet, despite their success, there still remains something of a gap between programming languages and circuit designs for an FPGA. We consider the compilation of an imperative programming language, Whiley, to VHDL for use on an FPGA.</description></item><item><title>What does the Future of Programming Look Like?</title><link/><pubDate>Mon, 24 Jul 2017 00:00:00 +0000</pubDate><guid/><description/></item><item><title>Contracts in the Wild: A Study of Java Programs</title><link/><pubDate>Tue, 27 Jun 2017 00:00:00 +0000</pubDate><guid/><description/></item><item><title>Array Programming in Whiley</title><link>http://whileydave.com/publications/pea17_array/</link><pubDate>Sun, 01 Jan 2017 00:00:00 +0000</pubDate><guid>http://whileydave.com/publications/pea17_array/</guid><description>Abstract: Arrays are a fundamental mechanism for developing and reasoning about programs. Using them, one can easily encode a range of important algorithms from various domains, such as for sorting, graph traversal, heap manipulation and more. However, the encoding of such problems in traditional languages is relatively opaque. That is, such programming languages do not allow those properties important for the given problem to be encoded within the language itself and, instead, rely up on programmer-supplied comments.</description></item><item><title>Classless Object Semantics</title><link>http://whileydave.com/publications/jones17_phd/</link><pubDate>Sun, 01 Jan 2017 00:00:00 +0000</pubDate><guid>http://whileydave.com/publications/jones17_phd/</guid><description>Abstract: Objects have been categorised into classes that declare and implement their behaviour ever since the paradigm of object-orientation in programming languages was first conceived. Classes have an integral role in the design and theory of object-oriented languages, and often appear alongside objects as a foundational concept of the paradigm in many theoretical models. A number of object-oriented languages have attempted to remove classes as a core component of the language design and rebuild their functionality purely in terms of objects, to varying success.</description></item><item><title>Compiling Whiley to FPGAs</title><link>http://whileydave.com/publications/pauget17_project/</link><pubDate>Sun, 01 Jan 2017 00:00:00 +0000</pubDate><guid>http://whileydave.com/publications/pauget17_project/</guid><description>Abstract. Improving code performances lies more and more in the relevant use of computational helpers. Computing platforms like OpenCL or CUDA that enable to relocate resource consuming calculations to graphics processing unit (GPU) are now ordinary. Theses frameworks are rather low-level and require either a thorough learning or the use of higher level libraries that reduce their flexibility. A orthogonal concern of programming language is static checking. As the rise of strongly typed languages (Rust, Scala, Haskell, &amp;hellip;) reveals it, extended static checking is well-liked since it improves greatly the development process, lowering the debug work.</description></item><item><title>Contracts in the Wild: A Study of Java Programs</title><link>http://whileydave.com/publications/dpjb17_ecoop/</link><pubDate>Sun, 01 Jan 2017 00:00:00 +0000</pubDate><guid>http://whileydave.com/publications/dpjb17_ecoop/</guid><description>Abstract: The use of formal contracts has long been advocated as an approach to develop programs that are provably correct. However, the reality is that adoption of contracts has been slow in practice. Despite this, the adoption of lightweight contracts — typically utilising runtime checking — has progressed. In the case of Java, built-in features of the language (e.g. assertions and exceptions) can be used for this. Furthermore, a number of libraries which facilitate contract checking have arisen.</description></item><item><title>Making Whiley Boogie!</title><link>http://whileydave.com/publications/upg17_ifm/</link><pubDate>Sun, 01 Jan 2017 00:00:00 +0000</pubDate><guid>http://whileydave.com/publications/upg17_ifm/</guid><description>Abstract: The quest to develop increasingly sophisticated verification systems continues unabated. Tools such as Dafny, Spec#, ESC/Java, SPARK Ada, and Whiley attempt to seamlessly integrate specification and verification into a programming language, in a similar way to type checking. A common integration approach is to generate verification conditions that are handed off to an automated theorem prover. This provides a nice separation of concerns, and allows different theorem provers to be used interchangeably.</description></item><item><title>A Mechanical Soundness Proof for Subtyping over Recursive Types</title><link>http://whileydave.com/publications/jp16_ftfjp/</link><pubDate>Fri, 01 Jan 2016 00:00:00 +0000</pubDate><guid>http://whileydave.com/publications/jp16_ftfjp/</guid><description>Abstract: Structural type systems provide an interesting alternative to the more common nominal typing scheme. Several existing languages employ structural types in some form, including Modula-3, Scala and various extensions proposed for Java. However, formalising a recursive structural type system is challenging. In particular, the need to use structural coinduction remains a hindrance for many. We formalise in Agda a simple recursive and structural type system with products and unions. Agda proves useful here because it has explicit support for coinduction and will raise an error if this is misused.</description></item><item><title>A Space Efficient Algorithm for Detecting Strongly Connected Components</title><link>http://whileydave.com/publications/pea16_ipl/</link><pubDate>Fri, 01 Jan 2016 00:00:00 +0000</pubDate><guid>http://whileydave.com/publications/pea16_ipl/</guid><description>Abstract. Tarjan’s algorihm for finding the strongly connected components of a directed graph is widely used and acclaimed. His original algorithm required at most v(2 + 5w) bits of storage, where w is the machine’s word size, whilst Nuutila and Soisalon-Soininen reduced this to v(1 + 4w). Many real world applications routinely operate on very large graphs where the storage requirements of such algorithms is a concern. We present a novel improvement on Tarjan’s algorithm which reduces the space requirements to v(1 + 3w) bits in the worst case.</description></item><item><title>Lifetime Analysis for Whiley</title><link>http://whileydave.com/publications/schweizer16_msc/</link><pubDate>Fri, 01 Jan 2016 00:00:00 +0000</pubDate><guid>http://whileydave.com/publications/schweizer16_msc/</guid><description>Abstract. Safety critical environments require high programming standards. Verification is a way to prove absence of certain faults and to make sure that a program meets a given specification. Unfortunately, most modern programming languages do not actively support verification. External tools are necessary and there is no good integration with the development process.
hiley is a programming language that aims to popularize verification. Functions can be annotated with pre- and postconditions and the compiler ships with a verifier that ensures that the implementation satisfies the specification.</description></item><item><title>Whiley as a Research Project</title><link/><pubDate>Mon, 23 Mar 2015 00:00:00 +0000</pubDate><guid/><description/></item><item><title>Comparing Graph Layouts for Vertex Selection Tasks</title><link>http://whileydave.com/publications/kpm15_ozchi/</link><pubDate>Thu, 01 Jan 2015 00:00:00 +0000</pubDate><guid>http://whileydave.com/publications/kpm15_ozchi/</guid><description>Abstract: Different graph layouts can affect a user’s ability to complete both passive understanding and active interaction tasks. While most research exploring the effects of graph layout looks at a user’s ability to accomplish a passive understanding task, this paper’s novel contribution is looking at their ability to complete a selection task. Specifically we compare two graph layout algorithms with respect to their suitability for free-form multi-selection.
The two layout algorithms are drawn from our previous work which established that they have significantly different understandability metric scores.</description></item><item><title>Designing a Verifying Compiler: Lessons Learned from Developing Whiley</title><link>http://whileydave.com/publications/pg15_scp/</link><pubDate>Thu, 01 Jan 2015 00:00:00 +0000</pubDate><guid>http://whileydave.com/publications/pg15_scp/</guid><description>Abstract. An ongoing challenge for computer science is the development of a tool which automati- cally verifies programs meet their specifications, and are free from runtime errors such as divide-by-zero, array out-of-bounds and null dereferences. Several impressive systems have been developed to this end, such as ESC/Java and Spec#, which build on existing programming languages (e.g., Java, C#). We have been developing a programming language from scratch to simplify verification, called Whiley, and an accompanying verifying compiler.</description></item><item><title>Developing a Whiley-to-JavaScript Translator</title><link>http://whileydave.com/publications/slater15_engr489/</link><pubDate>Thu, 01 Jan 2015 00:00:00 +0000</pubDate><guid>http://whileydave.com/publications/slater15_engr489/</guid><description>Abstract. Executing Whiley in the web browser requires a server for processing. With many people using Whiley in the web browser simultaneously, this server can become very slow. JavaScript is programming language designed to execute in the web browser without a server. This project designed and implemented a translator for turning Whiley programs into JavaScript. Two web applications, Minesweeper and Conway’s Game of Life have been built in Whiley then executed in the browser using translated JavaScript and HTML5.</description></item><item><title>Identifying Redundant Test Cases</title><link>http://whileydave.com/publications/shaw15_engr489/</link><pubDate>Thu, 01 Jan 2015 00:00:00 +0000</pubDate><guid>http://whileydave.com/publications/shaw15_engr489/</guid><description>Abstract. This project investigates tracing the method call information of Java JUnit Tests and using the information to identify redundant tests in a test suite. There are a variety of different methods implemented (and experimented on) to identify redundancy within a suite. The techniques involve retrieving different information from the tests and analysing it differently. The experiments show two main points. First, that a set of the method calls work well as a heuristic.</description></item><item><title>Integer Range Analysis for Whiley on Embedded Systems</title><link>http://whileydave.com/publications/pea15_seus/</link><pubDate>Thu, 01 Jan 2015 00:00:00 +0000</pubDate><guid>http://whileydave.com/publications/pea15_seus/</guid><description>Abstract: Programs written in the Whiley programming language are verified at compile-time to ensure all function specifications are met. The purpose of doing this is to eliminate as many software bugs as possible and, thus, Whiley is ideally suited for use in safety-critical systems. The language was designed from scratch to simplify verification as much as possible. To that end, arithmetic types in Whiley consist of unbounded integers and rationals and this poses a problem for use in memory constrained embedded devices.</description></item><item><title>Some Usability Hypotheses for Verification</title><link>http://whileydave.com/publications/pea15_plateau/</link><pubDate>Thu, 01 Jan 2015 00:00:00 +0000</pubDate><guid>http://whileydave.com/publications/pea15_plateau/</guid><description>Abstract: The idea of specifying and verifying software to eliminate errors has been studied extensively over the last three decades or more. Recent advances in automated theorem proving have given rise to a range of new verification tools being developed. Despite this, very little is known about the effect of using such tools on software development. In this paper, we present several verification-related usability hypotheses which we believe warrant further investigation.</description></item><item><title>The Whiley Rewrite Language (WyRL)</title><link>http://whileydave.com/publications/pea15_sle/</link><pubDate>Thu, 01 Jan 2015 00:00:00 +0000</pubDate><guid>http://whileydave.com/publications/pea15_sle/</guid><description>Abstract: The Whiley Rewrite Language (WyRL) is a standalone tool providing a domain-specific declarative rewrite language and code generator. The tool is currently used to generate a critical component of the Whiley verifying compiler, namely the automated theorem prover. The tool automatically generates Java source code from a given rule set. The runtime library provides support for different heuristics to control aspects of the generated system, such as the order in which rewrite rules are applied.</description></item><item><title>An Empirical Evaluation of Force-Directed Graph Layout</title><link>http://whileydave.com/publications/klapaukh14_phd/</link><pubDate>Wed, 01 Jan 2014 00:00:00 +0000</pubDate><guid>http://whileydave.com/publications/klapaukh14_phd/</guid><description>Abstract: Force-directed graph layout is a widely used algorithm for the automatic layout of graphs. Little experimental work has been done exploring the behaviour of the algorithm under a variety of conditions. This thesis carries out three large-scale metric-based experiments. The first explores how the core algorithm behaves under changes to initial conditions. The second looks at extending the force-directed layout algorithm with additional forces to reduce overlaps. The third develops a novel symmetry metric for graphs and uses that to explore the symmetries of graphs.</description></item><item><title>Demonstrating Whiley on an Embedded System</title><link>http://whileydave.com/publications/stevens14_engr489/</link><pubDate>Wed, 01 Jan 2014 00:00:00 +0000</pubDate><guid>http://whileydave.com/publications/stevens14_engr489/</guid><description>Abstract. Developing and verifying the software for safety critical embedded systems can be difficult and expensive due to unique constraints, including limited RAM and minimalist operating systems. This report looks at Whiley, a verifying compiler, which is intended to improve the correctness of code on a variety of systems. For the first time, Whiley is explored in the embedded systems context to identify obstacles to becoming a practical tool for embedded systems programmers.</description></item><item><title>Graceful Language Extensions and Interfaces</title><link>http://whileydave.com/publications/homer14_phd/</link><pubDate>Wed, 01 Jan 2014 00:00:00 +0000</pubDate><guid>http://whileydave.com/publications/homer14_phd/</guid><description>Abstract: Grace is a programming language under development aimed at education. Grace is object-oriented, imperative, and block-structured, and intended for use in first- and second-year object-oriented programming courses. We present a number of language features we have designed for Grace and implemented in our self-hosted compiler. We describe the design of a pattern-matching system with object-oriented structure and minimal extension to the language. We give a design for an object-based module system, which we use to build dialects, a means of extending and restricting the language available to the programmer, and of implementing domain-specific languages.</description></item><item><title>Maintaining Private Views in Java</title><link>http://whileydave.com/publications/haslett14_msc/</link><pubDate>Wed, 01 Jan 2014 00:00:00 +0000</pubDate><guid>http://whileydave.com/publications/haslett14_msc/</guid><description>Abstract: When developers collaborate on a project there are times when the code diverges. When this happens the code may need to be refactored to best suit the changes before they are applied. In these situations it would be valuable to have a private view. This view would be functionally equivalent to other views and be able to present the code in a different form. It enables a developer to refactor or change the code to their tastes, with minimal impact on other developers.</description></item><item><title>Software Language Engineering - 7th International Conference</title><link>http://whileydave.com/publications/cpbv14_sle/</link><pubDate>Wed, 01 Jan 2014 00:00:00 +0000</pubDate><guid>http://whileydave.com/publications/cpbv14_sle/</guid><description>Proceedings of the 7th International Conference on Software Language Engineering (SLE). See the conference homepage here.</description></item><item><title>Towards a Vertex and Edge Label Aware Force Directed Layout Algorithm</title><link>http://whileydave.com/publications/kpm14_acsc/</link><pubDate>Wed, 01 Jan 2014 00:00:00 +0000</pubDate><guid>http://whileydave.com/publications/kpm14_acsc/</guid><description>Abstract: Many automatic graph layout algorithms can cause shaped vertices and edge labels (which have a size when drawn on the screen) to overlap in the resulting visualisation. Overlaps can hide information that users expect to see in cases where the graph is small. We perform two experiments on a large real-world set of small (10-110 vertex) graphs to compare how different combinations of forces in Eades’ force directed layout algorithm affect the final graph layout.</description></item><item><title>Verifying Whiley Programs using an Off-the-Shelf SMT Solver</title><link>http://whileydave.com/publications/wylde14_engr489/</link><pubDate>Wed, 01 Jan 2014 00:00:00 +0000</pubDate><guid>http://whileydave.com/publications/wylde14_engr489/</guid><description>Abstract. This project investigated the integration of external theorem proving tools with Whiley — specifically, Satisfiability Modulo Theories (SMT) solvers — to increase the number of verifiable Whiley programs. The current verifier, the Whiley Constraint Solver (WyCS), is limited and hence there is a difficulty in verifying Whiley programs. This project designed and implemented an extension that supported the use of arbitrary SMT solvers with the Whiley compiler. The evaluation of this extension used the Z3 SMT solver.</description></item><item><title>Writing Loop Invariants in Whiley</title><link/><pubDate>Sun, 27 Jan 2013 00:00:00 +0000</pubDate><guid/><description/></item><item><title>A Calculus for Constraint-Based Flow Typing</title><link>http://whileydave.com/publications/pea13_beat/</link><pubDate>Tue, 01 Jan 2013 00:00:00 +0000</pubDate><guid>http://whileydave.com/publications/pea13_beat/</guid><description/></item><item><title>A Calculus for Constraint-Based Flow Typing</title><link>http://whileydave.com/publications/pea13_ftfjp/</link><pubDate>Tue, 01 Jan 2013 00:00:00 +0000</pubDate><guid>http://whileydave.com/publications/pea13_ftfjp/</guid><description>Abstract: Flow typing offers an alternative to traditional Hindley-Milner type inference. A key distinction is that variables may have different types at different program points. Flow typing systems are typically formalised in the style of a dataflow analysis. In the presence of loops, this requires a fix-point computation over typing environments. Unfortunately, for some flow typing problems, the standard iterative fix-point computation may not terminate. We formalise such a problem we encountered in developing the Whiley programming language, and present a novel constraint-based solution which is guaranteed to terminate.</description></item><item><title>Balloon Types for Safe Parallelisation over Arbitrary Object Graphs</title><link>http://whileydave.com/publications/spgp13_wodet/</link><pubDate>Tue, 01 Jan 2013 00:00:00 +0000</pubDate><guid>http://whileydave.com/publications/spgp13_wodet/</guid><description>Abstract: Safe parallelisation of object-oriented programs requires static guarantees about the shape and/or intended usage of reachable objects. For example, transitively immutable objects lend themselves naturally to concurrent access. However, parallelising tasks which potentially mutate reachable objects is more challenging. One approach to avoiding race conditions is to ensure the reachable object graphs of any concurrently executing tasks are disjoint. Numerous systems have been developed which provide guarantees of this kind (e.</description></item><item><title>Compiling Whiley Programs for a General Purpose GPU</title><link>http://whileydave.com/publications/raurus13_engr489/</link><pubDate>Tue, 01 Jan 2013 00:00:00 +0000</pubDate><guid>http://whileydave.com/publications/raurus13_engr489/</guid><description>Abstract. This project investigates improving the performance of Whiley programs by executing portions of these programs on GPUs while maintaining as closely as possible the semantics of the language. Programs written in languages such as Whiley are typically not well suited to execution on GPUs which exhibit large-scale data parallelism in contrast to small-scale task parallelism seen on CPUs. Therefore, the developed solution parallelises only the portions of programs which are likely to benefit — specifically, certain types of loops — and applies several optimisations to increase performance.</description></item><item><title>OwnKit: Inferring Modularly Checkable Ownership Annotations for Java</title><link>http://whileydave.com/publications/dpp13_aswec/</link><pubDate>Tue, 01 Jan 2013 00:00:00 +0000</pubDate><guid>http://whileydave.com/publications/dpp13_aswec/</guid><description>Abstract: Ownership and related systems impose restrictions on the object graph that can help improve program structure, exploit concurrency and verify software. Such systems rely on the presence of appropriate ownership annotations in the source code. Unfortunately, manually adding ownership annotations to legacy systems is a tedious process. Previous attempts at automatically inferring such ownership systems do not produce modularly checkable annotations (i.e. which allow classes to be checked in isolation) making them difficult to incorporate into day-to- day development.</description></item><item><title>Reflections on Verifying Software with Whiley</title><link>http://whileydave.com/publications/pg13_ftscs/</link><pubDate>Tue, 01 Jan 2013 00:00:00 +0000</pubDate><guid>http://whileydave.com/publications/pg13_ftscs/</guid><description>Abstract: An ongoing challenge for computer science is the development of a tool which automatically verifies that programs meet their specifications, and are free from runtime errors such as divide-by-zero, array out-of-bounds and null dereferences. Several impressive systems have been developed to this end, such as ESC/Java and Spec#, which build on existing programming languages (e.g. Java, C#). Unfortunately, such languages were not designed for this purpose and this significantly hinders the development of practical verification tools for them.</description></item><item><title>Sound and Complete Flow Typing with Unions, Intersections and Negations</title><link>http://whileydave.com/publications/pea13_vmcai/</link><pubDate>Tue, 01 Jan 2013 00:00:00 +0000</pubDate><guid>http://whileydave.com/publications/pea13_vmcai/</guid><description>Abstract: Flow typing is becoming a popular mechanism for typing existing programs written in untyped languages (e.g. JavaScript, Racket, Groovy). Such systems require intersections for the true-branch of a type test, negations for the false-branch, and unions to capture the flow of information at meet points. Type systems involving unions, intersections and negations require a subtype operator which is non-trivial to implement. Frisch et al. demonstrated that this problem was decidable.</description></item><item><title>Whiley: a Platform for Research in Software Verification</title><link>http://whileydave.com/publications/pg13_sle/</link><pubDate>Tue, 01 Jan 2013 00:00:00 +0000</pubDate><guid>http://whileydave.com/publications/pg13_sle/</guid><description>Abstract: An ongoing challenge for computer science is the development of a tool which automatically verifies programs meet their specifications, and are free from runtime errors such as divide-by-zero, array out-of-bounds and null dereferences. Several impressive systems have been developed to this end, such as ESC/Java and Spec#, which build on existing programming languages (e.g. Java, C#). However, there remains a need for an open research platform in this area. We have developed the Whiley programming language, and its accompanying verifying compiler, as an open platform for research.</description></item><item><title>Patterns as Objects in Grace</title><link>http://whileydave.com/publications/hnbbp12_dls/</link><pubDate>Sun, 01 Jan 2012 00:00:00 +0000</pubDate><guid>http://whileydave.com/publications/hnbbp12_dls/</guid><description>Abstract: Object orientation and pattern matching are often seen as conflicting approaches to program design. Object oriented programs place type-dependent behaviour inside objects and invoke it via dynamic dispatch, while pattern matching programs place type-dependent behaviour outside data structures and invoke it via multiway conditionals (case statements). Grace is a new, dynamic, object-oriented language designed to support teaching: to this end, Grace needs to support both styles. In this paper we explain how this conflict can be resolved gracefully: by modelling patterns and cases as partial functions, reifying those functions as first-class objects, and then building up complex patterns from simpler ones using pattern combinators.</description></item><item><title>Profiling Field Initialization for Java</title><link>http://whileydave.com/publications/npn12_rv/</link><pubDate>Sun, 01 Jan 2012 00:00:00 +0000</pubDate><guid>http://whileydave.com/publications/npn12_rv/</guid><description>Abstract: Java encourages programmers to use constructor methods to initialise objects, supports final modifiers for documenting fields which are never modified and employs static checking to ensure such fields are only ever initialised inside constructors. Unkel and Lam observed that relatively few fields are actually declared final and showed using static analysis that many more fields have final behaviour, and even more fields are stationary (i.e. all writes occur before all reads).</description></item><item><title>Profiling Initialisation Behaviour in Java</title><link>http://whileydave.com/publications/nelson12_phd/</link><pubDate>Sun, 01 Jan 2012 00:00:00 +0000</pubDate><guid>http://whileydave.com/publications/nelson12_phd/</guid><description>Abstract: Freshly created objects are a blank slate: their mutable state and their constant properties must be initialised before they can be used. Programming languages like Java typically support object initialisation by providing constructor methods. This thesis examines the actual initialisation of objects in real-world programs to determine whether constructor methods support the initialisation that programmers actually perform. Determining which object initialisation techniques are most popular and how they can be identified will allow language designers to better understand the needs of programmers, and give insights that VM designers could use to optimise the performance of language implementations, reduce memory consumption, and improve garbage collection behaviour.</description></item><item><title>The Whiley Programming Language</title><link/><pubDate>Tue, 20 Dec 2011 00:00:00 +0000</pubDate><guid/><description/></item><item><title>Formalisation and Implementation of an Algorithm for Bytecode Verification of @NonNull Types</title><link>http://whileydave.com/publications/mppd11_scp/</link><pubDate>Sat, 01 Jan 2011 00:00:00 +0000</pubDate><guid>http://whileydave.com/publications/mppd11_scp/</guid><description>Abstract. Java&amp;rsquo;s annotation mechanism allows us to extend its type system with non-null types. Checking such types cannot be done using the existing bytecode verification algorithm. We extend this algorithm to verify non-null types using a novel technique that identifies aliasing relationships between local variables and stack locations in the JVM. We formalise this for a subset of Java Bytecode and report on experiences using our implementation.</description></item><item><title>Implementing a Language with Flow-Sensitive and Structural Typing on the JVM</title><link>http://whileydave.com/publications/pn11_bytecode/</link><pubDate>Sat, 01 Jan 2011 00:00:00 +0000</pubDate><guid>http://whileydave.com/publications/pn11_bytecode/</guid><description>Abstract. Dynamically typed languages are flexible and impose few burdens on the programmer. In contrast, static typing leads to software that is more efficient and has fewer errors. However, static type systems traditionally require every variable to have one type, and that relationships between types (e.g. subclassing) be declared explicitly. The Whiley language aims to hit a sweet spot between dynamic and static typing. This is achieved through structural subtyping and by typing variables in a flow-sensitive fashion.</description></item><item><title>Integrating the Actor Model into the Whiley Programming Language</title><link>http://whileydave.com/publications/jones11_engr489/</link><pubDate>Sat, 01 Jan 2011 00:00:00 +0000</pubDate><guid>http://whileydave.com/publications/jones11_engr489/</guid><description>Abstract. Introducing concurrent behaviour into a program tends to also introduce unpredictable behaviour. The actor model is an attempt to simplify concurrency and reduce such problems. The Whiley programming language is structured around concurrent processes, which are analogous to actors, but it runs on top of the Java Virtual Machine, which does not provide support for the model. This project implemented the model for JVM in a manner specific to Whiley.</description></item><item><title>JPure: a Modular Purity System for Java</title><link>http://whileydave.com/publications/pea11_cc/</link><pubDate>Sat, 01 Jan 2011 00:00:00 +0000</pubDate><guid>http://whileydave.com/publications/pea11_cc/</guid><description>Abstract: Purity Analysis is the problem of determining whether or not a method may have side-effects. This has applications in automatic parallelisation, extended static checking, and more. We present a novel purity system for Java that employs purity annotations which can be checked modularly. This is done using a flow-sensitive, intraprocedural analysis. The system exploits two properties, called freshness and locality, to increase the range of methods that can be considered pure.</description></item><item><title>OwnKit: Ownership Inference for Java</title><link>http://whileydave.com/publications/dymnikov11_msc/</link><pubDate>Sat, 01 Jan 2011 00:00:00 +0000</pubDate><guid>http://whileydave.com/publications/dymnikov11_msc/</guid><description>Abstract: Object ownership allows us to statically control run-time aliasing in order to provide a strong notion of object encapsulation. Unfortunately in order to use ownership, code must first be annotated with extra type information. This imposes a heavy burden on the programmer, and has contributed to the slow adoption of ownership. Ownership inference is the process of reconstructing ownership type information based on the existing ownership patterns in code. This thesis presents OwnKit — an automatic ownership inference tool for Java.</description></item><item><title>A Batch Algorithm for Maintaining a Topological Order</title><link>http://whileydave.com/publications/pk10_acsc/</link><pubDate>Fri, 01 Jan 2010 00:00:00 +0000</pubDate><guid>http://whileydave.com/publications/pk10_acsc/</guid><description>Abstract: The dynamic topological order problem is that of efficiently updating a topological order after some edge(s) are inserted into a graph. Much prior work exists on the unit-change version of this problem, where the order is updated after every single insertion. No previous (non-trivial) algorithms are known for the batch version of the problem, where the order is updated after every batch of insertions. We present the first such algorithm.</description></item><item><title>Computing Tutte Polynomials</title><link>http://whileydave.com/publications/hpr10_toms/</link><pubDate>Fri, 01 Jan 2010 00:00:00 +0000</pubDate><guid>http://whileydave.com/publications/hpr10_toms/</guid><description>Abstract: The Tutte polynomial of a graph is a 2-variable polynomial graph invariant of considerable importance in both combinatorics and statistical physics. It contains several other polynomial invariants, such as the chromatic polynomial and flow polynomial as partial evaluations, and various numerical invariants such as the number of spanning trees as complete evaluations. However, despite its ubiquity, there are no widely-available effective computational tools able to compute the Tutte polynomial of a general graph of reasonable size.</description></item><item><title>Edge-Selection Heuristics for Computing Tutte Polynomials</title><link>http://whileydave.com/publications/phr10_cjtcs/</link><pubDate>Fri, 01 Jan 2010 00:00:00 +0000</pubDate><guid>http://whileydave.com/publications/phr10_cjtcs/</guid><description>Abstract. The Tutte polynomial of a graph, also known as the partition function of theq-statePotts model, is a 2-variable polynomial graph invariant of considerable importance in bothcombinatorics and statistical physics. It contains several other polynomial invariants, such asthe chromatic polynomial and flow polynomial as partial evaluations, and various numericalinvariants such as the number of spanning trees as complete evaluations. We have developedthe most efficient algorithm to-date for computing the Tutte polynomial of a graph.</description></item><item><title>Understanding the Impact of Collection Contracts on Design</title><link>http://whileydave.com/publications/npn10_tools/</link><pubDate>Fri, 01 Jan 2010 00:00:00 +0000</pubDate><guid>http://whileydave.com/publications/npn10_tools/</guid><description>Abstract: Java provides a specification for a user-defined general purpose equivalence operator for objects, but collections such as Set have more stringent requirements. This inconsistency breaks polymorphism: programmers must take care to follow Set’s contract rather than the more general Object contract if their object could enter a Set. We have dynamically profiled 30 Java applications to better understand the way programmers design their objects, to determine whether they program with collections in mind.</description></item><item><title>Whiley</title><link>http://whileydave.com/projects/whiley/</link><pubDate>Fri, 01 Jan 2010 00:00:00 +0000</pubDate><guid>http://whileydave.com/projects/whiley/</guid><description>Whiley is a hybrid imperative and functional programming language which has been under development since 2009. Find out more at whiley.org or try it online at whileylabs.com. The complete source code for the compiler and theorem prover is available on GitHub. There is also a Wikipedia page and a dedicated Reddit group.</description></item><item><title>Edge-Selection Heuristics for Computing Tutte Polynomials</title><link>http://whileydave.com/publications/phr09_cats/</link><pubDate>Thu, 01 Jan 2009 00:00:00 +0000</pubDate><guid>http://whileydave.com/publications/phr09_cats/</guid><description>Abstract: The Tutte polynomial of a graph, also known as the partition function of the q-state Potts model, is a 2-variable polynomial graph invariant of considerable importance in both combinatorics and statistical physics. It contains several other polynomial invariants, such as the chromatic polynomial and flow polynomial as partial evaluations, and various numerical invariants such as the number of spanning trees as complete evaluations. We have developed the most efficient algorithm to-date for computing the Tutte polynomial of a graph.</description></item><item><title>Implementing relationships using Affinity</title><link>http://whileydave.com/publications/npn09_raool/</link><pubDate>Thu, 01 Jan 2009 00:00:00 +0000</pubDate><guid>http://whileydave.com/publications/npn09_raool/</guid><description/></item><item><title>Mocha: Type Inference for Java</title><link>http://whileydave.com/publications/male09_msc/</link><pubDate>Thu, 01 Jan 2009 00:00:00 +0000</pubDate><guid>http://whileydave.com/publications/male09_msc/</guid><description>Abstract: Static typing allows type errors to be revealed at compile time, which reduces the amount of maintenance and debugging that must occur later on. However, often the static type information included in source code is duplicate or redundant. Type inference resolves this issue by inferring the types of variables from their usage, allowing much of the type information to be omitted. This thesis formally describes Mocha, an extension to Java, which supports the inference of both local variable and field types.</description></item><item><title>Caching and Incrementalisation for the Java Query Language</title><link>http://whileydave.com/publications/wpn08_oopsla/</link><pubDate>Tue, 01 Jan 2008 00:00:00 +0000</pubDate><guid>http://whileydave.com/publications/wpn08_oopsla/</guid><description>Abstract: Many contemporary object-oriented programming languages support first-class queries or comprehensions. These language extensions make it easier for programmers to write queries, but are generally implemented no more efficiently than the code using collections, iterators, and loops that they replace. Crucially, whenever a query is re-executed, it is recomputed from scratch. We describe a general approach to optimising queries over mutable objects: query results are cached, and those caches are incrementally maintained whenever the collections and objects underlying those queries are updated.</description></item><item><title>Implementing First-Class Relationships in Java</title><link>http://whileydave.com/publications/npn08_raool/</link><pubDate>Tue, 01 Jan 2008 00:00:00 +0000</pubDate><guid>http://whileydave.com/publications/npn08_raool/</guid><description/></item><item><title>Introducing Software Modelling with Alloy at VUW</title><link>http://whileydave.com/publications/npg08_formed/</link><pubDate>Tue, 01 Jan 2008 00:00:00 +0000</pubDate><guid>http://whileydave.com/publications/npg08_formed/</guid><description/></item><item><title>Java Bytecode Verification for @NonNull Types</title><link>http://whileydave.com/publications/mppd08_cc/</link><pubDate>Tue, 01 Jan 2008 00:00:00 +0000</pubDate><guid>http://whileydave.com/publications/mppd08_cc/</guid><description>Abstract: Java’s annotation mechanism allows us to extend its type system with non-null types. However, checking such types cannot be done using the existing bytecode verification algorithm. We extend this algorithm to verify non-null types using a novel technique that identifies aliasing relationships between local variables and stack locations in the JVM. We formalise this for a subset of Java Bytecode and report on experiences using our implementation.</description></item><item><title>Object State Querying for Optimisation</title><link>http://whileydave.com/publications/pn08_mpool/</link><pubDate>Tue, 01 Jan 2008 00:00:00 +0000</pubDate><guid>http://whileydave.com/publications/pn08_mpool/</guid><description/></item><item><title>Patterns for ADT Optimisation</title><link>http://whileydave.com/publications/pn08_plop/</link><pubDate>Tue, 01 Jan 2008 00:00:00 +0000</pubDate><guid>http://whileydave.com/publications/pn08_plop/</guid><description>Abstract: Operations on abstract data types can be classified as either queries or updates — those that either query the current state, or update it. Modern object-oriented programming languages require classes/interfaces to support a predefined set of such operations. This presents a challenge for software designers, since a fixed interface can severely restrict the opportunities for optimisation. In this paper, we present two common patterns — Specific Query Optimisation and Generalised Query Optimisation — for optimising such operations.</description></item><item><title>The Java Compiler Kit</title><link>http://whileydave.com/projects/jkit/</link><pubDate>Tue, 01 Jan 2008 00:00:00 +0000</pubDate><guid>http://whileydave.com/projects/jkit/</guid><description>The Java Compiler Kit is a straightforward implementation of a Java compiler, designed with extensibility in mind. In building the JKit compiler, the aims were: firstly, to help with teaching compilers by considering an implementation for a fully fledged language (Java), rather than a stripped-down imitation language; secondly, to aid research in programming languages, compilers and verification. With JKit you can easily prototype new extensions to the Java language, or implement completely new languages and compile them down to Java Bytecode.</description></item><item><title>The Java Query Language</title><link>http://whileydave.com/publications/willis08_msc/</link><pubDate>Tue, 01 Jan 2008 00:00:00 +0000</pubDate><guid>http://whileydave.com/publications/willis08_msc/</guid><description>Abstract: This thesis describes JQL, an extension to Java which provides object querying. Object querying is an abstraction of operations over collections, including operations that combine multiple collections, which would otherwise have to be manually implemented. Such manual implementations are ‘low-level’; they force developers to specify how an operation is done, rather than what the operation to do is. Many operations over collections can easily be expressed as queries. JQL provides a Java-like syntax for expressing these queries, an optimizing query evaluator that can dynamically reconfigure query evaluation, and a caching system that allows querying to replace common collection operations with incrementally cached versions.</description></item><item><title>Visualizing the computation tree of the Tutte Polynomial</title><link>http://whileydave.com/publications/tpah08_softviz/</link><pubDate>Tue, 01 Jan 2008 00:00:00 +0000</pubDate><guid>http://whileydave.com/publications/tpah08_softviz/</guid><description/></item><item><title>A Dynamic Topological Sort Algorithm for Directed Acyclic Graphs</title><link>http://whileydave.com/publications/pk07_jea/</link><pubDate>Mon, 01 Jan 2007 00:00:00 +0000</pubDate><guid>http://whileydave.com/publications/pk07_jea/</guid><description>Abstract. We consider the problem of maintaining the topological order of a directed acyclic graph (DAG) in the presence of edge insertions and deletions. We present a new algorithm and, although this has inferior time complexity compared with the best previously known result, we find that its simplicity leads to better performance in practice. In addition, we provide an empirical comparison against the three main alternatives over a large number of random DAGs.</description></item><item><title>Efficient Field-Sensitive Pointer Analysis for C</title><link>http://whileydave.com/publications/pkh07_toplas/</link><pubDate>Mon, 01 Jan 2007 00:00:00 +0000</pubDate><guid>http://whileydave.com/publications/pkh07_toplas/</guid><description>Abstract. The subject of this paper is flow- and context-insensitive pointer analysis. We present a novel approach for precisely modelling struct variables and indirect function calls. Our method em- phasises efficiency and simplicity and is based on a simple language of set constraints. We obtain an O(v^4) bound on the time needed to solve a set of constraints from this language, where v is the number of constraint variables. This gives, for the first time, some insight into the hardness of performing field-sensitive pointer analysis of C.</description></item><item><title>Patterns of Aspect-Oriented Design</title><link>http://whileydave.com/publications/nspb07_europlop/</link><pubDate>Mon, 01 Jan 2007 00:00:00 +0000</pubDate><guid>http://whileydave.com/publications/nspb07_europlop/</guid><description>Abstract: Aspect-oriented programming languages are becoming commonplace, and programmers are accumulating experience in building and maintaining aspect-oriented systems. This paper addresses how the use of these languages affects program design: how aspect-oriented languages change the design space, which designs should be emulated and which avoided, and the strengths and weaknesses of particular kinds of design. We identify five patterns of aspect-oriented design: Spectator, Regulator, Patch, Extension, and Heterarchical Design. For each pattern, we describe the problem it solves, show how aspect-oriented language features are used in the pattern, give characteristic examples of the pattern’s use, and assess its benefits and liabilities.</description></item><item><title>Profiling with AspectJ</title><link>http://whileydave.com/publications/pwbk07_spe/</link><pubDate>Mon, 01 Jan 2007 00:00:00 +0000</pubDate><guid>http://whileydave.com/publications/pwbk07_spe/</guid><description>Abstract. This paper investigates whether AspectJ can be used for efficient profiling of Java programs. Profiling differs from other applications of AOP (e.g. tracing), since it necessitates efficient and often complex interactions with the target program. As such, it was uncertain whether AspectJ could achieve this goal. Therefore, we investigate four common profiling problems (heap usage, object lifetime, wasted time and time-spent) and report on how well AspectJ handles them. For each, we provide an efficient implementation, discuss any trade-offs or limitations and present the results of an experimental evaluation into the costs of using it.</description></item><item><title>Visualising the Tutte Polynomial Computation</title><link>http://whileydave.com/publications/tph07_sienz/</link><pubDate>Mon, 01 Jan 2007 00:00:00 +0000</pubDate><guid>http://whileydave.com/publications/tph07_sienz/</guid><description>Abstract: The Tutte polynomial is an important concept in graph theory which captures many important properties of graphs (e.g. chromatic number, number of spanning trees etc). It also provides a normalised representation that can be used as an equivalence relation on graphs and has applications in diverse areas such micro-biology and physics. A highly efficient algorithm for computing Tutte polynomials has been elsewhere developed by Haggard and Pearce. This relies on various optimisations and heuristics to improve performance; however, understanding the effect of a particular heuristic remains challenging, since the computation trees involved are very large.</description></item><item><title>AspectJ for Multilevel Security</title><link>http://whileydave.com/publications/rpw06_acp4is/</link><pubDate>Sun, 01 Jan 2006 00:00:00 +0000</pubDate><guid>http://whileydave.com/publications/rpw06_acp4is/</guid><description>Abstract: A multilevel security (MLS) system has two primary goals: first, it is intended to prevent unauthorised personnel from accessing information at higher classification than their authorisation. Second, it is intended to prevent personnel from declassifying information. Using an object-oriented approach to implementing MLS results not only with the problem of code scattering and code tangling, but also results in weaker enforcement of security. This weaker enforcement of security could be due to the inherent design of the system or due to a programming error.</description></item><item><title>Efficient Object Querying for Java</title><link>http://whileydave.com/publications/wpn06_ecoop/</link><pubDate>Sun, 01 Jan 2006 00:00:00 +0000</pubDate><guid>http://whileydave.com/publications/wpn06_ecoop/</guid><description>Abstract: Modern programming languages have little or no support for querying objects and collections. Programmers are forced to hand code such queries using nested loops, which is both cumbersome and inefficient. We demonstrate that first-class queries over objects and collections improve program readability, provide good performance and are applicable to a large number of common programming problems. We have developed a prototype extension to Java which tracks all objects in a program using AspectJ and allows first-class queries over them in the program.</description></item><item><title>Relationship Aspect Patterns</title><link>http://whileydave.com/publications/pn06_europlop/</link><pubDate>Sun, 01 Jan 2006 00:00:00 +0000</pubDate><guid>http://whileydave.com/publications/pn06_europlop/</guid><description>Abstract: Relationships between objects are almost as important to designs as the objects themselves. Most programming languages do not support relationships well, so programmers must implement relationships in terms of more primitive constructs. This paper presents a selection of proto-patterns which describe how aspects can be used to model relationships within programs. By using these patterns, programs and designs can be made smaller, more flexible, and easier to understand and maintain.</description></item><item><title>Relationship Aspects</title><link>http://whileydave.com/publications/pn06_aosd/</link><pubDate>Sun, 01 Jan 2006 00:00:00 +0000</pubDate><guid>http://whileydave.com/publications/pn06_aosd/</guid><description>Abstract: The relationships between objects in object-oriented programs are as important as the objects themselves. Unfortunately, most object-oriented programming languages provide little support for such relationships, leaving the task of implementing them entirely to the programmer. Relationships are typically hard-coded into the participating classes, resulting in tangled code that unnecessarily couples these classes together. The classes become harder to understand and cannot be reused independently. Aspect-oriented programs can model relationships explicitly, treating them as separate concerns that cross-cut their participants.</description></item><item><title>Towards a Semiotics of Object- and Aspect-Oriented Design</title><link>http://whileydave.com/publications/nbtp06_ecap/</link><pubDate>Sun, 01 Jan 2006 00:00:00 +0000</pubDate><guid>http://whileydave.com/publications/nbtp06_ecap/</guid><description>Abstract: Object-oriented design is based on the argument that objects in a program act as a simulation of objects in the real world. This paper will provide a semiotic account of object-oriented design patterns, treating an object as a sign comprised of some part of the real world, its realisation in the program, and the programmers intent about the program design (that the object model the world). The paper will then go on to discuss the developing discipline of aspect- orientation affects the representational discourses of object-orientation.</description></item><item><title>Tutte Polynomials</title><link>http://whileydave.com/projects/tutte/</link><pubDate>Sun, 01 Jan 2006 00:00:00 +0000</pubDate><guid>http://whileydave.com/projects/tutte/</guid><description>Overview. Tutte polynomials play an important role in graph theory, combinatorics, matroid theory, knot theory, and experimental physics. For example, the polynomials can be evaluated to find the number of spanning trees in a graph, the number of forests in a graph, the number of connected spanning subgraphs, the number of spanning subgraphs, and the number of acyclic orientations. In addition, Tutte polynomials specialise to chromatic polynomials, flow polynomials, Jones polynomials for alternating links, and partition functions of the q-state Potts model from statistical physics.</description></item><item><title>Some directed graph algorithms and their application to pointer analysis.</title><link>http://whileydave.com/publications/pearce05_phd/</link><pubDate>Sat, 01 Jan 2005 00:00:00 +0000</pubDate><guid>http://whileydave.com/publications/pearce05_phd/</guid><description>Abstract: This thesis is focused on improving execution time and precision of scalable pointer analysis. Such an analysis statically determines the targets of all pointer variables in a program. We formulate the analysis as a directed graph problem, where the solution can be obtained by a computation similar, in many ways, to transitive closure. As with transitive closure, identifying strongly connected components and transitive edges offers significant gains. However, our problem differs as the computation can result in new edges being added to the graph and, hence, dynamic algorithms are needed to efficiently identify these structures.</description></item><item><title>A Dynamic Algorithm for Topologically Sorting Directed Acyclic Graphs</title><link>http://whileydave.com/publications/pk04_wea/</link><pubDate>Thu, 01 Jan 2004 00:00:00 +0000</pubDate><guid>http://whileydave.com/publications/pk04_wea/</guid><description>Abstract: We consider how to maintain the topological order of a directed acyclic graph (DAG) in the presence of edge insertions and deletions. We present a new algorithm and, although this has marginally inferior time complexity compared with the best previously known result, we find that its simplicity leads to better performance in practice. In addition, we provide an empirical comparison against three alternatives over a large number of random DAG’s.</description></item><item><title>Automating Optimized Table-with-Polynomial Function Evaluation for FPGAs</title><link>http://whileydave.com/publications/lmpl04_fpl/</link><pubDate>Thu, 01 Jan 2004 00:00:00 +0000</pubDate><guid>http://whileydave.com/publications/lmpl04_fpl/</guid><description>Abstract: Function evaluation is at the core of many compute-intensive applications which perform well on reconfigurable platforms. Yet, in order to implement function evaluation efficiently, the FPGA programmer has to choose between a multitude of function evaluation methods such as table lookup, polynomial approximation, or table lookup combined with polynomial approximation. In this paper, we present a methodology and a partially automated implementation to select the best function evaluation hardware for a given function, accuracy requirement, technology mapping and optimization metrics, such as area, throughput and latency.</description></item><item><title>Dynamic Topological Sort</title><link>http://whileydave.com/projects/dts/</link><pubDate>Thu, 01 Jan 2004 00:00:00 +0000</pubDate><guid>http://whileydave.com/projects/dts/</guid><description>The problem of topologically sorting a directed graph is about arranging its nodes so that all edges go in the same direction. For example, consider the following directed graph:
A topological sort of this graph is:
There are often many possible solutions for a given graph and we are simply interested in obtaining one of them. This is a well-known problem and optimal algorithms are known which need O(v+e) time, where v is the number of nodes and e the number of edges.</description></item><item><title>Efficient Field-Sensitive Pointer Analysis for C</title><link>http://whileydave.com/publications/pkh04_paste/</link><pubDate>Thu, 01 Jan 2004 00:00:00 +0000</pubDate><guid>http://whileydave.com/publications/pkh04_paste/</guid><description>Abstract: The subject of this paper is flow- and context-insensitive pointer analysis. We present a novel approach for precisely modelling struct variables and indirect function calls. Our method emphasises efficiency and simplicity and extends the language of set-constraints. We experimentally evaluate the precision cost trade-off using a benchmark suite of 7 common C programs between 5,000 to 150,000 lines of code. Our results indicate the field-sensitive analysis is more expensive to compute, but yields significantly better precision.</description></item><item><title>Online Cycle Detection and Difference Propagation: Applications to Pointer Analysis</title><link>http://whileydave.com/publications/pkh04_sqj/</link><pubDate>Thu, 01 Jan 2004 00:00:00 +0000</pubDate><guid>http://whileydave.com/publications/pkh04_sqj/</guid><description>Abstract. This paper presents and evaluates a number of techniques to improve the execution time of interprocedural pointer analysis in the context of C programs. The analysis is formulated as a graph of set constraintsand solved using a worklist algorithm. Indirections lead to new constraints being added during this procedure.The solution process can be simplified by identifying cycles, and we present a novel online algorithm for doingthis. We also present a difference propagation scheme which avoids redundant work by tracking changes to eachsolution set.</description></item><item><title>Design Space Exploration with A Stream Compiler</title><link>http://whileydave.com/publications/mphl03_fpt/</link><pubDate>Wed, 01 Jan 2003 00:00:00 +0000</pubDate><guid>http://whileydave.com/publications/mphl03_fpt/</guid><description>Abstract: We consider speeding up general-purpose applications with hardware accelerators. Traditionally hardware accelera- tors are tediously hand-crafted to achieve top performance. ASC (A Stream Compiler) simplifies exploration of hard- ware accelerators by transforming the hardware design task into a software design process using only ’gcc’ and ’make’ to obtain a hardware netlist. ASC enables programmers to customize hardware accelerators at three levels of abstraction: the architecture level, the functional block level, and the bit level.</description></item><item><title>DJProf</title><link>http://whileydave.com/projects/djprof/</link><pubDate>Wed, 01 Jan 2003 00:00:00 +0000</pubDate><guid>http://whileydave.com/projects/djprof/</guid><description>DJProf is an experimental Java profiling tool which employs AspectJ to insert the necessary instrumentation for profiling rather than, for example, the Java Machine Profiler Interface (JVMPI). DJProf can be used to profile Java programs without modification (i.e. there is no need to recompile them for profiling) and does not require the user to have any knowledge of AspectJ. The Load-Time Weaving capability of AspectJ is utilised to make this possible.</description></item><item><title>Online Cycle Detection and Difference Propagation for Pointer Analysis</title><link>http://whileydave.com/publications/pkh03_scam/</link><pubDate>Wed, 01 Jan 2003 00:00:00 +0000</pubDate><guid>http://whileydave.com/publications/pkh03_scam/</guid><description>Abstract. This paper presents and evaluates a number of techniques to improve the execution time of interprocedural pointer analysis in the context of large C programs. The analysis is formulated as a graph of set constraints and solved using a worklist algorithm. Indirections lead to new constraints being added during this process. In this work, we present a new algorithm for online cycle detection, and a difference propagation technique which records changes in a variable’s solution.</description></item><item><title>GILK: A Dynamic Instrumentation Tool for the Linux Kernel</title><link>http://whileydave.com/publications/pkfh02_tools/</link><pubDate>Tue, 01 Jan 2002 00:00:00 +0000</pubDate><guid>http://whileydave.com/publications/pkfh02_tools/</guid><description>Abstract: This paper desribes a dynamic instrumentation tool for the Linux Kernal which allows a stock Linux kernel to be modified while in execution, with instruments implemented as kernel modules. The Intel x86 architecture poses a particular problem, due to variable length instructions, which this paper addresses for the first time. Finally we present a short case study illustrating its use in understanding i/o behaviour in the kernel. The source code is freely available for download.</description></item><item><title>GILK</title><link>http://whileydave.com/projects/gilk/</link><pubDate>Sat, 01 Jan 2000 00:00:00 +0000</pubDate><guid>http://whileydave.com/projects/gilk/</guid><description>The GILK project was part of my master&amp;rsquo;s thesis at Imperial College London. The project is all about dynamic instrumentation of the Linux Kernel. This means that a stock (i.e. without any source code modification) kernel can be instrumented whilst in execution! This is possible because the tool performs binary analysis on the kernel image to determine where it is safe to instrument. Furthermore, it makes use of the non-premtive property of the kernel to ensure that the instrumentation is safely updated.</description></item><item><title>Instrumenting the Linux Kernel</title><link>http://whileydave.com/publications/pearce00_meng/</link><pubDate>Sat, 01 Jan 2000 00:00:00 +0000</pubDate><guid>http://whileydave.com/publications/pearce00_meng/</guid><description>Abstract: An instrumentation tool has been developed for the Linux kernel that uses the relatively new technique of runtime code splicing. This permits instrumentation of a running system, without any source code modification, by redirecting the flow of control to pass through carefully written code patches.
The result is a tool that can insert arbitrary code before and after almost every basic block of an executing Linux kernel. A new twist on the original technique has been developed, called local bounce allocation, that overcomes some of the problems encountered on variable length architectures.</description></item></channel></rss>