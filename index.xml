<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Dave's Homepage</title><link>https://whileydave.com/</link><description>Recent content on Dave's Homepage</description><generator>Hugo -- gohugo.io</generator><language>en-nz</language><lastBuildDate>Sat, 16 Sep 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://whileydave.com/index.xml" rel="self" type="application/rss+xml"/><item><title>Efficient Functions in Dafny</title><link>https://whileydave.com/2023/09/16/efficient-functions-in-dafny/</link><pubDate>Sat, 16 Sep 2023 00:00:00 +0000</pubDate><guid>https://whileydave.com/2023/09/16/efficient-functions-in-dafny/</guid><description>In developing an EVM in Dafny, a key requirement is to test it against the official EVM test suite. This means it needs to be at least reasonably efficient, otherwise completing a test run becomes impractical.</description></item><item><title>Proving a Beautiful Identity in Dafny</title><link>https://whileydave.com/2023/07/17/proving-a-beautiful-identity-in-dafny/</link><pubDate>Mon, 17 Jul 2023 00:00:00 +0000</pubDate><guid>https://whileydave.com/2023/07/17/proving-a-beautiful-identity-in-dafny/</guid><description>Recently, I came across a tweet about the following identity:
This seemed quite surprising to me, though the tweet&amp;rsquo;s thread included a number of proofs. We can check the first few values easily for ourself:</description></item><item><title>On Leveraging Tests to Infer Nullable Annotations</title><link>https://whileydave.com/publications/dpc23_ecoop/</link><pubDate>Tue, 11 Jul 2023 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/dpc23_ecoop/</guid><description>Abstract:
Issues related to the dereferencing of null pointers are a pervasive and widely studied problem, and numerous static analyses have been proposed for this purpose. These are typically based on dataflow analysis, and take advantage of annotations indicating whether a type is nullable or not.</description></item><item><title>Programming Languages Going Above and Beyond</title><link>https://whileydave.com/2023/06/27/programming-languages-going-above-and-beyond/</link><pubDate>Tue, 27 Jun 2023 00:00:00 +0000</pubDate><guid>https://whileydave.com/2023/06/27/programming-languages-going-above-and-beyond/</guid><description>Having been a programmer for a long time now, I have experienced my fair share of programming languages. What strikes me the most is that programming languages have not improved much over the years.</description></item><item><title>Pattern Matching in Rust's Neverland</title><link>https://whileydave.com/2023/04/16/pattern-matching-in-rusts-neverland/</link><pubDate>Sun, 16 Apr 2023 00:00:00 +0000</pubDate><guid>https://whileydave.com/2023/04/16/pattern-matching-in-rusts-neverland/</guid><description>Recently, I&amp;rsquo;ve been working on a tool for manipulating EVM bytecode and assembly language. I wanted to describe low level bytecode and assembly language using the same datatype. At the same time, I wanted some instructions to be allowed only in assembly language but not bytecode (e.</description></item><item><title>Formal and Executable Semantics of the Ethereum Virtual Machine in Dafny</title><link>https://whileydave.com/publications/cfgpq_fm23/</link><pubDate>Mon, 06 Mar 2023 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/cfgpq_fm23/</guid><description>Abstract:
The Ethereum protocol implements a replicated state machine. The network participants keep track of the system state by: 1) agreeing on the sequence of transactions to be processed and 2) computing the state transitions that correspond to the sequence of transactions.</description></item><item><title>Formalising the Ethereum Virtual Machine in Dafny</title><link>https://whileydave.com/2023/02/06/formalising-the-ethereum-virtual-machine-in-dafny/</link><pubDate>Mon, 06 Feb 2023 00:00:00 +0000</pubDate><guid>https://whileydave.com/2023/02/06/formalising-the-ethereum-virtual-machine-in-dafny/</guid><description>Since starting at ConsenSys, the main project I have been involved with is a formalisation of the Ethereum Virtual Machine in Dafny called the &amp;ldquo;DafnyEVM&amp;rdquo;. Our goals share some similarity with Runtime Verification&amp;rsquo;s KEVM project.</description></item><item><title>Disassembling EVM Bytecode (the Basics)</title><link>https://whileydave.com/2023/01/04/disassembling-evm-bytecode-the-basics/</link><pubDate>Wed, 04 Jan 2023 00:00:00 +0000</pubDate><guid>https://whileydave.com/2023/01/04/disassembling-evm-bytecode-the-basics/</guid><description>Recently, I&amp;rsquo;ve been looking at how to disassemble (and eventually decompile) bytecode for the Ethereum Virtual Machine (EVM). This is an interesting computer science problem which I&amp;rsquo;ve been thinking about lately.</description></item><item><title>Language Design Meets Verifying Compilers (Keynote)</title><link>https://whileydave.com/publications/pea22_gpce/</link><pubDate>Sun, 13 Nov 2022 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/pea22_gpce/</guid><description>Abstract.
The dream of developing compilers that automatically verify whether or not programs meet their specifications remains an ongoing challenge. Such ``verifying compilers&amp;rsquo;&amp;rsquo; are (finally) on the verge of entering mainstream software development.</description></item><item><title>Formal Verification of a Token Contract</title><link>https://whileydave.com/2022/09/15/formal-verification-of-a-token-contract/</link><pubDate>Thu, 15 Sep 2022 00:00:00 +0000</pubDate><guid>https://whileydave.com/2022/09/15/formal-verification-of-a-token-contract/</guid><description>Following on from my previous post on verifying an auction contract in Whiley, I thought it might be useful to look at a more challenging example. A token contract is a very common form of smart contract which allows someone to create and manage their own currency.</description></item><item><title>Formalising a Simple Virtual Machine</title><link>https://whileydave.com/2022/06/28/formalising-a-simple-virtual-machine/</link><pubDate>Tue, 28 Jun 2022 00:00:00 +0000</pubDate><guid>https://whileydave.com/2022/06/28/formalising-a-simple-virtual-machine/</guid><description>Since starting my new role at ConsenSys, I have become interested in formalising virtual machines. For example, there are already some formalisations of the Ethereum Virtual Machine (e.g. in K, Lem, Coq).</description></item><item><title>Version 0.9.19</title><link>https://whileydave.com/downloads/tuttev0.9.19/</link><pubDate>Tue, 21 Jun 2022 00:00:00 +0000</pubDate><guid>https://whileydave.com/downloads/tuttev0.9.19/</guid><description>The following updates have been made:
Add support for --split with --chromatic.</description></item><item><title>Type Checking in Whiley goes Both Ways!</title><link>https://whileydave.com/2022/06/15/type-checking-in-whiley-goes-both-ways/</link><pubDate>Wed, 15 Jun 2022 00:00:00 +0000</pubDate><guid>https://whileydave.com/2022/06/15/type-checking-in-whiley-goes-both-ways/</guid><description>Type checking in Whiley is a curious thing as it goes both forwards and backwards. This is sometimes referred to as bidirectional type checking (see e.g. here and here). This is surprisingly useful in Whiley (perhaps because the language has a reasonably unusual feature set).</description></item><item><title>Whiley gets Rusty!</title><link>https://whileydave.com/2022/05/31/whiley-gets-rusty/</link><pubDate>Tue, 31 May 2022 00:00:00 +0000</pubDate><guid>https://whileydave.com/2022/05/31/whiley-gets-rusty/</guid><description>I&amp;rsquo;ve been learning Rust for a while now but, at the same time, trying to continue developing Whiley. Since Whiley was written entirely in Java, these activities were mutually exclusive and it was frustrating trying to balance things!</description></item><item><title>Verifying an Auction Contract in Whiley</title><link>https://whileydave.com/2022/05/17/verifying-an-auction-contract-in-whiley/</link><pubDate>Tue, 17 May 2022 00:00:00 +0000</pubDate><guid>https://whileydave.com/2022/05/17/verifying-an-auction-contract-in-whiley/</guid><description>Since Whiley is a general purpose verification system, I thought it might be interesting to try and verify a smart contract. Smart contracts are well suited to formal verification tools (like Whiley), as they are small and typically self-contained.</description></item><item><title>Puzzling Strong Updates in Rust</title><link>https://whileydave.com/2022/04/27/puzzling-strong-updates-in-rust/</link><pubDate>Wed, 27 Apr 2022 00:00:00 +0000</pubDate><guid>https://whileydave.com/2022/04/27/puzzling-strong-updates-in-rust/</guid><description>The idea of a strong update comes from earlier work on static analysis and, in particular, pointer analysis. To understand this, let&amp;rsquo;s imagine a hypothetical non-null analysis for C:
int* r = (int*) malloc(sizeof(int)); int** p = &amp;amp;r; At this point, our non-null analysis would conclude that p was nonnull and that r was nullable.</description></item><item><title>On the Termination of Borrow Checking in Featherweight Rust</title><link>https://whileydave.com/publications/pps22/</link><pubDate>Mon, 14 Mar 2022 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/pps22/</guid><description>Abstract: A distinguished feature of the Rust programming language is its ability to deallocate dynamically-allocated data structures as soon as they go out of scope, without relying on a garbage collector.</description></item><item><title>Language Design Meets Verifying Compilers</title><link/><pubDate>Sun, 13 Mar 2022 00:00:00 +0000</pubDate><guid/><description/></item><item><title>AtmoVis: Web Based Visualization of Air Quality Data with Interconnected Windows</title><link>https://whileydave.com/publications/pap22_envirvis/</link><pubDate>Sat, 15 Jan 2022 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/pap22_envirvis/</guid><description>Abstract:
Air quality has an adverse impact on the health of people living in areas with poor quality air. Hence monitoring is needed to understand the extent of poor air quality.</description></item><item><title>Verifying Whiley Programs with Boogie</title><link>https://whileydave.com/publications/pug22_jar/</link><pubDate>Sat, 15 Jan 2022 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/pug22_jar/</guid><description>Abstract: The quest to develop increasingly sophisticated verification systems continues unabated. Tools such as Dafny, Spec#, ESC/Java, SPARK Ada, and Whiley attempt to seamlessly integrate specification and verification into a programming language, in a similar way to type checking.</description></item><item><title>Modelling Borrow Checking in Rust</title><link>https://whileydave.com/2021/12/06/modelling-borrow-checking-in-rust/</link><pubDate>Mon, 06 Dec 2021 00:00:00 +0000</pubDate><guid>https://whileydave.com/2021/12/06/modelling-borrow-checking-in-rust/</guid><description>Recently, I&amp;rsquo;ve been working on a formalisation of borrow checking in Rust. The idea is to help people think clearly about how borrow checking works (in someways perhaps similar to the Stacked Borrows work but with a different perspective).</description></item><item><title>Compiling Whiley for Embedded Systems</title><link>https://whileydave.com/publications/anker21_comp589/</link><pubDate>Mon, 01 Nov 2021 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/anker21_comp589/</guid><description>Abstract.
Whiley is a statically typed language that supports both object-oriented as well as functional programming language paradigms. Like many other programming languages, Whiley also supports variables, primitive types (e.g. int, bool), methods, control-flow statements (e.</description></item><item><title>Transpiling Whiley to C++</title><link>https://whileydave.com/publications/mcmurray21_engr489/</link><pubDate>Mon, 01 Nov 2021 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/mcmurray21_engr489/</guid><description>Abstract. Whiley2Cpp is a plugin for the Whiley programming language that is being developed as part of this project. The plugin translates Whiley code into C++ code. Whiley is a programming language that uses an automated theorem prover to statically check programs for correctness.</description></item><item><title>Whiley to TypeScript Transpiler</title><link>https://whileydave.com/publications/rainford21_engr489/</link><pubDate>Mon, 01 Nov 2021 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/rainford21_engr489/</guid><description>Abstract. Whiley is an imperative and functional programming language that supports Extended Static Checking through formal verification. TypeScript is a gradually typed programming language that is a superset of JavaScript. The main purpose of TypeScript is to add type safety to the JavaScript language.</description></item><item><title>Verifying the Whiley Standard Library</title><link>https://whileydave.com/2021/10/27/verifying-the-whiley-standard-library/</link><pubDate>Wed, 27 Oct 2021 00:00:00 +0000</pubDate><guid>https://whileydave.com/2021/10/27/verifying-the-whiley-standard-library/</guid><description>For sometime now, its been possible to use Boogie / Z3 as a backend for verifying Whiley programs. Initially that was pretty sketchy, but it&amp;rsquo;s really starting to ramp up now.</description></item><item><title>Test-Driving the Rust Model Checker (RMC)</title><link>https://whileydave.com/2021/10/26/test-driving-the-rust-model-checker-rmc/</link><pubDate>Tue, 26 Oct 2021 00:00:00 +0000</pubDate><guid>https://whileydave.com/2021/10/26/test-driving-the-rust-model-checker-rmc/</guid><description>The Rust Model Checker (RMC) allows Rust programs to be model checked using the C Bounded Model Checker (CBMC). In essence, RMC is an extension to the Rust compiler which converts Rust&amp;rsquo;s MIR into the input language of CBMC (GOTO).</description></item><item><title>Fooling the Borrow Checker</title><link>https://whileydave.com/2021/09/01/fooling-the-borrow-checker/</link><pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate><guid>https://whileydave.com/2021/09/01/fooling-the-borrow-checker/</guid><description>An interesting question is how the Rust borrow checker decides when a borrow could still be live. This illustrates a simple example:
let mut x = 1234; let z = f(&amp;amp;x); .</description></item><item><title>Sizing Up Types in Rust</title><link>https://whileydave.com/2021/07/15/sizing-up-types-in-rust/</link><pubDate>Thu, 15 Jul 2021 00:00:00 +0000</pubDate><guid>https://whileydave.com/2021/07/15/sizing-up-types-in-rust/</guid><description>When learning Rust, understanding the difference between statically and dynamically sized types seems critical. There are some good discussions out there already (e.g. here and here). Whilst these explain the mechanics, they didn&amp;rsquo;t tell me why its done like this in Rust.</description></item><item><title>A Lightweight Formalism for Reference Lifetimes and Borrowing in Rust</title><link>https://whileydave.com/publications/pea21_toplas/</link><pubDate>Thu, 01 Apr 2021 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/pea21_toplas/</guid><description>Abstract. Rust is a relatively new programming language which has gained significant traction since its v1.0 release in 2015. Rust aims to be a systems language that competes with C/C++. A claimed advantage of Rust is a strong focus on memory safety without garbage collection.</description></item><item><title>Finding Bugs with Specification-Based Testing is Easy!</title><link/><pubDate>Thu, 25 Mar 2021 00:00:00 +0000</pubDate><guid/><description/></item><item><title>Understanding Generic Type Variance (in Whiley)</title><link>https://whileydave.com/2021/03/14/understanding-generic-type-variance-in-whiley/</link><pubDate>Sun, 14 Mar 2021 00:00:00 +0000</pubDate><guid>https://whileydave.com/2021/03/14/understanding-generic-type-variance-in-whiley/</guid><description>For languages which support generic types, an important question is deciding whether or not a type C&amp;lt;T&amp;gt; is a subtype of another related type C&amp;lt;S&amp;gt;. Since Whiley was recently extended to support generic types, its interesting to think about how this was handled.</description></item><item><title>Finding Bugs with Specification-Based Testing is Easy!</title><link>https://whileydave.com/publications/cp21_programming/</link><pubDate>Fri, 01 Jan 2021 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/cp21_programming/</guid><description>Abstract: Automated specification-based testing has a long history with several notable tools having emerged. For example, QuickCheck for Haskell focuses on testing against user-provided properties. Others, such as JMLUnit, use specifications in the form of pre- and post-conditions to drive testing.</description></item><item><title>Dynamic Cycle Detection for Lock Ordering</title><link>https://whileydave.com/2020/12/19/dynamic-cycle-detection-for-lock-ordering/</link><pubDate>Sat, 19 Dec 2020 00:00:00 +0000</pubDate><guid>https://whileydave.com/2020/12/19/dynamic-cycle-detection-for-lock-ordering/</guid><description>Recently, I discovered that an algorithm of mine from a few years back is being used in both TensorFlow and the Abseil C++ library (see here and here). That is of course pretty exciting since they are both widely used libraries!</description></item><item><title>Automated Testing for Whiley</title><link>https://whileydave.com/2020/12/02/automated-testing-for-whiley/</link><pubDate>Wed, 02 Dec 2020 00:00:00 +0000</pubDate><guid>https://whileydave.com/2020/12/02/automated-testing-for-whiley/</guid><description>Recently, the online editor for Whiley was updated with some new features. Actually, the update represents a complete rewrite of the front-end in Whiley. Obviously, I am very excited about that!</description></item><item><title>Understanding Partial Moves in Rust</title><link>https://whileydave.com/2020/11/30/understanding-partial-moves-in-rust/</link><pubDate>Mon, 30 Nov 2020 00:00:00 +0000</pubDate><guid>https://whileydave.com/2020/11/30/understanding-partial-moves-in-rust/</guid><description>Recently I&amp;rsquo;ve been digging into Rust and, whilst it&amp;rsquo;s a great language on many fronts, I do find lots of hidden complexity. One example which doesn&amp;rsquo;t get much attention is partial moves.</description></item><item><title>Profiling the Java Compiler for Improved Incremental Compiler Design</title><link>https://whileydave.com/publications/oliver20_engr489/</link><pubDate>Sun, 01 Nov 2020 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/oliver20_engr489/</guid><description>Abstract. Compiling a program is a process which can take a long time, thereby breaking up a developer&amp;rsquo;s workflow and productivity. Incremental compilation is a method which aims to solve this problem.</description></item><item><title>Putting the Semantics into Semantic Versioning</title><link/><pubDate>Sun, 18 Oct 2020 00:00:00 +0000</pubDate><guid/><description/></item><item><title>Reverse Engineering of an Obfuscated Binary</title><link>https://whileydave.com/publications/yang20_msc/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/yang20_msc/</guid><description>Abstract: Reverse engineering is an important process employed by both attackers seeking to gain entry to a system as well as the security engineers that protect it. While there are numerous tools developed for this purpose, they often can be tedious to use and rely on prior obtained domain knowledge.</description></item><item><title>Functional Reactive Programming in Whiley</title><link/><pubDate>Sat, 26 Sep 2020 00:00:00 +0000</pubDate><guid/><description/></item><item><title>The Semantics of Semantic Versioning?</title><link>https://whileydave.com/2020/09/24/the-semantics-of-semantic-versioning/</link><pubDate>Thu, 24 Sep 2020 00:00:00 +0000</pubDate><guid>https://whileydave.com/2020/09/24/the-semantics-of-semantic-versioning/</guid><description>Semantic versioning is a surprisingly interesting topic when you get into it. Recently, myself and a few colleagues (Patrick &amp;amp; Jens) have been giving it some thought (and we even wrote an essay on it)!</description></item><item><title>Whiley is Ten Years Old!</title><link>https://whileydave.com/2020/09/01/whiley-is-ten-years-old/</link><pubDate>Tue, 01 Sep 2020 00:00:00 +0000</pubDate><guid>https://whileydave.com/2020/09/01/whiley-is-ten-years-old/</guid><description>The first commit recorded in the WhileyCompiler repository on Github is dated June 25th, 2010. That means Whiley has been going for just over ten years already! Wow, time sure does fly.</description></item><item><title>Putting the Semantics into Semantic Versioning</title><link>https://whileydave.com/publications/ldp20/</link><pubDate>Tue, 04 Aug 2020 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/ldp20/</guid><description>Abstract: The long-standing aspiration for software reuse has made astonishing strides in the past few years. Many modern software development ecosystems now come with rich sets of publicly-available components contributed by the community.</description></item><item><title>Computational Resources</title><link>https://whileydave.com/publications/rp2020_crc/</link><pubDate>Wed, 01 Jan 2020 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/rp2020_crc/</guid><description/></item><item><title>AtmoVis: Visualization of Air Quality Data</title><link>https://whileydave.com/publications/powley19_msc/</link><pubDate>Tue, 01 Jan 2019 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/powley19_msc/</guid><description>Abstract: Air quality has an adverse impact on the health of people living in areas with poor quality air. Monitoring is needed to understand the effects of poor air quality. It is difficult to compare measurements to find trends and patterns between different monitoring sites when data is contained in separate data stores.</description></item><item><title>Compiling Whiley for the Ethereum Virtial Machine</title><link>https://whileydave.com/publications/kumar19_engr489/</link><pubDate>Tue, 01 Jan 2019 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/kumar19_engr489/</guid><description>Abstract. Ethereum is a blockchain based platform that supports a Turing complete contract language. However, methods of writing smart contracts have been error prone. This has resulted in many historically expensive bugs such as the DAO.</description></item><item><title>Compiling Whiley for WebAssembly</title><link>https://whileydave.com/publications/hua19_comp489/</link><pubDate>Tue, 01 Jan 2019 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/hua19_comp489/</guid><description>Abstract. Whiley is a multi-paradigm programming language which supports Extended Static Checking through formal specification. At compile time, Whiley can identify common errors which are uncaught by a type checker, including division by zero, null reference and array out of bounds errors.</description></item><item><title>Dependency Versioning in the Wild</title><link>https://whileydave.com/publications/dpstb19_msr/</link><pubDate>Tue, 01 Jan 2019 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/dpstb19_msr/</guid><description>Abstract: Many modern software systems are built on top of existing packages (modules, components, libraries). The increasing number and complexity of dependencies has given rise to automated dependency management where package managers resolve symbolic dependencies against a central repository.</description></item><item><title>Efficient compilation of a verification-friendly programming language</title><link>https://whileydave.com/publications/weng19_phd/</link><pubDate>Tue, 01 Jan 2019 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/weng19_phd/</guid><description>Abstract. This thesis develops a compiler to convert a program written in the verification friendly programming language Whiley into an efficient implementation in C. Our compiler uses a mixture of static analysis, run-time monitoring and a code generator to and faster integer types, eliminate unnecessary array copies and de-allocate unused memory without garbage collection, so that Whiley programs can be translated into C code to run fast and for long periods on general operating systems as well as limited-resource embedded devices.</description></item><item><title>On the Architecture of a (Verifying) Compiler</title><link/><pubDate>Sun, 16 Dec 2018 00:00:00 +0000</pubDate><guid/><description/></item><item><title>Whiley Memory Analyser</title><link>https://whileydave.com/publications/russel18_engr489/</link><pubDate>Thu, 01 Nov 2018 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/russel18_engr489/</guid><description>Abstract. The Whiley Memory Analyser (WyMA) is a tool for performing a static analysis on Whiley files to evaluate their worst case memory consumption. We evaluate worst case memory consumption to avoid potential errors in systems with limited memory, and it is evaluated statically to ensure it is the absolute worst case.</description></item><item><title>Verifying leftPad() in Whiley</title><link>https://whileydave.com/2018/04/23/verifying-leftpad-in-whiley/</link><pubDate>Mon, 23 Apr 2018 00:00:00 +0000</pubDate><guid>https://whileydave.com/2018/04/23/verifying-leftpad-in-whiley/</guid><description>The leftPad(string,int) function simply pads a string up to a given size by inserted spaces at the beginning. For example, leftPad(&amp;quot;hello&amp;quot;,8) produces &amp;quot; hello&amp;quot;. This little function shot to fame in 2016 when a developer pulled all his modules from NPM, of which one provided the leftPad() functionality.</description></item><item><title>A Symmetry Metric for Graphs and Line Diagrams</title><link>https://whileydave.com/publications/kmp18_diagrams/</link><pubDate>Mon, 01 Jan 2018 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/kmp18_diagrams/</guid><description>Abstract: Symmetry is often considered a desirable feature of dia- grams. However, quantifying the exact amount of symmetry present is often difficult. We propose a novel symmetry metric that can score the amount of rotational, translational, and reflective symmetry present in a graph or line diagram.</description></item><item><title>An Introduction to Software Verification with Whiley</title><link>https://whileydave.com/publications/pug18_etss/</link><pubDate>Mon, 01 Jan 2018 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/pug18_etss/</guid><description>Abstract: This tutorial introduces the basic ideas of software specification and verification, which are important techniques for assuring the quality of software and eliminating common kinds of errors such as buffer overflow.</description></item><item><title>Inferring invariants from postconditions in Whiley</title><link>https://whileydave.com/publications/pope18_engr489/</link><pubDate>Mon, 01 Jan 2018 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/pope18_engr489/</guid><description>Abstract. For the formal verification of programs, loop invariants must be used to ensure the verifier understands the properties of a loop. These invariants are often trivial, and many are common between loops.</description></item><item><title>On Declarative Rewriting for Sound and Complete Union, Intersection and Negation Types</title><link>https://whileydave.com/publications/pea18_jvlc/</link><pubDate>Mon, 01 Jan 2018 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/pea18_jvlc/</guid><description>Abstract. Implementing the type system of a programming language is a critical task that is oftendone in an ad-hoc fashion. Whilst this makes it hard to ensure the system is sound, italso makes it difficult to extend as the language evolves.</description></item><item><title>QuickCheck for Whiley</title><link>https://whileydave.com/publications/chin18_engr489/</link><pubDate>Mon, 01 Jan 2018 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/chin18_engr489/</guid><description>Abstract. Whiley is a programming language that verifies code using formal specifications to improve software quality. Whiley contains a verifying compiler which can identify common bugs. However, the compiler is limited in its ability to discover bugs and may take a long time to verify large programs.</description></item><item><title>Rewriting for Sound and Complete Union, Intersection and Negation Types</title><link>https://whileydave.com/publications/pea18_gpce/</link><pubDate>Mon, 01 Jan 2018 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/pea18_gpce/</guid><description>Abstract: Implementing the type system of a programming language is a critical task that is often done in an ad-hoc fashion. Whilst this makes it hard to ensure the system is sound, it also makes it difficult to extend as the language evolves.</description></item><item><title>Towards Compilation of an Imperative Language for FPGAs</title><link>https://whileydave.com/publications/ppp18_vmil/</link><pubDate>Mon, 01 Jan 2018 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/ppp18_vmil/</guid><description>Abstract: Field-Programmable Gate Arrays (FPGA’s) have been around since the early 1980s and have now achieved relatively widespread use. For example, FPGAs are routinely used for high-performance computing, financial applications, seismic modelling, DNA sequence alignment, software defined networking and, occasionally, are even found in smartphones.</description></item><item><title>Version 0.9.18</title><link>https://whileydave.com/downloads/tuttev0.9.18/</link><pubDate>Mon, 01 Jan 2018 00:00:00 +0000</pubDate><guid>https://whileydave.com/downloads/tuttev0.9.18/</guid><description>The following updates have been made:
Updated code to eliminate C++ warnings and errors.
Addresses issue on MacOS High Sierra.</description></item><item><title>Verifying Bubble Sort in Whiley</title><link>https://whileydave.com/2017/12/19/verifying-bubble-sort-in-whiley/</link><pubDate>Tue, 19 Dec 2017 00:00:00 +0000</pubDate><guid>https://whileydave.com/2017/12/19/verifying-bubble-sort-in-whiley/</guid><description>Bubble sort is a classic sorting algorithm with lots of well-known issues. It&amp;rsquo;s been a long time since I thought much about this algorithm. But, it turns out to be an interesting verification example for Whiley, as it has some interesting loop invariants.</description></item><item><title>Whiley Demo @ Oracle Labs!!</title><link>https://whileydave.com/2017/08/24/whiley-demo-oracle-labs/</link><pubDate>Thu, 24 Aug 2017 00:00:00 +0000</pubDate><guid>https://whileydave.com/2017/08/24/whiley-demo-oracle-labs/</guid><description>Recently, I gave a demo of Whiley at Oracle Labs in Brisbane which they have kindly put up on YouTube:
The actual demo itself starts around 11:30s, so you might want to skip on to that.</description></item><item><title>What does the Future of Programming Look Like?</title><link/><pubDate>Mon, 24 Jul 2017 00:00:00 +0000</pubDate><guid/><description/></item><item><title>Contracts in the Wild: A Study of Java Programs</title><link/><pubDate>Tue, 27 Jun 2017 00:00:00 +0000</pubDate><guid/><description/></item><item><title>On the Internet and Object-Oriented Programming</title><link>https://whileydave.com/2017/06/21/on-the-internet-and-object-oriented-programming/</link><pubDate>Wed, 21 Jun 2017 00:00:00 +0000</pubDate><guid>https://whileydave.com/2017/06/21/on-the-internet-and-object-oriented-programming/</guid><description>The rise of the internet over the last, say, two decades has been pretty unstoppable (we all know that). But, is it now affecting the prominence of object-oriented programming? I&amp;rsquo;m going to try and argue in this post that: yes, it is.</description></item><item><title>Property Syntax in Whiley</title><link>https://whileydave.com/2017/03/28/property-syntax-in-whiley/</link><pubDate>Tue, 28 Mar 2017 00:00:00 +0000</pubDate><guid>https://whileydave.com/2017/03/28/property-syntax-in-whiley/</guid><description>Recently, I gave a demo which showed off thew new &amp;ldquo;Property Syntax&amp;rdquo; in Whiley. Whilst this is still in the devel branch it will make its way, soon enough, into the next release.</description></item><item><title>On Memory Management and Rust</title><link>https://whileydave.com/2017/02/15/on-memory-management-and-rust/</link><pubDate>Wed, 15 Feb 2017 00:00:00 +0000</pubDate><guid>https://whileydave.com/2017/02/15/on-memory-management-and-rust/</guid><description>Rust is definitely one of the more interesting new programming language I&amp;rsquo;ve come across recently. Memory management is definitely Rust&amp;rsquo;s &amp;ldquo;thing&amp;rdquo;, and the language wants to have its cake and eat it (so to speak).</description></item><item><title>Array Programming in Whiley</title><link>https://whileydave.com/publications/pea17_array/</link><pubDate>Sun, 01 Jan 2017 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/pea17_array/</guid><description>Abstract: Arrays are a fundamental mechanism for developing and reasoning about programs. Using them, one can easily encode a range of important algorithms from various domains, such as for sorting, graph traversal, heap manipulation and more.</description></item><item><title>Classless Object Semantics</title><link>https://whileydave.com/publications/jones17_phd/</link><pubDate>Sun, 01 Jan 2017 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/jones17_phd/</guid><description>Abstract: Objects have been categorised into classes that declare and implement their behaviour ever since the paradigm of object-orientation in programming languages was first conceived. Classes have an integral role in the design and theory of object-oriented languages, and often appear alongside objects as a foundational concept of the paradigm in many theoretical models.</description></item><item><title>Compiling Whiley to FPGAs</title><link>https://whileydave.com/publications/pauget17_project/</link><pubDate>Sun, 01 Jan 2017 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/pauget17_project/</guid><description>Abstract. Improving code performances lies more and more in the relevant use of computational helpers. Computing platforms like OpenCL or CUDA that enable to relocate resource consuming calculations to graphics processing unit (GPU) are now ordinary.</description></item><item><title>Contracts in the Wild: A Study of Java Programs</title><link>https://whileydave.com/publications/dpjb17_ecoop/</link><pubDate>Sun, 01 Jan 2017 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/dpjb17_ecoop/</guid><description>Abstract: The use of formal contracts has long been advocated as an approach to develop programs that are provably correct. However, the reality is that adoption of contracts has been slow in practice.</description></item><item><title>Making Whiley Boogie!</title><link>https://whileydave.com/publications/upg17_ifm/</link><pubDate>Sun, 01 Jan 2017 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/upg17_ifm/</guid><description>Abstract: The quest to develop increasingly sophisticated verification systems continues unabated. Tools such as Dafny, Spec#, ESC/Java, SPARK Ada, and Whiley attempt to seamlessly integrate specification and verification into a programming language, in a similar way to type checking.</description></item><item><title>Understanding Effective Unions in Whiley</title><link>https://whileydave.com/2016/12/09/understanding-effective-unions-in-whiley/</link><pubDate>Fri, 09 Dec 2016 00:00:00 +0000</pubDate><guid>https://whileydave.com/2016/12/09/understanding-effective-unions-in-whiley/</guid><description>The concept of effective union types in Whiley exposes some interesting features worth considering. In particular, they result in a separation between the readable and writeable view of a type. But, we&amp;rsquo;re getting ahead of ourselves!</description></item><item><title>Mixfix Function Syntax for Whiley</title><link>https://whileydave.com/2016/11/15/mixfix-function-syntax-for-whiley/</link><pubDate>Tue, 15 Nov 2016 00:00:00 +0000</pubDate><guid>https://whileydave.com/2016/11/15/mixfix-function-syntax-for-whiley/</guid><description>Today I saw an interesting talk about mix-fix function syntax. The idea is to allow a more complex syntax for declaring and calling functions, rather than the very common &amp;ldquo;uniform&amp;rdquo; style.</description></item><item><title>Simulating and Visualising a Model Railway</title><link>https://whileydave.com/publications/hulst16_engr489/</link><pubDate>Tue, 01 Nov 2016 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/hulst16_engr489/</guid><description>Abstract. This project is concerned with creating a software simulation and visualisation of a model railway to improve the efficiency of testing software controllers. Testing a train controller on a physical railway is time consuming and limited by what is physically available to test on.</description></item><item><title>Program Specification in Practice?</title><link>https://whileydave.com/2016/09/01/program-specification-in-practice/</link><pubDate>Thu, 01 Sep 2016 00:00:00 +0000</pubDate><guid>https://whileydave.com/2016/09/01/program-specification-in-practice/</guid><description>Recently, as part of our Programming Languages Reading group, we looked at the paper &amp;ldquo;Contracts in Practice&amp;rdquo; by Estler et al., (see here for a copy). This is quite an interesting paper and the authors perform an empirical investigation as to how contracts are used by programmers in practice.</description></item><item><title>Flow Typing with Constrained Types</title><link>https://whileydave.com/2016/08/03/flow-typing-with-constrained-types/</link><pubDate>Wed, 03 Aug 2016 00:00:00 +0000</pubDate><guid>https://whileydave.com/2016/08/03/flow-typing-with-constrained-types/</guid><description>Flow-sensitive typing (a.k.a. &amp;ldquo;Flow Typing&amp;rdquo;) is definitely getting more popular these days. Ceylon, Kotlin, TypeScript, Racket, Whiley all support flow typing in some form. Then, of course, there&amp;rsquo;s Facebook Flow and the list goes on!</description></item><item><title>Reference Lifetimes in Whiley</title><link>https://whileydave.com/2016/05/28/reference-lifetimes-in-whiley/</link><pubDate>Sat, 28 May 2016 00:00:00 +0000</pubDate><guid>https://whileydave.com/2016/05/28/reference-lifetimes-in-whiley/</guid><description>The concept of lifetimes was pioneered in the Rust programming language, and builds on earlier notions of regions and ownership types. Lifetimes are considered one of Rust&amp;rsquo;s &amp;ldquo;most unique and compelling features&amp;rdquo;.</description></item><item><title>Contractive and Uninhabited Types in Whiley</title><link>https://whileydave.com/2016/04/21/contractive-and-uninhabited-types-in-whiley/</link><pubDate>Thu, 21 Apr 2016 00:00:00 +0000</pubDate><guid>https://whileydave.com/2016/04/21/contractive-and-uninhabited-types-in-whiley/</guid><description>An interesting feature of Whiley is that it supports true recursive types. These are surprisingly tricky to get right, and recently we came across some interesting examples that the Whiley compiler should (but doesn&amp;rsquo;t) check for.</description></item><item><title>A Mechanical Soundness Proof for Subtyping over Recursive Types</title><link>https://whileydave.com/publications/jp16_ftfjp/</link><pubDate>Fri, 01 Jan 2016 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/jp16_ftfjp/</guid><description>Abstract: Structural type systems provide an interesting alternative to the more common nominal typing scheme. Several existing languages employ structural types in some form, including Modula-3, Scala and various extensions proposed for Java.</description></item><item><title>A Space Efficient Algorithm for Detecting Strongly Connected Components</title><link>https://whileydave.com/publications/pea16_ipl/</link><pubDate>Fri, 01 Jan 2016 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/pea16_ipl/</guid><description>Abstract. Tarjan’s algorihm for finding the strongly connected components of a directed graph is widely used and acclaimed. His original algorithm required at most v(2 + 5w) bits of storage, where w is the machine’s word size, whilst Nuutila and Soisalon-Soininen reduced this to v(1 + 4w).</description></item><item><title>Lifetime Analysis for Whiley</title><link>https://whileydave.com/publications/schweizer16_msc/</link><pubDate>Fri, 01 Jan 2016 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/schweizer16_msc/</guid><description>Abstract. Safety critical environments require high programming standards. Verification is a way to prove absence of certain faults and to make sure that a program meets a given specification. Unfortunately, most modern programming languages do not actively support verification.</description></item><item><title>Version 0.9.17</title><link>https://whileydave.com/downloads/tuttev0.9.17/</link><pubDate>Fri, 01 Jan 2016 00:00:00 +0000</pubDate><guid>https://whileydave.com/downloads/tuttev0.9.17/</guid><description>The following updates have been made:
Added support for the --split-edges option. This allows splitting a graph based on the number of edges, rather than the number of vertices.</description></item><item><title>Encoding C Strings in Whiley</title><link>https://whileydave.com/2015/11/12/encoding-c-strings-in-whiley/</link><pubDate>Thu, 12 Nov 2015 00:00:00 +0000</pubDate><guid>https://whileydave.com/2015/11/12/encoding-c-strings-in-whiley/</guid><description>In this post, we&amp;rsquo;re going to consider representing the classic C string in Whiley. This turns out to be useful as we can then try to verify properties about functions which operate on C strings (e.</description></item><item><title>Verifying Software with Whiley</title><link>https://whileydave.com/2015/10/06/verifying-software-with-whiley/</link><pubDate>Tue, 06 Oct 2015 00:00:00 +0000</pubDate><guid>https://whileydave.com/2015/10/06/verifying-software-with-whiley/</guid><description>A couple of weeks back, I gave a presentation to the Wellington Java User Group. The talk provides a useful introduction to verifying software in Whiley, and shows a bunch of interesting examples.</description></item><item><title>Introductory Lecture on Verification in Whiley</title><link>https://whileydave.com/2015/09/22/introductory-lecture-on-verification-in-whiley/</link><pubDate>Tue, 22 Sep 2015 00:00:00 +0000</pubDate><guid>https://whileydave.com/2015/09/22/introductory-lecture-on-verification-in-whiley/</guid><description>We&amp;rsquo;ve started using Whiley again in my second year course Formal Foundations of Programming. The aim of this course is to introduce students into a range of techniques related to software correctness.</description></item><item><title>The Whiley Programming Language</title><link/><pubDate>Wed, 26 Aug 2015 00:00:00 +0000</pubDate><guid/><description/></item><item><title>Whiley as a Research Project</title><link/><pubDate>Mon, 23 Mar 2015 00:00:00 +0000</pubDate><guid/><description/></item><item><title>My ATtiny85 Games Console</title><link>https://whileydave.com/2015/01/27/my-attiny85-games-console/</link><pubDate>Tue, 27 Jan 2015 00:00:00 +0000</pubDate><guid>https://whileydave.com/2015/01/27/my-attiny85-games-console/</guid><description>One my goals for Whiley in 2015 is to focus more on embedded systems (see here for more). A recent project of ours was compiling Whiley code to run on a QuadCopter and this identified several challenges here.</description></item><item><title>Comparing Graph Layouts for Vertex Selection Tasks</title><link>https://whileydave.com/publications/kpm15_ozchi/</link><pubDate>Thu, 01 Jan 2015 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/kpm15_ozchi/</guid><description>Abstract: Different graph layouts can affect a user’s ability to complete both passive understanding and active interaction tasks. While most research exploring the effects of graph layout looks at a user’s ability to accomplish a passive understanding task, this paper’s novel contribution is looking at their ability to complete a selection task.</description></item><item><title>Designing a Verifying Compiler: Lessons Learned from Developing Whiley</title><link>https://whileydave.com/publications/pg15_scp/</link><pubDate>Thu, 01 Jan 2015 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/pg15_scp/</guid><description>Abstract. An ongoing challenge for computer science is the development of a tool which automati- cally verifies programs meet their specifications, and are free from runtime errors such as divide-by-zero, array out-of-bounds and null dereferences.</description></item><item><title>Developing a Whiley-to-JavaScript Translator</title><link>https://whileydave.com/publications/slater15_engr489/</link><pubDate>Thu, 01 Jan 2015 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/slater15_engr489/</guid><description>Abstract. Executing Whiley in the web browser requires a server for processing. With many people using Whiley in the web browser simultaneously, this server can become very slow. JavaScript is programming language designed to execute in the web browser without a server.</description></item><item><title>Identifying Redundant Test Cases</title><link>https://whileydave.com/publications/shaw15_engr489/</link><pubDate>Thu, 01 Jan 2015 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/shaw15_engr489/</guid><description>Abstract. This project investigates tracing the method call information of Java JUnit Tests and using the information to identify redundant tests in a test suite. There are a variety of different methods implemented (and experimented on) to identify redundancy within a suite.</description></item><item><title>Integer Range Analysis for Whiley on Embedded Systems</title><link>https://whileydave.com/publications/pea15_seus/</link><pubDate>Thu, 01 Jan 2015 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/pea15_seus/</guid><description>Abstract: Programs written in the Whiley programming language are verified at compile-time to ensure all function specifications are met. The purpose of doing this is to eliminate as many software bugs as possible and, thus, Whiley is ideally suited for use in safety-critical systems.</description></item><item><title>Some Usability Hypotheses for Verification</title><link>https://whileydave.com/publications/pea15_plateau/</link><pubDate>Thu, 01 Jan 2015 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/pea15_plateau/</guid><description>Abstract: The idea of specifying and verifying software to eliminate errors has been studied extensively over the last three decades or more. Recent advances in automated theorem proving have given rise to a range of new verification tools being developed.</description></item><item><title>The Whiley Rewrite Language (WyRL)</title><link>https://whileydave.com/publications/pea15_sle/</link><pubDate>Thu, 01 Jan 2015 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/pea15_sle/</guid><description>Abstract: The Whiley Rewrite Language (WyRL) is a standalone tool providing a domain-specific declarative rewrite language and code generator. The tool is currently used to generate a critical component of the Whiley verifying compiler, namely the automated theorem prover.</description></item><item><title>Verification with Data from Untrusted Sources</title><link>https://whileydave.com/2014/12/09/verification-with-data-from-untrusted-sources/</link><pubDate>Tue, 09 Dec 2014 00:00:00 +0000</pubDate><guid>https://whileydave.com/2014/12/09/verification-with-data-from-untrusted-sources/</guid><description>Recently, I was listening to the latest edition of the Illegal Argument podcast, and it turns out they were discussing Whiley! (about 103:16 minutes in). The discussion was about how verification interacts with data from an untrusted source (e.</description></item><item><title>A Story of Cast Expressions</title><link>https://whileydave.com/2014/09/05/a-story-of-cast-expressions/</link><pubDate>Fri, 05 Sep 2014 00:00:00 +0000</pubDate><guid>https://whileydave.com/2014/09/05/a-story-of-cast-expressions/</guid><description>Issue #427 &amp;ldquo;Bug with Dereferencing Array Types&amp;rdquo; seemed like just another bug. Submitted by a user last week (@Matt&amp;ndash;), I didn&amp;rsquo;t think too much of it. But, as sometimes happens, appearances can be deceiving.</description></item><item><title>Loop Variant Relations</title><link>https://whileydave.com/2014/07/10/loop-variant-relations/</link><pubDate>Thu, 10 Jul 2014 00:00:00 +0000</pubDate><guid>https://whileydave.com/2014/07/10/loop-variant-relations/</guid><description>Proving that a loop always terminates is a common requirement when verifying software. The usual approach to doing this is to provide a loop variant function. This is typically an integer expression which decreases on every iteration of the loop.</description></item><item><title>Understanding Ghost Variables in Software Verification</title><link>https://whileydave.com/2014/06/20/understanding-ghost-variables-in-software-verification/</link><pubDate>Fri, 20 Jun 2014 00:00:00 +0000</pubDate><guid>https://whileydave.com/2014/06/20/understanding-ghost-variables-in-software-verification/</guid><description>Verification tools often support the use of ghost variables to help in the verification process. A ghost variable is not needed for the program to execute, and will not be compiled into object code.</description></item><item><title>Loop Invariants and Do/While Statements</title><link>https://whileydave.com/2014/05/15/loop-invariants-and-do/while-statements/</link><pubDate>Thu, 15 May 2014 00:00:00 +0000</pubDate><guid>https://whileydave.com/2014/05/15/loop-invariants-and-do/while-statements/</guid><description>Recently, I encountered what I thought was a bug in the Whiley Compiler. The issue related to the current treatment of do/while loops and loop invariants. Having now spent a fair bit of time researching the issue, the answer is not so clear.</description></item><item><title>Loop invariants and Break Statements</title><link>https://whileydave.com/2014/05/02/loop-invariants-and-break-statements/</link><pubDate>Fri, 02 May 2014 00:00:00 +0000</pubDate><guid>https://whileydave.com/2014/05/02/loop-invariants-and-break-statements/</guid><description>In this article, I&amp;rsquo;ll look at some interesting issues relating to the use of break statements within loops, and how this affects the idea of a loop invariant. For some general background on writing loop invariants in Whiley, see my previous post.</description></item><item><title>Flying the CrazyFlie Quadcopter!</title><link>https://whileydave.com/2014/03/02/flying-the-crazyflie-quadcopter/</link><pubDate>Sun, 02 Mar 2014 00:00:00 +0000</pubDate><guid>https://whileydave.com/2014/03/02/flying-the-crazyflie-quadcopter/</guid><description>Last week, my CrazyFlie nano-quadcopter finally arrived and, since then, I&amp;rsquo;ve been learning how to fly! The copter is much smaller than I was expecting, and it requires you to solder a few bits together.</description></item><item><title>More Tracked Arduino Fun!</title><link>https://whileydave.com/2014/01/31/more-tracked-arduino-fun/</link><pubDate>Fri, 31 Jan 2014 00:00:00 +0000</pubDate><guid>https://whileydave.com/2014/01/31/more-tracked-arduino-fun/</guid><description>Recently, I&amp;rsquo;ve been upgrading my tracked arduino robot with a few more sensors. Check out the video:
The robot has two medium range IR sensors (front and back), as well as a downward facing short-range IR sensor.</description></item><item><title>Thoughts on Parsing Whiley (and Indentation Syntax)</title><link>https://whileydave.com/2014/01/23/thoughts-on-parsing-whiley-and-indentation-syntax/</link><pubDate>Thu, 23 Jan 2014 00:00:00 +0000</pubDate><guid>https://whileydave.com/2014/01/23/thoughts-on-parsing-whiley-and-indentation-syntax/</guid><description>Recently, I have been reworking the Whiley compiler&amp;rsquo;s parser to make it more robust. Doing this has opened up some interesting issues, which I thought were worth discussing. Whiley uses indentation syntax without explicit end-of-statement terminators (e.</description></item><item><title>An Empirical Evaluation of Force-Directed Graph Layout</title><link>https://whileydave.com/publications/klapaukh14_phd/</link><pubDate>Wed, 01 Jan 2014 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/klapaukh14_phd/</guid><description>Abstract: Force-directed graph layout is a widely used algorithm for the automatic layout of graphs. Little experimental work has been done exploring the behaviour of the algorithm under a variety of conditions.</description></item><item><title>Demonstrating Whiley on an Embedded System</title><link>https://whileydave.com/publications/stevens14_engr489/</link><pubDate>Wed, 01 Jan 2014 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/stevens14_engr489/</guid><description>Abstract. Developing and verifying the software for safety critical embedded systems can be difficult and expensive due to unique constraints, including limited RAM and minimalist operating systems. This report looks at Whiley, a verifying compiler, which is intended to improve the correctness of code on a variety of systems.</description></item><item><title>Graceful Language Extensions and Interfaces</title><link>https://whileydave.com/publications/homer14_phd/</link><pubDate>Wed, 01 Jan 2014 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/homer14_phd/</guid><description>Abstract: Grace is a programming language under development aimed at education. Grace is object-oriented, imperative, and block-structured, and intended for use in first- and second-year object-oriented programming courses. We present a number of language features we have designed for Grace and implemented in our self-hosted compiler.</description></item><item><title>Maintaining Private Views in Java</title><link>https://whileydave.com/publications/haslett14_msc/</link><pubDate>Wed, 01 Jan 2014 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/haslett14_msc/</guid><description>Abstract: When developers collaborate on a project there are times when the code diverges. When this happens the code may need to be refactored to best suit the changes before they are applied.</description></item><item><title>Software Language Engineering - 7th International Conference</title><link>https://whileydave.com/publications/cpbv14_sle/</link><pubDate>Wed, 01 Jan 2014 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/cpbv14_sle/</guid><description>Proceedings of the 7th International Conference on Software Language Engineering (SLE). See the conference homepage here.</description></item><item><title>Towards a Vertex and Edge Label Aware Force Directed Layout Algorithm</title><link>https://whileydave.com/publications/kpm14_acsc/</link><pubDate>Wed, 01 Jan 2014 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/kpm14_acsc/</guid><description>Abstract: Many automatic graph layout algorithms can cause shaped vertices and edge labels (which have a size when drawn on the screen) to overlap in the resulting visualisation. Overlaps can hide information that users expect to see in cases where the graph is small.</description></item><item><title>Verifying Whiley Programs using an Off-the-Shelf SMT Solver</title><link>https://whileydave.com/publications/wylde14_engr489/</link><pubDate>Wed, 01 Jan 2014 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/wylde14_engr489/</guid><description>Abstract. This project investigated the integration of external theorem proving tools with Whiley — specifically, Satisfiability Modulo Theories (SMT) solvers — to increase the number of verifiable Whiley programs. The current verifier, the Whiley Constraint Solver (WyCS), is limited and hence there is a difficulty in verifying Whiley programs.</description></item><item><title>Thoughts on Writing Loop Invariants</title><link>https://whileydave.com/2013/11/19/thoughts-on-writing-loop-invariants/</link><pubDate>Tue, 19 Nov 2013 00:00:00 +0000</pubDate><guid>https://whileydave.com/2013/11/19/thoughts-on-writing-loop-invariants/</guid><description>As the Whiley system is taking better shape every day, I&amp;rsquo;m starting to play around more and discover things. In particular, there are some surprising issues surrounding while loops and their loop invariants.</description></item><item><title>The Dafny Tutorial at SPLASH'13</title><link>https://whileydave.com/2013/11/01/the-dafny-tutorial-at-splash13/</link><pubDate>Fri, 01 Nov 2013 00:00:00 +0000</pubDate><guid>https://whileydave.com/2013/11/01/the-dafny-tutorial-at-splash13/</guid><description>Today I was attending the Dafny tutorial given by Rustan Leino at SPLASH'13. I have to say that this was the highlight of the conference for me. In case you haven&amp;rsquo;t come across it before, Dafny is a programming language designed for software verification.</description></item><item><title>Understanding why Union Types are useful</title><link>https://whileydave.com/2013/07/31/understanding-why-union-types-are-useful/</link><pubDate>Wed, 31 Jul 2013 00:00:00 +0000</pubDate><guid>https://whileydave.com/2013/07/31/understanding-why-union-types-are-useful/</guid><description>The Whiley programming language uses union types as a way of combining types together. Here&amp;rsquo;s a simple example to illustrate:
function indexOf(string str, char c) =&amp;gt; null|int: for i in 0.</description></item><item><title>The Architecture of Verification in Whiley</title><link>https://whileydave.com/2013/06/26/the-architecture-of-verification-in-whiley/</link><pubDate>Wed, 26 Jun 2013 00:00:00 +0000</pubDate><guid>https://whileydave.com/2013/06/26/the-architecture-of-verification-in-whiley/</guid><description>As the Whiley compiler continues to evolve, certain aspects of its architecture are really starting to mature. One of the more recent pieces to take shape is the verification pipeline. This is the process by which a Whiley file is converted into a series of verification conditions, which are then checked by the automated theorem prover.</description></item><item><title>Whiley at the Melbourne Java User Group</title><link>https://whileydave.com/2013/06/19/whiley-at-the-melbourne-java-user-group/</link><pubDate>Wed, 19 Jun 2013 00:00:00 +0000</pubDate><guid>https://whileydave.com/2013/06/19/whiley-at-the-melbourne-java-user-group/</guid><description>A few weeks ago, I was in Melbourne attending the Australasian Software Engineering Conference and, whilst I was there, I gave a talk on Whiley at the Melbourne Java Users Group.</description></item><item><title>Dave Pearce on Whiley</title><link/><pubDate>Wed, 05 Jun 2013 00:00:00 +0000</pubDate><guid/><description/></item><item><title>Input / Output and the Object-Oriented Paradigm</title><link>https://whileydave.com/2013/05/16/input-/-output-and-the-object-oriented-paradigm/</link><pubDate>Thu, 16 May 2013 00:00:00 +0000</pubDate><guid>https://whileydave.com/2013/05/16/input-/-output-and-the-object-oriented-paradigm/</guid><description>Today, more then ever before, I/O dominates what software is about. Of course, it&amp;rsquo;s always been important but, with increasing bandwidths, I/O seems to be what most programs now spend most of their time doing.</description></item><item><title>Iso-Recursive versus Equi-Recursive Types</title><link>https://whileydave.com/2013/04/21/iso-recursive-versus-equi-recursive-types/</link><pubDate>Sun, 21 Apr 2013 00:00:00 +0000</pubDate><guid>https://whileydave.com/2013/04/21/iso-recursive-versus-equi-recursive-types/</guid><description>An important component of the Whiley language is the use of recursive data types. Whilst these are similar to the algebraic data types found in languages like Haskell, they are also more powerful since Whiley employs a structural type system.</description></item><item><title>Compile-Time Verification and I/O</title><link>https://whileydave.com/2013/04/09/compile-time-verification-and-i/o/</link><pubDate>Tue, 09 Apr 2013 00:00:00 +0000</pubDate><guid>https://whileydave.com/2013/04/09/compile-time-verification-and-i/o/</guid><description>A surprisingly common question people ask me when I talk about compile-time checking of pre-/post-conditions and invariants is: how do you deal with I/O?
To understand what the difficulty is, let&amp;rsquo;s consider a simple example in Whiley:</description></item><item><title>Understanding Loop Invariants in Whiley</title><link>https://whileydave.com/2013/01/29/understanding-loop-invariants-in-whiley/</link><pubDate>Tue, 29 Jan 2013 00:00:00 +0000</pubDate><guid>https://whileydave.com/2013/01/29/understanding-loop-invariants-in-whiley/</guid><description>In this article, I&amp;rsquo;ll look at a common problem one encounters when verifying programs: namely, writing loop invariants. In short, a loop invariant is a property of the loop which:</description></item><item><title>Writing Loop Invariants in Whiley</title><link/><pubDate>Sun, 27 Jan 2013 00:00:00 +0000</pubDate><guid/><description/></item><item><title>Whiley Puzzler</title><link>https://whileydave.com/2013/01/14/whiley-puzzler/</link><pubDate>Mon, 14 Jan 2013 00:00:00 +0000</pubDate><guid>https://whileydave.com/2013/01/14/whiley-puzzler/</guid><description>I was having an interesting discussion with a colleague today about various aspects of Whiley, and we came up with an interesting bit of example code which is something of a puzzler.</description></item><item><title>Whiley Features in the Dominion Post!</title><link>https://whileydave.com/2013/01/10/whiley-features-in-the-dominion-post/</link><pubDate>Thu, 10 Jan 2013 00:00:00 +0000</pubDate><guid>https://whileydave.com/2013/01/10/whiley-features-in-the-dominion-post/</guid><description>Today&amp;rsquo;s edition of the Dominion Post (Wellington&amp;rsquo;s Local Newspaper) features a nice article on Whiley:
Obviously, I&amp;rsquo;m very excited to see Whiley being talked about in our local newspaper, and I think the article does a nice job of it.</description></item><item><title>A Calculus for Constraint-Based Flow Typing</title><link>https://whileydave.com/publications/pea13_beat/</link><pubDate>Tue, 01 Jan 2013 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/pea13_beat/</guid><description/></item><item><title>A Calculus for Constraint-Based Flow Typing</title><link>https://whileydave.com/publications/pea13_ftfjp/</link><pubDate>Tue, 01 Jan 2013 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/pea13_ftfjp/</guid><description>Abstract: Flow typing offers an alternative to traditional Hindley-Milner type inference. A key distinction is that variables may have different types at different program points. Flow typing systems are typically formalised in the style of a dataflow analysis.</description></item><item><title>Balloon Types for Safe Parallelisation over Arbitrary Object Graphs</title><link>https://whileydave.com/publications/spgp13_wodet/</link><pubDate>Tue, 01 Jan 2013 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/spgp13_wodet/</guid><description>Abstract: Safe parallelisation of object-oriented programs requires static guarantees about the shape and/or intended usage of reachable objects. For example, transitively immutable objects lend themselves naturally to concurrent access. However, parallelising tasks which potentially mutate reachable objects is more challenging.</description></item><item><title>Compiling Whiley Programs for a General Purpose GPU</title><link>https://whileydave.com/publications/ruarus13_engr489/</link><pubDate>Tue, 01 Jan 2013 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/ruarus13_engr489/</guid><description>Abstract. This project investigates improving the performance of Whiley programs by executing portions of these programs on GPUs while maintaining as closely as possible the semantics of the language. Programs written in languages such as Whiley are typically not well suited to execution on GPUs which exhibit large-scale data parallelism in contrast to small-scale task parallelism seen on CPUs.</description></item><item><title>OwnKit: Inferring Modularly Checkable Ownership Annotations for Java</title><link>https://whileydave.com/publications/dpp13_aswec/</link><pubDate>Tue, 01 Jan 2013 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/dpp13_aswec/</guid><description>Abstract: Ownership and related systems impose restrictions on the object graph that can help improve program structure, exploit concurrency and verify software. Such systems rely on the presence of appropriate ownership annotations in the source code.</description></item><item><title>Reflections on Verifying Software with Whiley</title><link>https://whileydave.com/publications/pg13_ftscs/</link><pubDate>Tue, 01 Jan 2013 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/pg13_ftscs/</guid><description>Abstract: An ongoing challenge for computer science is the development of a tool which automatically verifies that programs meet their specifications, and are free from runtime errors such as divide-by-zero, array out-of-bounds and null dereferences.</description></item><item><title>Sound and Complete Flow Typing with Unions, Intersections and Negations</title><link>https://whileydave.com/publications/pea13_vmcai/</link><pubDate>Tue, 01 Jan 2013 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/pea13_vmcai/</guid><description>Abstract: Flow typing is becoming a popular mechanism for typing existing programs written in untyped languages (e.g. JavaScript, Racket, Groovy). Such systems require intersections for the true-branch of a type test, negations for the false-branch, and unions to capture the flow of information at meet points.</description></item><item><title>Whiley: a Platform for Research in Software Verification</title><link>https://whileydave.com/publications/pg13_sle/</link><pubDate>Tue, 01 Jan 2013 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/pg13_sle/</guid><description>Abstract: An ongoing challenge for computer science is the development of a tool which automatically verifies programs meet their specifications, and are free from runtime errors such as divide-by-zero, array out-of-bounds and null dereferences.</description></item><item><title>Testing out my Papilio FPGA!</title><link>https://whileydave.com/2012/12/20/testing-out-my-papilio-fpga/</link><pubDate>Thu, 20 Dec 2012 00:00:00 +0000</pubDate><guid>https://whileydave.com/2012/12/20/testing-out-my-papilio-fpga/</guid><description>Recently, I got hold of a Papilio One (which you can think of as the Arduino of FPGAs). The Papilio board has a Xilinx Spartan 3 on board, which is plenty enough to get started learning about FPGAs.</description></item><item><title>Building an Arduino Robot (for Testing Whiley)</title><link>https://whileydave.com/2012/12/12/building-an-arduino-robot-for-testing-whiley/</link><pubDate>Wed, 12 Dec 2012 00:00:00 +0000</pubDate><guid>https://whileydave.com/2012/12/12/building-an-arduino-robot-for-testing-whiley/</guid><description>The Whiley programming language is about developing more reliable software and, of course, embedded systems is one of the biggest areas that could benefit. Obviously, then, we need an &amp;ldquo;embedded system&amp;rdquo; to test Whiley with, right?</description></item><item><title>A Source File with 72KLOC!?</title><link>https://whileydave.com/2012/12/11/a-source-file-with-72kloc/</link><pubDate>Tue, 11 Dec 2012 00:00:00 +0000</pubDate><guid>https://whileydave.com/2012/12/11/a-source-file-with-72kloc/</guid><description>Yesterday, I was looking at the stats on Ohloh for the Whiley project and noticed that my total line count for the project had increased from around 65KLOCto 143KLOC over a very short amount of time:</description></item><item><title>Generating Verification Conditions for Whiley</title><link>https://whileydave.com/2012/12/04/generating-verification-conditions-for-whiley/</link><pubDate>Tue, 04 Dec 2012 00:00:00 +0000</pubDate><guid>https://whileydave.com/2012/12/04/generating-verification-conditions-for-whiley/</guid><description>Probably the most interesting aspect of the Whiley language is that it supports compile-time verification of preconditions, postconditions and other invariants. There are two main aspects of how this works:</description></item><item><title>Comparing I/O in C with Java</title><link>https://whileydave.com/2012/11/28/comparing-i/o-in-c-with-java/</link><pubDate>Wed, 28 Nov 2012 00:00:00 +0000</pubDate><guid>https://whileydave.com/2012/11/28/comparing-i/o-in-c-with-java/</guid><description>Recently, I was having a somewhat heated discussion with a friend about the Java I/O library (specificially java.io.*). His position was that the library is unnecessarily cluttered and verbose, and that I/O in C is much simpler and more productive.</description></item><item><title>Rustan on Automatic Program Verification</title><link>https://whileydave.com/2012/11/06/rustan-on-automatic-program-verification/</link><pubDate>Tue, 06 Nov 2012 00:00:00 +0000</pubDate><guid>https://whileydave.com/2012/11/06/rustan-on-automatic-program-verification/</guid><description>Yesterday I came across an interesting talk given by Rustan Leino at the University of Edinburgh in 2011. Rustan takes an interesting look overview over the subject&amp;rsquo;s history, and then shows several tools in action (including Code Contracts and Dafny):</description></item><item><title>Formalising Flow Typing with Union, Intersection and Negation Types</title><link>https://whileydave.com/2012/10/31/formalising-flow-typing-with-union-intersection-and-negation-types/</link><pubDate>Wed, 31 Oct 2012 00:00:00 +0000</pubDate><guid>https://whileydave.com/2012/10/31/formalising-flow-typing-with-union-intersection-and-negation-types/</guid><description>The Whiley language takes an unusual approaching to static typing called flow typing. This helps to give Whiley the look-and-feel of a dynamically typed language. The key idea behind flow typing is to allow variables to have different types at different points in a program.</description></item><item><title>Profiling Field Initialisation in Java</title><link>https://whileydave.com/2012/09/30/profiling-field-initialisation-in-java/</link><pubDate>Sun, 30 Sep 2012 00:00:00 +0000</pubDate><guid>https://whileydave.com/2012/09/30/profiling-field-initialisation-in-java/</guid><description>Recently, I attended the annual Conference on Runtime Verification (RV2012) and gave a talk entitled &amp;ldquo;Profiling Field Initialisation in Java&amp;rdquo; (the paper itself is here). This is the work of my PhD student, Stephen Nelson, and he should take all the credit for the gory details.</description></item><item><title>A Misconception of Functional Programming?</title><link>https://whileydave.com/2012/09/06/a-misconception-of-functional-programming/</link><pubDate>Thu, 06 Sep 2012 00:00:00 +0000</pubDate><guid>https://whileydave.com/2012/09/06/a-misconception-of-functional-programming/</guid><description>Recently, I came across an article entitled &amp;ldquo;Useful Pure Functional Programming&amp;rdquo; which talks about the advantages of functional programming. However, something struck me about the way the author thinks about functional programming:</description></item><item><title>Autonomous Robotic Drone which Flies Indoors!?</title><link>https://whileydave.com/2012/08/15/autonomous-robotic-drone-which-flies-indoors/</link><pubDate>Wed, 15 Aug 2012 00:00:00 +0000</pubDate><guid>https://whileydave.com/2012/08/15/autonomous-robotic-drone-which-flies-indoors/</guid><description>Very recently, I came across this article from MIT News about an autonomous robotic drone developed at MIT. It&amp;rsquo;s incredibly neat stuff &amp;hellip; and I would love to get Whiley running on something like this!</description></item><item><title>Java versus C++ Performance</title><link>https://whileydave.com/2012/08/13/java-versus-c-performance/</link><pubDate>Mon, 13 Aug 2012 00:00:00 +0000</pubDate><guid>https://whileydave.com/2012/08/13/java-versus-c-performance/</guid><description>Recently, I came across an interesting discussion of C++ versus Java performance over on Stack Exchange. There was also some good discussion of the article on Reddit which included a link to an interesting article from Google.</description></item><item><title>Whiley Interview on VBC 88.3FM</title><link>https://whileydave.com/2012/07/30/whiley-interview-on-vbc-88.3fm/</link><pubDate>Mon, 30 Jul 2012 00:00:00 +0000</pubDate><guid>https://whileydave.com/2012/07/30/whiley-interview-on-vbc-88.3fm/</guid><description>Recently, I was on VBC 88.3FM (Victoria University&amp;rsquo;s Student Radio) giving a 60s &amp;ldquo;speed summary&amp;rdquo; of my research, and generally chatting about some tech stuff. The station has been interviewing a whole range of people at the university to raise awareness of what research is going on.</description></item><item><title>The Liquid Metal Project</title><link>https://whileydave.com/2012/07/04/the-liquid-metal-project/</link><pubDate>Wed, 04 Jul 2012 00:00:00 +0000</pubDate><guid>https://whileydave.com/2012/07/04/the-liquid-metal-project/</guid><description>One of the most interesting projects I came across at PLDI/ECOOP in Beijing was the Liquid Metal project being developed at IBM&amp;rsquo;s TJ Watson Research Center. From the Liquid Metal homepage:</description></item><item><title>Groovy 2.0 uses Flow Typing!</title><link>https://whileydave.com/2012/07/01/groovy-2.0-uses-flow-typing/</link><pubDate>Sun, 01 Jul 2012 00:00:00 +0000</pubDate><guid>https://whileydave.com/2012/07/01/groovy-2.0-uses-flow-typing/</guid><description>Groovy 2.0 has just been released, and it contains something rather interesting &amp;hellip; optional flow typing! For those who don&amp;rsquo;t know much about the language, Groovy is a JVM-based dynamically typed language which is similar to Java, but more compact.</description></item><item><title>Flow Typing for References in Whiley</title><link>https://whileydave.com/2012/06/11/flow-typing-for-references-in-whiley/</link><pubDate>Mon, 11 Jun 2012 00:00:00 +0000</pubDate><guid>https://whileydave.com/2012/06/11/flow-typing-for-references-in-whiley/</guid><description>The Whiley language splits into a fully functional &amp;ldquo;core&amp;rdquo; and an imperative &amp;ldquo;outer layer&amp;rdquo;. References and objects do not exist within the functional core. However, they can exist within the imperative outer layer and are necessary for supporting state and other side-effecting computation.</description></item><item><title>Exploring The Verification Corner</title><link>https://whileydave.com/2012/06/06/exploring-the-verification-corner/</link><pubDate>Wed, 06 Jun 2012 00:00:00 +0000</pubDate><guid>https://whileydave.com/2012/06/06/exploring-the-verification-corner/</guid><description>Recently, I was lucky enough to meet Rustan Leino whilst at a conference in Tallin, Estonia. The Whiley project owes a lot to Rustan, as much of his work has been the inspiration behind Whiley.</description></item><item><title>Variable Scoping for Try-Catch Blocks in Whiley</title><link>https://whileydave.com/2012/05/22/variable-scoping-for-try-catch-blocks-in-whiley/</link><pubDate>Tue, 22 May 2012 00:00:00 +0000</pubDate><guid>https://whileydave.com/2012/05/22/variable-scoping-for-try-catch-blocks-in-whiley/</guid><description>A friend of mine was talking about how variable scoping for try-catch blocks in Java really frustrated him sometimes. Specifically, the problem was related to variables declared inside try blocks not being visible in their catch handlers.</description></item><item><title>Termination of Flow Typing in Whiley</title><link>https://whileydave.com/2012/04/17/termination-of-flow-typing-in-whiley/</link><pubDate>Tue, 17 Apr 2012 00:00:00 +0000</pubDate><guid>https://whileydave.com/2012/04/17/termination-of-flow-typing-in-whiley/</guid><description>Whiley uses flow typing to give it the look-and-feel of a dynamically typed language (see this page for more on flow typing). In short, flow typing means that variables can have different types at different program points.</description></item><item><title>Are Checked Exceptions Always Caused by I/O?</title><link>https://whileydave.com/2012/04/10/are-checked-exceptions-always-caused-by-i/o/</link><pubDate>Tue, 10 Apr 2012 00:00:00 +0000</pubDate><guid>https://whileydave.com/2012/04/10/are-checked-exceptions-always-caused-by-i/o/</guid><description>Recently, I&amp;rsquo;ve had the pleasure of working with Eclipse and trying to build a plugin. On the whole, I have to confess,* I find that Eclipse is an extremely well-designed and considered piece of software*.</description></item><item><title>Test to Code Ratio</title><link>https://whileydave.com/2012/03/08/test-to-code-ratio/</link><pubDate>Thu, 08 Mar 2012 00:00:00 +0000</pubDate><guid>https://whileydave.com/2012/03/08/test-to-code-ratio/</guid><description>I&amp;rsquo;ve just been watching the following talk over on InfoQ: Software Quality &amp;mdash; You know it when you see it. Thanks to Craig over at SoftViz for pointing me to it.</description></item><item><title>Commonwealth Bank of Australia (CBA) denies problem with Leap Year?</title><link>https://whileydave.com/2012/03/05/commonwealth-bank-of-australia-cba-denies-problem-with-leap-year/</link><pubDate>Mon, 05 Mar 2012 00:00:00 +0000</pubDate><guid>https://whileydave.com/2012/03/05/commonwealth-bank-of-australia-cba-denies-problem-with-leap-year/</guid><description>It&amp;rsquo;s 8:30am on the 29th Februrary, 2012. After a large number of complaints, ATM and Eftpos services are finally restored for the Commonwealth Bank of Australia (CBA). See this, this and this for more details.</description></item><item><title>Jobs versus Allen</title><link>https://whileydave.com/2012/03/05/jobs-versus-allen/</link><pubDate>Mon, 05 Mar 2012 00:00:00 +0000</pubDate><guid>https://whileydave.com/2012/03/05/jobs-versus-allen/</guid><description>I&amp;rsquo;ve recently finished Paul Allen&amp;rsquo;s excellent memoir entitled &amp;ldquo;Idea Man&amp;rdquo; and the recent biography of Steve Jobs by Walter Isaacson. Obviously, I didn&amp;rsquo;t read them at the same time &amp;hellip; but one after there other!</description></item><item><title>Type Aliasing in Java?</title><link>https://whileydave.com/2012/03/02/type-aliasing-in-java/</link><pubDate>Fri, 02 Mar 2012 00:00:00 +0000</pubDate><guid>https://whileydave.com/2012/03/02/type-aliasing-in-java/</guid><description>A problem I often encounter in Java is that I want to say &amp;ldquo;these two things are the same&amp;rdquo;, but Java won&amp;rsquo;t let me. Suppose I want to maintain an int[] array which is always sorted in my program.</description></item><item><title>A Problem of Decoupling?</title><link>https://whileydave.com/2012/02/29/a-problem-of-decoupling/</link><pubDate>Wed, 29 Feb 2012 00:00:00 +0000</pubDate><guid>https://whileydave.com/2012/02/29/a-problem-of-decoupling/</guid><description>Recently, I&amp;rsquo;ve been working on improving the core framework that underpins the Whiley compiler. This provides a platform for reading/writing files of specified content in a structured fashion. Like Java, Whiley provides a hierarchical namespace in which names live and can be imported by others.</description></item><item><title>Writing a PNG Decoder in Whiley!</title><link>https://whileydave.com/2012/02/18/writing-a-png-decoder-in-whiley/</link><pubDate>Sat, 18 Feb 2012 00:00:00 +0000</pubDate><guid>https://whileydave.com/2012/02/18/writing-a-png-decoder-in-whiley/</guid><description>Over the last few days, I have been writing GIF and PNG decoders in Whiley. These form part of an image manipulation benchmark which I&amp;rsquo;m planning to use for experimenting with the compiler.</description></item><item><title>Connecting the Dots on the Future of Programming Languages</title><link>https://whileydave.com/2012/01/18/connecting-the-dots-on-the-future-of-programming-languages/</link><pubDate>Wed, 18 Jan 2012 00:00:00 +0000</pubDate><guid>https://whileydave.com/2012/01/18/connecting-the-dots-on-the-future-of-programming-languages/</guid><description>Yesterday, I serendipitously came across two things which got me thinking about the future of programming languages:
The first was an excellent article entitled &amp;ldquo;Welcome to the Hardware Jungle&amp;rdquo; by Herb Sutter.</description></item><item><title>Three Rules for Programming Language Syntax?</title><link>https://whileydave.com/2012/01/11/three-rules-for-programming-language-syntax/</link><pubDate>Wed, 11 Jan 2012 00:00:00 +0000</pubDate><guid>https://whileydave.com/2012/01/11/three-rules-for-programming-language-syntax/</guid><description>I&amp;rsquo;m always pondering the question: what makes good programming language syntax? One thing occuring to me is that many languages often ignore the HCI aspect. For me, it&amp;rsquo;s a given that the purpose of a programming language is to simplify the programmer&amp;rsquo;s life, not the other way around.</description></item><item><title>Patterns as Objects in Grace</title><link>https://whileydave.com/publications/hnbbp12_dls/</link><pubDate>Sun, 01 Jan 2012 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/hnbbp12_dls/</guid><description>Abstract: Object orientation and pattern matching are often seen as conflicting approaches to program design. Object oriented programs place type-dependent behaviour inside objects and invoke it via dynamic dispatch, while pattern matching programs place type-dependent behaviour outside data structures and invoke it via multiway conditionals (case statements).</description></item><item><title>Profiling Field Initialization for Java</title><link>https://whileydave.com/publications/npn12_rv/</link><pubDate>Sun, 01 Jan 2012 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/npn12_rv/</guid><description>Abstract: Java encourages programmers to use constructor methods to initialise objects, supports final modifiers for documenting fields which are never modified and employs static checking to ensure such fields are only ever initialised inside constructors.</description></item><item><title>Profiling Initialisation Behaviour in Java</title><link>https://whileydave.com/publications/nelson12_phd/</link><pubDate>Sun, 01 Jan 2012 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/nelson12_phd/</guid><description>Abstract: Freshly created objects are a blank slate: their mutable state and their constant properties must be initialised before they can be used. Programming languages like Java typically support object initialisation by providing constructor methods.</description></item><item><title>Merchants of Doubt</title><link>https://whileydave.com/2011/12/27/merchants-of-doubt/</link><pubDate>Tue, 27 Dec 2011 00:00:00 +0000</pubDate><guid>https://whileydave.com/2011/12/27/merchants-of-doubt/</guid><description>I&amp;rsquo;ve just finished reading this book, which I have to say was really good. The book is about how a handful of rogue scientists deliberately spread disinformation on a range of key issues, including tobacco, acid rain, the ozone hole and climate change.</description></item><item><title>The Whiley Programming Language</title><link/><pubDate>Tue, 20 Dec 2011 00:00:00 +0000</pubDate><guid/><description/></item><item><title>Efficient Value Semantics for Whiley</title><link>https://whileydave.com/2011/12/13/efficient-value-semantics-for-whiley/</link><pubDate>Tue, 13 Dec 2011 00:00:00 +0000</pubDate><guid>https://whileydave.com/2011/12/13/efficient-value-semantics-for-whiley/</guid><description>The latest release of the Whiley compiler (v0.3.12) includes an optimisation for passing compound structures (e.g. lists, sets and records) by value. This is really important because all compound structures in Whiley have value semantics, meaning they are always passed by value.</description></item><item><title>Final should be Default for Classes in Java</title><link>https://whileydave.com/2011/12/06/final-should-be-default-for-classes-in-java/</link><pubDate>Tue, 06 Dec 2011 00:00:00 +0000</pubDate><guid>https://whileydave.com/2011/12/06/final-should-be-default-for-classes-in-java/</guid><description>We were having an interesting discussion the other day, and the issue of final classes came up. For some reason, it suddenly occurred to me that all classes should be final by default.</description></item><item><title>Version 0.9.16</title><link>https://whileydave.com/downloads/tuttev0.9.16/</link><pubDate>Thu, 01 Dec 2011 00:00:00 +0000</pubDate><guid>https://whileydave.com/downloads/tuttev0.9.16/</guid><description>The following updates have been made:
Incorporated the vorder push heuristic suggested by Michael Monagan. As part of this, I&amp;rsquo;ve added the ability to sort the vertex order according to a depth-first or breadth-first search.</description></item><item><title>Fall-Through by Default for Switch Statements?</title><link>https://whileydave.com/2011/10/26/fall-through-by-default-for-switch-statements/</link><pubDate>Wed, 26 Oct 2011 00:00:00 +0000</pubDate><guid>https://whileydave.com/2011/10/26/fall-through-by-default-for-switch-statements/</guid><description>The switch statement has a long history, and most languages support it or something similar. In my experience, I found it to be very useful &amp;mdash; both for conciseness, and also improving performance.</description></item><item><title>What Kind of Revert are You?</title><link>https://whileydave.com/2011/10/19/what-kind-of-revert-are-you/</link><pubDate>Wed, 19 Oct 2011 00:00:00 +0000</pubDate><guid>https://whileydave.com/2011/10/19/what-kind-of-revert-are-you/</guid><description>Reverting is tough. There&amp;rsquo;s no doubt about it! I don&amp;rsquo;t mean tough as in technically challenging &amp;mdash; no, version control systems make this easy! I mean tough as in mentally challenging.</description></item><item><title>Namespaces in Whiley</title><link>https://whileydave.com/2011/09/03/namespaces-in-whiley/</link><pubDate>Sat, 03 Sep 2011 00:00:00 +0000</pubDate><guid>https://whileydave.com/2011/09/03/namespaces-in-whiley/</guid><description>With the upcoming v0.3.10 release of Whiley, the way import statements are interpreted has changed in a fairly significant manner. The primary purpose of this is to give better support for namespaces.</description></item><item><title>Version 0.9.15</title><link>https://whileydave.com/downloads/tuttev0.9.15/</link><pubDate>Thu, 01 Sep 2011 00:00:00 +0000</pubDate><guid>https://whileydave.com/downloads/tuttev0.9.15/</guid><description>The following updates have been made:
For the --chromatic option, the tool now automatically removes multi-edges on the input graph. Thanks to Alan Sokal for pointing out this bug.
For the `&amp;ndash;chromatic1 option, the tool now reports the result as zero if the input graph contains a loop, and outputs an error message as well.</description></item><item><title>Simplification vs Minimisation of Types in Whiley</title><link>https://whileydave.com/2011/08/30/simplification-vs-minimisation-of-types-in-whiley/</link><pubDate>Tue, 30 Aug 2011 00:00:00 +0000</pubDate><guid>https://whileydave.com/2011/08/30/simplification-vs-minimisation-of-types-in-whiley/</guid><description>Recently, I&amp;rsquo;ve been trying to harden up the implementation of Whiley&amp;rsquo;s type system. The reason for this is fairly straightforward: bugs in the code often prevent me from compiling correct programs!</description></item><item><title>A Subtyping Gotcha</title><link>https://whileydave.com/2011/08/29/a-subtyping-gotcha/</link><pubDate>Mon, 29 Aug 2011 00:00:00 +0000</pubDate><guid>https://whileydave.com/2011/08/29/a-subtyping-gotcha/</guid><description>An interesting issue with the following piece of code has recently come to my attention:
define Queue as process { [int] items } int Queue::get(): item = this.items[0] this.items = this.</description></item><item><title>Parallel Sum in Whiley</title><link>https://whileydave.com/2011/08/03/parallel-sum-in-whiley/</link><pubDate>Wed, 03 Aug 2011 00:00:00 +0000</pubDate><guid>https://whileydave.com/2011/08/03/parallel-sum-in-whiley/</guid><description>Recently, I&amp;rsquo;ve been working on a variety of sequential and concurrent micro benchmarks for testing Whiley&amp;rsquo;s performance. An interesting and relatively simple example, is the parallel sum. The idea is to sum a large list of integers whilst performing as much work as possible in parallel.</description></item><item><title>A Semantic Interpretation of Types in Whiley</title><link>https://whileydave.com/2011/07/29/a-semantic-interpretation-of-types-in-whiley/</link><pubDate>Fri, 29 Jul 2011 00:00:00 +0000</pubDate><guid>https://whileydave.com/2011/07/29/a-semantic-interpretation-of-types-in-whiley/</guid><description>An interesting and intuitive way of thinking about a type system is using a semantic interpretation. Typically, a set-theoretic model is used where a type T is a subtype of S iff every element in the set described by T is in the set described by S.</description></item><item><title>Implicit Coercions in Whiley</title><link>https://whileydave.com/2011/07/21/implicit-coercions-in-whiley/</link><pubDate>Thu, 21 Jul 2011 00:00:00 +0000</pubDate><guid>https://whileydave.com/2011/07/21/implicit-coercions-in-whiley/</guid><description>The issue of implicit coercions in Whiley is proving to be a particularly thorny issue. The following motivates why (I think) coercions make sense:
real f(int x, real y): return x + y real g(int x, int y): return f(x,y) I believe the above should compile without error.</description></item><item><title>Compile-time Verification, It's Not Just for Type Safety Any More</title><link>https://whileydave.com/2011/07/12/compile-time-verification-its-not-just-for-type-safety-any-more/</link><pubDate>Tue, 12 Jul 2011 00:00:00 +0000</pubDate><guid>https://whileydave.com/2011/07/12/compile-time-verification-its-not-just-for-type-safety-any-more/</guid><description>I just came across an interesting presentation over at InfoQ called &amp;ldquo;Compile-time Verification, It&amp;rsquo;s Not Just for Type Safety Any More&amp;rdquo;:
The talk is by Greg Young and focuses on .</description></item><item><title>Regular Tree Automata</title><link>https://whileydave.com/2011/07/06/regular-tree-automata/</link><pubDate>Wed, 06 Jul 2011 00:00:00 +0000</pubDate><guid>https://whileydave.com/2011/07/06/regular-tree-automata/</guid><description>In my quest to understand the theory of recursive types in more detail, the notion of regular tree languages and Tree Automata has cropped up. These have been used, amongst other things, for describing XML schemas.</description></item><item><title>Bits, Bytes and More Ambiguous Syntax</title><link>https://whileydave.com/2011/07/04/bits-bytes-and-more-ambiguous-syntax/</link><pubDate>Mon, 04 Jul 2011 00:00:00 +0000</pubDate><guid>https://whileydave.com/2011/07/04/bits-bytes-and-more-ambiguous-syntax/</guid><description>Recently, I added a first-class byte type to Whiley. Unlike Java, this is not interpreted as some kind of signed or unsigned int. That&amp;rsquo;s because I find that very confusing since a byte is really just a sequence of bits without any interpretation.</description></item><item><title>Version 0.2</title><link>https://whileydave.com/downloads/jpure-110711/</link><pubDate>Fri, 01 Jul 2011 00:00:00 +0000</pubDate><guid>https://whileydave.com/downloads/jpure-110711/</guid><description/></item><item><title>Disambiguating Ambiguous Syntax?</title><link>https://whileydave.com/2011/06/28/disambiguating-ambiguous-syntax/</link><pubDate>Tue, 28 Jun 2011 00:00:00 +0000</pubDate><guid>https://whileydave.com/2011/06/28/disambiguating-ambiguous-syntax/</guid><description>When designing a programming language, being on the lookout for ambiguous syntax is important. You don&amp;rsquo;t want to realise down the track that your syntax is ambiguous in some subtle way.</description></item><item><title>On the Duality of Types: the Ideals versus the Reals</title><link>https://whileydave.com/2011/06/20/on-the-duality-of-types-the-ideals-versus-the-reals/</link><pubDate>Mon, 20 Jun 2011 00:00:00 +0000</pubDate><guid>https://whileydave.com/2011/06/20/on-the-duality-of-types-the-ideals-versus-the-reals/</guid><description>I&amp;rsquo;ve been working hard over the last few weeks on the next release of Whiley, which should be out soon. However, I&amp;rsquo;ve got myself into a little bit of a pickle over the type system (again).</description></item><item><title>Design by Contract is Most Requested Feature?</title><link>https://whileydave.com/2011/06/17/design-by-contract-is-most-requested-feature/</link><pubDate>Fri, 17 Jun 2011 00:00:00 +0000</pubDate><guid>https://whileydave.com/2011/06/17/design-by-contract-is-most-requested-feature/</guid><description>Thanks to Alex Potanin for pointing this out to me &amp;hellip; it seems that Design by Contract is the most requested enhancement to the Java language. You can find the list of the top 25 RFEs here.</description></item><item><title>Language Complexity?</title><link>https://whileydave.com/2011/06/13/language-complexity/</link><pubDate>Mon, 13 Jun 2011 00:00:00 +0000</pubDate><guid>https://whileydave.com/2011/06/13/language-complexity/</guid><description>Some languages are complex, others are simple &amp;hellip; right? C++ versus just about anything else is a good example here. But, it begs the question: what makes a language complex?</description></item><item><title>What a Racket!</title><link>https://whileydave.com/2011/06/03/what-a-racket/</link><pubDate>Fri, 03 Jun 2011 00:00:00 +0000</pubDate><guid>https://whileydave.com/2011/06/03/what-a-racket/</guid><description>The other day I was listening to this podcast over at FLOSS weekly. It was an interview was with Matthew Flatt about the Racket language (formerly PLT Scheme). The language is a Lisp dialect which was primarily designed for teaching, and subsequently used as a research platform.</description></item><item><title>JavaScript Playground</title><link>https://whileydave.com/2011/05/26/javascript-playground/</link><pubDate>Thu, 26 May 2011 00:00:00 +0000</pubDate><guid>https://whileydave.com/2011/05/26/javascript-playground/</guid><description>I&amp;rsquo;ve been doing a bit of JavaScript programming recently, and I came up with the &amp;ldquo;Creature Playground&amp;rdquo; (which is primarily aimed at teaching). Here&amp;rsquo;s a little taster (click on &amp;ldquo;Create&amp;rdquo; a few times):</description></item><item><title>Actor Syntax in Whiley</title><link>https://whileydave.com/2011/05/16/actor-syntax-in-whiley/</link><pubDate>Mon, 16 May 2011 00:00:00 +0000</pubDate><guid>https://whileydave.com/2011/05/16/actor-syntax-in-whiley/</guid><description>Recently, I&amp;rsquo;ve been doing some work on the syntax for Actors in Whiley. After some deliberation, I&amp;rsquo;ve decided to go with explicit syntax for both synchronous and asynchronous message sends. This means any message can be sent either synchronously or asynchronously.</description></item><item><title>Got Any Quotes from Coders At Work?</title><link>https://whileydave.com/2011/04/25/got-any-quotes-from-coders-at-work/</link><pubDate>Mon, 25 Apr 2011 00:00:00 +0000</pubDate><guid>https://whileydave.com/2011/04/25/got-any-quotes-from-coders-at-work/</guid><description>Recently, I finished reading Coders at Work by Peter Seibel. The book consists of a series of interviews with the following (impressive) list of programmers and computer scientists: Jamie Zawinski, Brad Fitzpatrick, Douglas Crockford, Brendan Eich, Josh Bloch, Joe Armstrong, Simon Peyton-Jones, Peter Norvig, Guy Steele, Dan Ingalls, Peter Deutsch, Ken Thompson, Fran Allen, Bernie Cosell and Don Knuth.</description></item><item><title>One Thing I Really Hate About the JVM</title><link>https://whileydave.com/2011/04/15/one-thing-i-really-hate-about-the-jvm/</link><pubDate>Fri, 15 Apr 2011 00:00:00 +0000</pubDate><guid>https://whileydave.com/2011/04/15/one-thing-i-really-hate-about-the-jvm/</guid><description>Whilst I think the Java Virtual Machine is generally speaking a fantastic piece of kit, there is one thing that I really hate about it: I can&amp;rsquo;t stop threads!!!
Sure, there&amp;rsquo;s a method called Thread.</description></item><item><title>Actors on the JVM</title><link>https://whileydave.com/2011/03/22/actors-on-the-jvm/</link><pubDate>Tue, 22 Mar 2011 00:00:00 +0000</pubDate><guid>https://whileydave.com/2011/03/22/actors-on-the-jvm/</guid><description>The Actor Model is an interesting alternative to the standard threading model used in languages like Java. Its been around for a while, but Erlang has recently brought it into the mainstream.</description></item><item><title>Implementing Structural Types</title><link>https://whileydave.com/2011/03/07/implementing-structural-types/</link><pubDate>Mon, 07 Mar 2011 00:00:00 +0000</pubDate><guid>https://whileydave.com/2011/03/07/implementing-structural-types/</guid><description>Introduction Over the last few months, I&amp;rsquo;ve been working on the type system underpinning Whiley. A key feature is the use of structural typing, rather than nominal typing, and I&amp;rsquo;ve blogged about this quite a bit already (see [1][2][3][4]).</description></item><item><title>Freakonomics</title><link>https://whileydave.com/2011/02/23/freakonomics/</link><pubDate>Wed, 23 Feb 2011 00:00:00 +0000</pubDate><guid>https://whileydave.com/2011/02/23/freakonomics/</guid><description>Recently, I finished reading Freakonomics, by Steven Levitt and Stephen Dubner. and I have to say that I really liked it!!
The book is focuses on the study of everyday aspects of life using the tools of economics and statistics.</description></item><item><title>Minimising Recursive Data Types</title><link>https://whileydave.com/2011/02/16/minimising-recursive-data-types/</link><pubDate>Wed, 16 Feb 2011 00:00:00 +0000</pubDate><guid>https://whileydave.com/2011/02/16/minimising-recursive-data-types/</guid><description>Following on from my previous post about structural subtyping with recursive types, a related problem is that of minimising recursive types. Consider this (somewhat artificial) example:
define InnerList as null | { int data, OuterList next } define OuterList as null | { int data, InnerList next } int sum(OuterList list): if list ~= null: return 0 else: return 1 + sum(list.</description></item><item><title>A Problem with Structural Subtyping and Recusive Types</title><link>https://whileydave.com/2011/02/15/a-problem-with-structural-subtyping-and-recusive-types/</link><pubDate>Tue, 15 Feb 2011 00:00:00 +0000</pubDate><guid>https://whileydave.com/2011/02/15/a-problem-with-structural-subtyping-and-recusive-types/</guid><description>One problem causing me a headache is how to implement structural subtyping for recursive types (which I first blogged about here). The following example illustrates the basic idea:
define Link as { int data, LinkedList next } define LinkedList as null | Link LinkedList f(Link list): return list This is a fairly straightforward definition of a linked list, along with a dumb function f() that just returns its parameter.</description></item><item><title>What Motivates Us?</title><link>https://whileydave.com/2011/02/07/what-motivates-us/</link><pubDate>Mon, 07 Feb 2011 00:00:00 +0000</pubDate><guid>https://whileydave.com/2011/02/07/what-motivates-us/</guid><description>Here&amp;rsquo;s an interesting video that I just came across (adapted from Dan Pink&amp;rsquo;s talk at the RSA, which is currently doing the rounds:
The video is about what motivates people to do things and, in particular, whether or not giving people more money means they do a better job.</description></item><item><title>Version 0.9.14</title><link>https://whileydave.com/downloads/tuttev0.9.14/</link><pubDate>Tue, 01 Feb 2011 00:00:00 +0000</pubDate><guid>https://whileydave.com/downloads/tuttev0.9.14/</guid><description>The following updates have been made:
Added better support for report statistical data on the operation of the cache. This is to help diagnosing cache behaviour, as there&amp;rsquo;s some interesting possibilities for optimising the caching strategies.</description></item><item><title>The Case Against Structural Subtyping ... ?</title><link>https://whileydave.com/2011/01/26/the-case-against-structural-subtyping-.../</link><pubDate>Wed, 26 Jan 2011 00:00:00 +0000</pubDate><guid>https://whileydave.com/2011/01/26/the-case-against-structural-subtyping-.../</guid><description>My previous post on structural subtyping generated quite a few comments over on reddit. There were a lot of mixed opinions as to the pros and cons of having a structural type system instead of a nominal type system.</description></item><item><title>One Approach to Efficient Structural Subtyping</title><link>https://whileydave.com/2011/01/14/one-approach-to-efficient-structural-subtyping/</link><pubDate>Fri, 14 Jan 2011 00:00:00 +0000</pubDate><guid>https://whileydave.com/2011/01/14/one-approach-to-efficient-structural-subtyping/</guid><description>An interesting challenge with structural subtyping is that of efficient implementation. In particular, without care, it may be impossible to determine a static offset for each field in a structure at runtime, meaning every field access will require a dictionary lookup.</description></item><item><title>Formalisation and Implementation of an Algorithm for Bytecode Verification of @NonNull Types</title><link>https://whileydave.com/publications/mppd11_scp/</link><pubDate>Sat, 01 Jan 2011 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/mppd11_scp/</guid><description>Abstract. Java&amp;rsquo;s annotation mechanism allows us to extend its type system with non-null types. Checking such types cannot be done using the existing bytecode verification algorithm. We extend this algorithm to verify non-null types using a novel technique that identifies aliasing relationships between local variables and stack locations in the JVM.</description></item><item><title>Implementing a Language with Flow-Sensitive and Structural Typing on the JVM</title><link>https://whileydave.com/publications/pn11_bytecode/</link><pubDate>Sat, 01 Jan 2011 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/pn11_bytecode/</guid><description>Abstract. Dynamically typed languages are flexible and impose few burdens on the programmer. In contrast, static typing leads to software that is more efficient and has fewer errors. However, static type systems traditionally require every variable to have one type, and that relationships between types (e.</description></item><item><title>Integrating the Actor Model into the Whiley Programming Language</title><link>https://whileydave.com/publications/jones11_engr489/</link><pubDate>Sat, 01 Jan 2011 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/jones11_engr489/</guid><description>Abstract. Introducing concurrent behaviour into a program tends to also introduce unpredictable behaviour. The actor model is an attempt to simplify concurrency and reduce such problems. The Whiley programming language is structured around concurrent processes, which are analogous to actors, but it runs on top of the Java Virtual Machine, which does not provide support for the model.</description></item><item><title>JPure: a Modular Purity System for Java</title><link>https://whileydave.com/publications/pea11_cc/</link><pubDate>Sat, 01 Jan 2011 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/pea11_cc/</guid><description>Abstract: Purity Analysis is the problem of determining whether or not a method may have side-effects. This has applications in automatic parallelisation, extended static checking, and more. We present a novel purity system for Java that employs purity annotations which can be checked modularly.</description></item><item><title>OwnKit: Ownership Inference for Java</title><link>https://whileydave.com/publications/dymnikov11_msc/</link><pubDate>Sat, 01 Jan 2011 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/dymnikov11_msc/</guid><description>Abstract: Object ownership allows us to statically control run-time aliasing in order to provide a strong notion of object encapsulation. Unfortunately in order to use ownership, code must first be annotated with extra type information.</description></item><item><title>Modular Purity Analysis for Java</title><link>https://whileydave.com/2010/12/14/modular-purity-analysis-for-java/</link><pubDate>Tue, 14 Dec 2010 00:00:00 +0000</pubDate><guid>https://whileydave.com/2010/12/14/modular-purity-analysis-for-java/</guid><description>Well, after an agonizing wait I finally heard the news that my paper on purity analysis was accepted to the Conference on Compiler Construction, 2011. Obviously, I&amp;rsquo;m stoked! The paper is:</description></item><item><title>Why not use Structural Subtyping?</title><link>https://whileydave.com/2010/12/13/why-not-use-structural-subtyping/</link><pubDate>Mon, 13 Dec 2010 00:00:00 +0000</pubDate><guid>https://whileydave.com/2010/12/13/why-not-use-structural-subtyping/</guid><description>Modern programming languages generally use what is known as a Nominal type system. This means types are associated with explicit names and subtyping relationships are explicit in the code (e.g. via extends or implements).</description></item><item><title>The Future of Programming Languages</title><link>https://whileydave.com/2010/12/06/the-future-of-programming-languages/</link><pubDate>Mon, 06 Dec 2010 00:00:00 +0000</pubDate><guid>https://whileydave.com/2010/12/06/the-future-of-programming-languages/</guid><description>There&amp;rsquo;s an interesting panel discussion from the StrangeLoop2010 conference over on InfoQ:
http://www.infoq.com/presentations/Future-of-Programming-Languages
There panel covers quite a range of different topics, but there was one in particular that caught my eye:</description></item><item><title>Where Good Ideas Come From</title><link>https://whileydave.com/2010/11/30/where-good-ideas-come-from/</link><pubDate>Tue, 30 Nov 2010 00:00:00 +0000</pubDate><guid>https://whileydave.com/2010/11/30/where-good-ideas-come-from/</guid><description>I recently finished reading Steven Johnson&amp;rsquo;s &amp;ldquo;Where Good Ideas Come From&amp;rdquo;. This is a rather interesting book which takes a walk through history looking at how good ideas come to be.</description></item><item><title>A Problem on Typing vs Verification</title><link>https://whileydave.com/2010/11/14/a-problem-on-typing-vs-verification/</link><pubDate>Sun, 14 Nov 2010 00:00:00 +0000</pubDate><guid>https://whileydave.com/2010/11/14/a-problem-on-typing-vs-verification/</guid><description>Whiley uses a flow-sensitive type system, and a verification engine to enable Extended static checking. My desire in designing these two subsystems is to keep them completely isolated. In particular, such that we can always compile and run a Whiley program with verification turned off.</description></item><item><title>More on Flow-Sensitive Typing</title><link>https://whileydave.com/2010/11/09/more-on-flow-sensitive-typing/</link><pubDate>Tue, 09 Nov 2010 00:00:00 +0000</pubDate><guid>https://whileydave.com/2010/11/09/more-on-flow-sensitive-typing/</guid><description>The idea behind flow-sensitive typing in Whiley is to give a statically typed language the look-and-feel of a dynamically typed language (as much as possible). The following illustrates:
int average([int] items): v = 0 for i in items: v = v + items[i] return v / |items| Here, we see that there are only two type declarations: one for the parameter, and one for the return.</description></item><item><title>The Design of Design</title><link>https://whileydave.com/2010/10/28/the-design-of-design/</link><pubDate>Thu, 28 Oct 2010 00:00:00 +0000</pubDate><guid>https://whileydave.com/2010/10/28/the-design-of-design/</guid><description>I just finished up reading &amp;ldquo;The Design of Design&amp;rdquo; by Fred Brookes JR (author of the Mythical Man Month). This book is a reflection on the design process itself and, in particular, what good designers are made of.</description></item><item><title>Implementing Actors on the JVM</title><link>https://whileydave.com/2010/10/25/implementing-actors-on-the-jvm/</link><pubDate>Mon, 25 Oct 2010 00:00:00 +0000</pubDate><guid>https://whileydave.com/2010/10/25/implementing-actors-on-the-jvm/</guid><description>Whiley adopts the Actor model of concurrency, instead of the traditional multi-threading approach used in e.g. Java. The actor model is simple and easy to use, and is less likely to result in complex race conditions or deadlocks.</description></item><item><title>Indentation Syntax in Whiley</title><link>https://whileydave.com/2010/10/18/indentation-syntax-in-whiley/</link><pubDate>Mon, 18 Oct 2010 00:00:00 +0000</pubDate><guid>https://whileydave.com/2010/10/18/indentation-syntax-in-whiley/</guid><description>Like Python, Whiley uses indentation syntax instead of curly braces for delimiting blocks. When I started using indentation syntax with Python, I was pretty skeptical, but it grew on me fast and now I really like it.</description></item><item><title>Function Pointer Syntax for Whiley</title><link>https://whileydave.com/2010/10/11/function-pointer-syntax-for-whiley/</link><pubDate>Mon, 11 Oct 2010 00:00:00 +0000</pubDate><guid>https://whileydave.com/2010/10/11/function-pointer-syntax-for-whiley/</guid><description>One of the next big issues needing to be addressed is the syntax for function and method pointers. The syntax I&amp;rsquo;m thinking of is close to that used in C and C++ (see e.</description></item><item><title>Field Resolution in Whiley</title><link>https://whileydave.com/2010/10/05/field-resolution-in-whiley/</link><pubDate>Tue, 05 Oct 2010 00:00:00 +0000</pubDate><guid>https://whileydave.com/2010/10/05/field-resolution-in-whiley/</guid><description>An interesting issue has arisen as a result of my recent decision to move away from a declared-type model. The issue is essentially about scope resolution of fields and local variables.</description></item><item><title>Better Namespaces</title><link>https://whileydave.com/2010/10/04/better-namespaces/</link><pubDate>Mon, 04 Oct 2010 00:00:00 +0000</pubDate><guid>https://whileydave.com/2010/10/04/better-namespaces/</guid><description>An interesting problem I&amp;rsquo;ve encountered many times in Java is that of conflicting names. For example, suppose I have the following code:
import wyil.lang.*; import wyil.lang.Type.*; ... public static Type T_Bool = new Type.</description></item><item><title>Version 0.1</title><link>https://whileydave.com/downloads/jpure-210410/</link><pubDate>Fri, 01 Oct 2010 00:00:00 +0000</pubDate><guid>https://whileydave.com/downloads/jpure-210410/</guid><description/></item><item><title>Thoughts on Loop Invariants</title><link>https://whileydave.com/2010/09/30/thoughts-on-loop-invariants/</link><pubDate>Thu, 30 Sep 2010 00:00:00 +0000</pubDate><guid>https://whileydave.com/2010/09/30/thoughts-on-loop-invariants/</guid><description>With the recent addition of for and while loops to Whiley, I&amp;rsquo;ve been able to fiddle around with loop invariants and already I noticed a few things. Consider this little program:</description></item><item><title>On Flow-Sensitive Types in Whiley</title><link>https://whileydave.com/2010/09/22/on-flow-sensitive-types-in-whiley/</link><pubDate>Wed, 22 Sep 2010 00:00:00 +0000</pubDate><guid>https://whileydave.com/2010/09/22/on-flow-sensitive-types-in-whiley/</guid><description>In the ensuing months since the previous release of Whiley, I have been working away on a major rewrite of the compiler. This is now almost ready, at last! One of the &amp;ldquo;executive decisions&amp;rdquo; I made recently, was to move away from a declared variable model to a completely flow-sensitive typing model.</description></item><item><title>Java Pathfinder</title><link>https://whileydave.com/2010/09/20/java-pathfinder/</link><pubDate>Mon, 20 Sep 2010 00:00:00 +0000</pubDate><guid>https://whileydave.com/2010/09/20/java-pathfinder/</guid><description>Recently, Simon Doherty gave a short talk on using Java Pathfinder to find bugs in Java programs. Java Pathfinder is a model checker for Java code, particularly suited to reasoning about multi-threaded code and finding concurrency bugs.</description></item><item><title>Normalising Recursive Data Types</title><link>https://whileydave.com/2010/09/19/normalising-recursive-data-types/</link><pubDate>Sun, 19 Sep 2010 00:00:00 +0000</pubDate><guid>https://whileydave.com/2010/09/19/normalising-recursive-data-types/</guid><description>Recently, I came across an interesting problem with the type system I&amp;rsquo;m using in Whiley. Specifically, the problem relates to recursive types which are equivalent but not identical. Consider, for example, the following Whiley code:</description></item><item><title>James Bach on Software Testing</title><link>https://whileydave.com/2010/09/08/james-bach-on-software-testing/</link><pubDate>Wed, 08 Sep 2010 00:00:00 +0000</pubDate><guid>https://whileydave.com/2010/09/08/james-bach-on-software-testing/</guid><description>I&amp;rsquo;ve just been watching this YouTube presentation by James Bach:
James has a very tongue-in-cheek style, which I rather like, and he&amp;rsquo;s obviously not a great fan of the academic establishment:</description></item><item><title>Beautiful Code ... ?</title><link>https://whileydave.com/2010/08/19/beautiful-code-.../</link><pubDate>Thu, 19 Aug 2010 00:00:00 +0000</pubDate><guid>https://whileydave.com/2010/08/19/beautiful-code-.../</guid><description>Recently, I&amp;rsquo;ve been reading &amp;ldquo;Beautiful Code&amp;rdquo; (edited by Andy Oram &amp;amp; Greg Wilson). This is a collection of short papers by academics and professional software developers which explores the idea of beauty in software.</description></item><item><title>Short Demonstration of The Whiley Programming Language</title><link/><pubDate>Tue, 10 Aug 2010 00:00:00 +0000</pubDate><guid/><description/></item><item><title>The X10 Programming Language</title><link>https://whileydave.com/2010/08/05/the-x10-programming-language/</link><pubDate>Thu, 05 Aug 2010 00:00:00 +0000</pubDate><guid>https://whileydave.com/2010/08/05/the-x10-programming-language/</guid><description>X10 is an interesting and relatively new language from IBM being developed as part of DARPA&amp;rsquo;s High Productivity Computing Systems program. X10 is designed for high-performance parallel programming using a partitioned global address space model.</description></item><item><title>Infamous Software Failures in New Zealand</title><link>https://whileydave.com/2010/08/02/infamous-software-failures-in-new-zealand/</link><pubDate>Mon, 02 Aug 2010 00:00:00 +0000</pubDate><guid>https://whileydave.com/2010/08/02/infamous-software-failures-in-new-zealand/</guid><description>I&amp;rsquo;ve been writing a grant application recently, and wanted to list some example software failures that occurred in New Zealand. Here&amp;rsquo;s what I found:
In 2012, the role out of the new Novopay system for handling the teachers salary payrole caused numerous and ongoing problems.</description></item><item><title>Thinking about Recursive Constrained Types in Whiley</title><link>https://whileydave.com/2010/07/25/thinking-about-recursive-constrained-types-in-whiley/</link><pubDate>Sun, 25 Jul 2010 00:00:00 +0000</pubDate><guid>https://whileydave.com/2010/07/25/thinking-about-recursive-constrained-types-in-whiley/</guid><description>Whiley supports so-called Algebraic Data Types for constructing tree-like data structures. For example, an expression tree might be defined like so:
define ADD as 1 define SUB as 2 define MUL as 3 define DIV as 4 define binop as {ADD,SUB,MUL,DIV} define expr as int | (binop op, expr lhs, expr rhs) Using this definition for expr, we can create a variety of trees representing compound arithmetic expressions.</description></item><item><title>Thinking about Pre- and Post-Conditions in Whiley</title><link>https://whileydave.com/2010/07/23/thinking-about-pre-and-post-conditions-in-whiley/</link><pubDate>Fri, 23 Jul 2010 00:00:00 +0000</pubDate><guid>https://whileydave.com/2010/07/23/thinking-about-pre-and-post-conditions-in-whiley/</guid><description>The notion of pre- and post-conditions is well understood in the context of software verification. However, Whiley deviates from the norm by combining them into a single condition. The following illustrates a simple Whiley function:</description></item><item><title>Language Designers ... who wait?</title><link>https://whileydave.com/2010/07/22/language-designers-...-who-wait/</link><pubDate>Thu, 22 Jul 2010 00:00:00 +0000</pubDate><guid>https://whileydave.com/2010/07/22/language-designers-...-who-wait/</guid><description>Someone recently pointed me to the Rust programming language which has some very nice features, although it&amp;rsquo;s still in early stage development. In particular, the system statically prevents null pointer errors, and does not permit dangling pointers.</description></item><item><title>On Object-Oriented Programming</title><link>https://whileydave.com/2010/07/15/on-object-oriented-programming/</link><pubDate>Thu, 15 Jul 2010 00:00:00 +0000</pubDate><guid>https://whileydave.com/2010/07/15/on-object-oriented-programming/</guid><description>There&amp;rsquo;s an interesting interview with Ralph Johnson and Joe Armstrong over at QCon. They&amp;rsquo;re talking generally about whether OOP has been successful, and reflecting on the last few decades.
A few things from the interview caught my eye.</description></item><item><title>Finding Bugs in the Real World</title><link>https://whileydave.com/2010/07/08/finding-bugs-in-the-real-world/</link><pubDate>Thu, 08 Jul 2010 00:00:00 +0000</pubDate><guid>https://whileydave.com/2010/07/08/finding-bugs-in-the-real-world/</guid><description>There&amp;rsquo;s a really interesting article over on CACM about static analysis in the real world. Here&amp;rsquo;s the Link.
The article is a report from experiences gained in the commercialisation of a tool by Coverity which uses static code analysis to find bugs.</description></item><item><title>Kiwi Language Creator Acknowledged!</title><link>https://whileydave.com/2010/07/05/kiwi-language-creator-acknowledged/</link><pubDate>Mon, 05 Jul 2010 00:00:00 +0000</pubDate><guid>https://whileydave.com/2010/07/05/kiwi-language-creator-acknowledged/</guid><description>The Dom Post ran a short article over the weekend on kiwi Ross Ihaka, about the R programming language which he created along with Robert Gentleman at the University of Auckland.</description></item><item><title>Example: Sum Over a Positive List</title><link>https://whileydave.com/2010/06/30/example-sum-over-a-positive-list/</link><pubDate>Wed, 30 Jun 2010 00:00:00 +0000</pubDate><guid>https://whileydave.com/2010/06/30/example-sum-over-a-positive-list/</guid><description>So, here&amp;rsquo;s the first Whiley programming example. Obviously, it&amp;rsquo;s pretty simple as Whiley is not quite ready for big code just yet. The idea is to compute the sum of a positive list which, of course, will give you a positive number.</description></item><item><title>What is Extended Static Checking?</title><link>https://whileydave.com/2010/06/26/what-is-extended-static-checking/</link><pubDate>Sat, 26 Jun 2010 00:00:00 +0000</pubDate><guid>https://whileydave.com/2010/06/26/what-is-extended-static-checking/</guid><description>Extended Static Checking (ESC) is the main technique used in Whiley. *But, what is it? *Since there isn&amp;rsquo;t a huge amount of information available on the web, I thought some discussion about this would be useful.</description></item><item><title>Rich Hickey on Clojure (SE Radio)</title><link>https://whileydave.com/2010/06/23/rich-hickey-on-clojure-se-radio/</link><pubDate>Wed, 23 Jun 2010 00:00:00 +0000</pubDate><guid>https://whileydave.com/2010/06/23/rich-hickey-on-clojure-se-radio/</guid><description>I&amp;rsquo;ve just been listening to an interesting interview with Rich Hickery on Clojure over at SE Radio. I&amp;rsquo;m a big fan of Clojure, since it shares a lot of similar ideas with Whiley (really, it does &amp;hellip; trust me :).</description></item><item><title>The Trouble with Quantifier Instantiation in an SMT Solver? Triggers.</title><link>https://whileydave.com/2010/06/22/the-trouble-with-quantifier-instantiation-in-an-smt-solver-triggers./</link><pubDate>Tue, 22 Jun 2010 00:00:00 +0000</pubDate><guid>https://whileydave.com/2010/06/22/the-trouble-with-quantifier-instantiation-in-an-smt-solver-triggers./</guid><description>So, i&amp;rsquo;ve been recently working through the quantifier instantiation mechanism in wyone. This is a tricky, yet important topic. There&amp;rsquo;s been a lot of interesting research in this area as well (see further reading below for some examples), although I found the papers often hard work at times.</description></item><item><title>Experimental Security Analysis of a Modern Automobile</title><link>https://whileydave.com/2010/06/15/experimental-security-analysis-of-a-modern-automobile/</link><pubDate>Tue, 15 Jun 2010 00:00:00 +0000</pubDate><guid>https://whileydave.com/2010/06/15/experimental-security-analysis-of-a-modern-automobile/</guid><description>Another good paper I found recently was the following:
&amp;ldquo;Experimental Security Analysis of a Modern Automobile&amp;rdquo;, Hoscher, Czeskis, et al. In Proceedings of IEEE Symposium on Security and Privacy, 2010. [PDF]</description></item><item><title>Formal Methods: To the Moon and Back!</title><link>https://whileydave.com/2010/06/10/formal-methods-to-the-moon-and-back/</link><pubDate>Thu, 10 Jun 2010 00:00:00 +0000</pubDate><guid>https://whileydave.com/2010/06/10/formal-methods-to-the-moon-and-back/</guid><description>I recently came across a rather interesting presentation by Gerard Holzmann (author of the SPIN model checker) who&amp;rsquo;s currently working for NASA&amp;rsquo;s Jet Propulsion Lab, and previously worked at Bell Labs:</description></item><item><title>Dafny: An Automatic Program Verifier for Functional Correctness</title><link>https://whileydave.com/2010/06/07/dafny-an-automatic-program-verifier-for-functional-correctness/</link><pubDate>Mon, 07 Jun 2010 00:00:00 +0000</pubDate><guid>https://whileydave.com/2010/06/07/dafny-an-automatic-program-verifier-for-functional-correctness/</guid><description>So, last week the pl reading group chose to read this paper by Rustan Leino. Ignoring the fact that a number of people in our group are interested in this area, Rustan had recently given a presentation on Dafny here (his slides are here) and this was reason we chose this paper.</description></item><item><title>A Batch Algorithm for Maintaining a Topological Order</title><link>https://whileydave.com/publications/pk10_acsc/</link><pubDate>Fri, 01 Jan 2010 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/pk10_acsc/</guid><description>Abstract: The dynamic topological order problem is that of efficiently updating a topological order after some edge(s) are inserted into a graph. Much prior work exists on the unit-change version of this problem, where the order is updated after every single insertion.</description></item><item><title>Computing Tutte Polynomials</title><link>https://whileydave.com/publications/hpr10_toms/</link><pubDate>Fri, 01 Jan 2010 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/hpr10_toms/</guid><description>Abstract: The Tutte polynomial of a graph is a 2-variable polynomial graph invariant of considerable importance in both combinatorics and statistical physics. It contains several other polynomial invariants, such as the chromatic polynomial and flow polynomial as partial evaluations, and various numerical invariants such as the number of spanning trees as complete evaluations.</description></item><item><title>Edge-Selection Heuristics for Computing Tutte Polynomials</title><link>https://whileydave.com/publications/phr10_cjtcs/</link><pubDate>Fri, 01 Jan 2010 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/phr10_cjtcs/</guid><description>Abstract. The Tutte polynomial of a graph, also known as the partition function of theq-statePotts model, is a 2-variable polynomial graph invariant of considerable importance in bothcombinatorics and statistical physics. It contains several other polynomial invariants, such asthe chromatic polynomial and flow polynomial as partial evaluations, and various numericalinvariants such as the number of spanning trees as complete evaluations.</description></item><item><title>JPure</title><link>https://whileydave.com/projects/jpure/</link><pubDate>Fri, 01 Jan 2010 00:00:00 +0000</pubDate><guid>https://whileydave.com/projects/jpure/</guid><description>Purity Analysis is the problem of determining whether or not a method may have side-effects. This has applications in automatic parallelisation, extended static checking, and more. JPure is a novel purity system for Java that employs purity annotations which can be checked modularly.</description></item><item><title>Understanding the Impact of Collection Contracts on Design</title><link>https://whileydave.com/publications/npn10_tools/</link><pubDate>Fri, 01 Jan 2010 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/npn10_tools/</guid><description>Abstract: Java provides a specification for a user-defined general purpose equivalence operator for objects, but collections such as Set have more stringent requirements. This inconsistency breaks polymorphism: programmers must take care to follow Set’s contract rather than the more general Object contract if their object could enter a Set.</description></item><item><title>Whiley</title><link>https://whileydave.com/projects/whiley/</link><pubDate>Fri, 01 Jan 2010 00:00:00 +0000</pubDate><guid>https://whileydave.com/projects/whiley/</guid><description>Whiley is a hybrid imperative and functional programming language which has been under development since 2009. Find out more at whiley.org or try it online at whileylabs.com. The complete source code for the compiler and theorem prover is available on GitHub.</description></item><item><title>Version 0.9.13</title><link>https://whileydave.com/downloads/tuttev0.9.13/</link><pubDate>Sun, 01 Nov 2009 00:00:00 +0000</pubDate><guid>https://whileydave.com/downloads/tuttev0.9.13/</guid><description>The following updates have been made:
Version 0.9.12 introduced a feature whereby &amp;ldquo;large&amp;rdquo; graphs were never displaced from the cache. This was useful for us where we were computing the polynomial of the Truncated Icosahedron.</description></item><item><title>Version 0.9.12</title><link>https://whileydave.com/downloads/tuttev0.9.12/</link><pubDate>Sat, 01 Aug 2009 00:00:00 +0000</pubDate><guid>https://whileydave.com/downloads/tuttev0.9.12/</guid><description>The following updates have been made:
A long standing bug related to memory corruption has been fixed.
Support for 64bit machines now works correctly. This means you can use very large caches (e.</description></item><item><title>Edge-Selection Heuristics for Computing Tutte Polynomials</title><link>https://whileydave.com/publications/phr09_cats/</link><pubDate>Thu, 01 Jan 2009 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/phr09_cats/</guid><description>Abstract: The Tutte polynomial of a graph, also known as the partition function of the q-state Potts model, is a 2-variable polynomial graph invariant of considerable importance in both combinatorics and statistical physics.</description></item><item><title>Implementing relationships using Affinity</title><link>https://whileydave.com/publications/npn09_raool/</link><pubDate>Thu, 01 Jan 2009 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/npn09_raool/</guid><description/></item><item><title>Mocha: Type Inference for Java</title><link>https://whileydave.com/publications/male09_msc/</link><pubDate>Thu, 01 Jan 2009 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/male09_msc/</guid><description>Abstract: Static typing allows type errors to be revealed at compile time, which reduces the amount of maintenance and debugging that must occur later on. However, often the static type information included in source code is duplicate or redundant.</description></item><item><title>Optimising Java Programs with Pure Functions</title><link>https://whileydave.com/publications/walbran08_comp489/</link><pubDate>Sat, 01 Nov 2008 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/walbran08_comp489/</guid><description>Abstract. Java programs often contain expressions involving method calls that are executed many times in a loop but will always return the same value, such as checking the length of a collection through which the loop is iterating.</description></item><item><title>The Java Collections Profiler</title><link>https://whileydave.com/publications/hibbard08_bitt489/</link><pubDate>Sat, 01 Nov 2008 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/hibbard08_bitt489/</guid><description>Abstract. This document contains a full report on the Profiling Collections in Java project. The project focuses on the development of a tool that profiles the use of different implementations of the Collection interface in Java and allows us to analyse their use with regards to efficiency.</description></item><item><title>Version 0.9.10</title><link>https://whileydave.com/downloads/tuttev0.9.10/</link><pubDate>Fri, 01 Aug 2008 00:00:00 +0000</pubDate><guid>https://whileydave.com/downloads/tuttev0.9.10/</guid><description/></item><item><title>Version 0.9.11</title><link>https://whileydave.com/downloads/tuttev0.9.11/</link><pubDate>Fri, 01 Aug 2008 00:00:00 +0000</pubDate><guid>https://whileydave.com/downloads/tuttev0.9.11/</guid><description/></item><item><title>Version 0.9.9</title><link>https://whileydave.com/downloads/tuttev0.9.9/</link><pubDate>Tue, 01 Jul 2008 00:00:00 +0000</pubDate><guid>https://whileydave.com/downloads/tuttev0.9.9/</guid><description/></item><item><title>Version 0.9.8</title><link>https://whileydave.com/downloads/tuttev0.9.8/</link><pubDate>Sun, 01 Jun 2008 00:00:00 +0000</pubDate><guid>https://whileydave.com/downloads/tuttev0.9.8/</guid><description/></item><item><title>Version 0.9.7</title><link>https://whileydave.com/downloads/tuttev0.9.7/</link><pubDate>Tue, 01 Apr 2008 00:00:00 +0000</pubDate><guid>https://whileydave.com/downloads/tuttev0.9.7/</guid><description/></item><item><title>Caching and Incrementalisation for the Java Query Language</title><link>https://whileydave.com/publications/wpn08_oopsla/</link><pubDate>Tue, 01 Jan 2008 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/wpn08_oopsla/</guid><description>Abstract: Many contemporary object-oriented programming languages support first-class queries or comprehensions. These language extensions make it easier for programmers to write queries, but are generally implemented no more efficiently than the code using collections, iterators, and loops that they replace.</description></item><item><title>Implementing First-Class Relationships in Java</title><link>https://whileydave.com/publications/npn08_raool/</link><pubDate>Tue, 01 Jan 2008 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/npn08_raool/</guid><description/></item><item><title>Introducing Software Modelling with Alloy at VUW</title><link>https://whileydave.com/publications/npg08_formed/</link><pubDate>Tue, 01 Jan 2008 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/npg08_formed/</guid><description/></item><item><title>Java Bytecode Verification for @NonNull Types</title><link>https://whileydave.com/publications/mppd08_cc/</link><pubDate>Tue, 01 Jan 2008 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/mppd08_cc/</guid><description>Abstract: Java’s annotation mechanism allows us to extend its type system with non-null types. However, checking such types cannot be done using the existing bytecode verification algorithm. We extend this algorithm to verify non-null types using a novel technique that identifies aliasing relationships between local variables and stack locations in the JVM.</description></item><item><title>Object State Querying for Optimisation</title><link>https://whileydave.com/publications/pn08_mpool/</link><pubDate>Tue, 01 Jan 2008 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/pn08_mpool/</guid><description/></item><item><title>Patterns for ADT Optimisation</title><link>https://whileydave.com/publications/pn08_plop/</link><pubDate>Tue, 01 Jan 2008 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/pn08_plop/</guid><description>Abstract: Operations on abstract data types can be classified as either queries or updates — those that either query the current state, or update it. Modern object-oriented programming languages require classes/interfaces to support a predefined set of such operations.</description></item><item><title>The Java Compiler Kit</title><link>https://whileydave.com/projects/jkit/</link><pubDate>Tue, 01 Jan 2008 00:00:00 +0000</pubDate><guid>https://whileydave.com/projects/jkit/</guid><description>The Java Compiler Kit is a straightforward implementation of a Java compiler, designed with extensibility in mind. In building the JKit compiler, the aims were: firstly, to help with teaching compilers by considering an implementation for a fully fledged language (Java), rather than a stripped-down imitation language; secondly, to aid research in programming languages, compilers and verification.</description></item><item><title>The Java Query Language</title><link>https://whileydave.com/publications/willis08_msc/</link><pubDate>Tue, 01 Jan 2008 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/willis08_msc/</guid><description>Abstract: This thesis describes JQL, an extension to Java which provides object querying. Object querying is an abstraction of operations over collections, including operations that combine multiple collections, which would otherwise have to be manually implemented.</description></item><item><title>Visualizing the computation tree of the Tutte Polynomial</title><link>https://whileydave.com/publications/tpah08_softviz/</link><pubDate>Tue, 01 Jan 2008 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/tpah08_softviz/</guid><description/></item><item><title>Version 0.9.2</title><link>https://whileydave.com/downloads/tuttev0.9.2/</link><pubDate>Wed, 01 Aug 2007 00:00:00 +0000</pubDate><guid>https://whileydave.com/downloads/tuttev0.9.2/</guid><description/></item><item><title>Version 0.9.3</title><link>https://whileydave.com/downloads/tuttev0.9.3/</link><pubDate>Wed, 01 Aug 2007 00:00:00 +0000</pubDate><guid>https://whileydave.com/downloads/tuttev0.9.3/</guid><description/></item><item><title>Version 0.9.4</title><link>https://whileydave.com/downloads/tuttev0.9.4/</link><pubDate>Wed, 01 Aug 2007 00:00:00 +0000</pubDate><guid>https://whileydave.com/downloads/tuttev0.9.4/</guid><description/></item><item><title>Version 0.9.5</title><link>https://whileydave.com/downloads/tuttev0.9.5/</link><pubDate>Wed, 01 Aug 2007 00:00:00 +0000</pubDate><guid>https://whileydave.com/downloads/tuttev0.9.5/</guid><description/></item><item><title>Version 0.9.6</title><link>https://whileydave.com/downloads/tuttev0.9.6/</link><pubDate>Wed, 01 Aug 2007 00:00:00 +0000</pubDate><guid>https://whileydave.com/downloads/tuttev0.9.6/</guid><description/></item><item><title>Version 0.9.1</title><link>https://whileydave.com/downloads/tuttev0.9.1/</link><pubDate>Fri, 01 Jun 2007 00:00:00 +0000</pubDate><guid>https://whileydave.com/downloads/tuttev0.9.1/</guid><description/></item><item><title>A Dynamic Topological Sort Algorithm for Directed Acyclic Graphs</title><link>https://whileydave.com/publications/pk07_jea/</link><pubDate>Mon, 01 Jan 2007 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/pk07_jea/</guid><description>Abstract. We consider the problem of maintaining the topological order of a directed acyclic graph (DAG) in the presence of edge insertions and deletions. We present a new algorithm and, although this has inferior time complexity compared with the best previously known result, we find that its simplicity leads to better performance in practice.</description></item><item><title>Efficient Field-Sensitive Pointer Analysis for C</title><link>https://whileydave.com/publications/pkh07_toplas/</link><pubDate>Mon, 01 Jan 2007 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/pkh07_toplas/</guid><description>Abstract. The subject of this paper is flow- and context-insensitive pointer analysis. We present a novel approach for precisely modelling struct variables and indirect function calls. Our method em- phasises efficiency and simplicity and is based on a simple language of set constraints.</description></item><item><title>Patterns of Aspect-Oriented Design</title><link>https://whileydave.com/publications/nspb07_europlop/</link><pubDate>Mon, 01 Jan 2007 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/nspb07_europlop/</guid><description>Abstract: Aspect-oriented programming languages are becoming commonplace, and programmers are accumulating experience in building and maintaining aspect-oriented systems. This paper addresses how the use of these languages affects program design: how aspect-oriented languages change the design space, which designs should be emulated and which avoided, and the strengths and weaknesses of particular kinds of design.</description></item><item><title>Profiling with AspectJ</title><link>https://whileydave.com/publications/pwbk07_spe/</link><pubDate>Mon, 01 Jan 2007 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/pwbk07_spe/</guid><description>Abstract. This paper investigates whether AspectJ can be used for efficient profiling of Java programs. Profiling differs from other applications of AOP (e.g. tracing), since it necessitates efficient and often complex interactions with the target program.</description></item><item><title>Visualising the Tutte Polynomial Computation</title><link>https://whileydave.com/publications/tph07_sienz/</link><pubDate>Mon, 01 Jan 2007 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/tph07_sienz/</guid><description>Abstract: The Tutte polynomial is an important concept in graph theory which captures many important properties of graphs (e.g. chromatic number, number of spanning trees etc). It also provides a normalised representation that can be used as an equivalence relation on graphs and has applications in diverse areas such micro-biology and physics.</description></item><item><title>AspectJ for Multilevel Security</title><link>https://whileydave.com/publications/rpw06_acp4is/</link><pubDate>Sun, 01 Jan 2006 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/rpw06_acp4is/</guid><description>Abstract: A multilevel security (MLS) system has two primary goals: first, it is intended to prevent unauthorised personnel from accessing information at higher classification than their authorisation. Second, it is intended to prevent personnel from declassifying information.</description></item><item><title>Efficient Object Querying for Java</title><link>https://whileydave.com/publications/wpn06_ecoop/</link><pubDate>Sun, 01 Jan 2006 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/wpn06_ecoop/</guid><description>Abstract: Modern programming languages have little or no support for querying objects and collections. Programmers are forced to hand code such queries using nested loops, which is both cumbersome and inefficient.</description></item><item><title>Relationship Aspect Patterns</title><link>https://whileydave.com/publications/pn06_europlop/</link><pubDate>Sun, 01 Jan 2006 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/pn06_europlop/</guid><description>Abstract: Relationships between objects are almost as important to designs as the objects themselves. Most programming languages do not support relationships well, so programmers must implement relationships in terms of more primitive constructs.</description></item><item><title>Relationship Aspects</title><link>https://whileydave.com/publications/pn06_aosd/</link><pubDate>Sun, 01 Jan 2006 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/pn06_aosd/</guid><description>Abstract: The relationships between objects in object-oriented programs are as important as the objects themselves. Unfortunately, most object-oriented programming languages provide little support for such relationships, leaving the task of implementing them entirely to the programmer.</description></item><item><title>Towards a Semiotics of Object- and Aspect-Oriented Design</title><link>https://whileydave.com/publications/nbtp06_ecap/</link><pubDate>Sun, 01 Jan 2006 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/nbtp06_ecap/</guid><description>Abstract: Object-oriented design is based on the argument that objects in a program act as a simulation of objects in the real world. This paper will provide a semiotic account of object-oriented design patterns, treating an object as a sign comprised of some part of the real world, its realisation in the program, and the programmers intent about the program design (that the object model the world).</description></item><item><title>Tutte Polynomials</title><link>https://whileydave.com/projects/tutte/</link><pubDate>Sun, 01 Jan 2006 00:00:00 +0000</pubDate><guid>https://whileydave.com/projects/tutte/</guid><description>Overview. Tutte polynomials play an important role in graph theory, combinatorics, matroid theory, knot theory, and experimental physics. For example, the polynomials can be evaluated to find the number of spanning trees in a graph, the number of forests in a graph, the number of connected spanning subgraphs, the number of spanning subgraphs, and the number of acyclic orientations.</description></item><item><title>Some directed graph algorithms and their application to pointer analysis.</title><link>https://whileydave.com/publications/pearce05_phd/</link><pubDate>Sat, 01 Jan 2005 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/pearce05_phd/</guid><description>Abstract: This thesis is focused on improving execution time and precision of scalable pointer analysis. Such an analysis statically determines the targets of all pointer variables in a program. We formulate the analysis as a directed graph problem, where the solution can be obtained by a computation similar, in many ways, to transitive closure.</description></item><item><title>A Dynamic Algorithm for Topologically Sorting Directed Acyclic Graphs</title><link>https://whileydave.com/publications/pk04_wea/</link><pubDate>Thu, 01 Jan 2004 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/pk04_wea/</guid><description>Abstract: We consider how to maintain the topological order of a directed acyclic graph (DAG) in the presence of edge insertions and deletions. We present a new algorithm and, although this has marginally inferior time complexity compared with the best previously known result, we find that its simplicity leads to better performance in practice.</description></item><item><title>Automating Optimized Table-with-Polynomial Function Evaluation for FPGAs</title><link>https://whileydave.com/publications/lmpl04_fpl/</link><pubDate>Thu, 01 Jan 2004 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/lmpl04_fpl/</guid><description>Abstract: Function evaluation is at the core of many compute-intensive applications which perform well on reconfigurable platforms. Yet, in order to implement function evaluation efficiently, the FPGA programmer has to choose between a multitude of function evaluation methods such as table lookup, polynomial approximation, or table lookup combined with polynomial approximation.</description></item><item><title>Dynamic Topological Sort</title><link>https://whileydave.com/projects/dts/</link><pubDate>Thu, 01 Jan 2004 00:00:00 +0000</pubDate><guid>https://whileydave.com/projects/dts/</guid><description>The problem of topologically sorting a directed graph is about arranging its nodes so that all edges go in the same direction. For example, consider the following directed graph:
A topological sort of this graph is:</description></item><item><title>Efficient Field-Sensitive Pointer Analysis for C</title><link>https://whileydave.com/publications/pkh04_paste/</link><pubDate>Thu, 01 Jan 2004 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/pkh04_paste/</guid><description>Abstract: The subject of this paper is flow- and context-insensitive pointer analysis. We present a novel approach for precisely modelling struct variables and indirect function calls. Our method emphasises efficiency and simplicity and extends the language of set-constraints.</description></item><item><title>Online Cycle Detection and Difference Propagation: Applications to Pointer Analysis</title><link>https://whileydave.com/publications/pkh04_sqj/</link><pubDate>Thu, 01 Jan 2004 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/pkh04_sqj/</guid><description>Abstract. This paper presents and evaluates a number of techniques to improve the execution time of interprocedural pointer analysis in the context of C programs. The analysis is formulated as a graph of set constraintsand solved using a worklist algorithm.</description></item><item><title>Design Space Exploration with A Stream Compiler</title><link>https://whileydave.com/publications/mphl03_fpt/</link><pubDate>Wed, 01 Jan 2003 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/mphl03_fpt/</guid><description>Abstract: We consider speeding up general-purpose applications with hardware accelerators. Traditionally hardware accelera- tors are tediously hand-crafted to achieve top performance. ASC (A Stream Compiler) simplifies exploration of hard- ware accelerators by transforming the hardware design task into a software design process using only ’gcc’ and ’make’ to obtain a hardware netlist.</description></item><item><title>DJProf</title><link>https://whileydave.com/projects/djprof/</link><pubDate>Wed, 01 Jan 2003 00:00:00 +0000</pubDate><guid>https://whileydave.com/projects/djprof/</guid><description>DJProf is an experimental Java profiling tool which employs AspectJ to insert the necessary instrumentation for profiling rather than, for example, the Java Machine Profiler Interface (JVMPI). DJProf can be used to profile Java programs without modification (i.</description></item><item><title>Online Cycle Detection and Difference Propagation for Pointer Analysis</title><link>https://whileydave.com/publications/pkh03_scam/</link><pubDate>Wed, 01 Jan 2003 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/pkh03_scam/</guid><description>Abstract. This paper presents and evaluates a number of techniques to improve the execution time of interprocedural pointer analysis in the context of large C programs. The analysis is formulated as a graph of set constraints and solved using a worklist algorithm.</description></item><item><title>GILK: A Dynamic Instrumentation Tool for the Linux Kernel</title><link>https://whileydave.com/publications/pkfh02_tools/</link><pubDate>Tue, 01 Jan 2002 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/pkfh02_tools/</guid><description>Abstract: This paper desribes a dynamic instrumentation tool for the Linux Kernal which allows a stock Linux kernel to be modified while in execution, with instruments implemented as kernel modules. The Intel x86 architecture poses a particular problem, due to variable length instructions, which this paper addresses for the first time.</description></item><item><title>GILK</title><link>https://whileydave.com/projects/gilk/</link><pubDate>Sat, 01 Jan 2000 00:00:00 +0000</pubDate><guid>https://whileydave.com/projects/gilk/</guid><description>The GILK project was part of my master&amp;rsquo;s thesis at Imperial College London. The project is all about dynamic instrumentation of the Linux Kernel. This means that a stock (i.e. without any source code modification) kernel can be instrumented whilst in execution!</description></item><item><title>Instrumenting the Linux Kernel</title><link>https://whileydave.com/publications/pearce00_meng/</link><pubDate>Sat, 01 Jan 2000 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/pearce00_meng/</guid><description>Abstract: An instrumentation tool has been developed for the Linux kernel that uses the relatively new technique of runtime code splicing. This permits instrumentation of a running system, without any source code modification, by redirecting the flow of control to pass through carefully written code patches.</description></item></channel></rss>