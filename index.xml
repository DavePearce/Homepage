<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Dave's Homepage</title><link>https://whileydave.com/</link><description>Recent content on Dave's Homepage</description><generator>Hugo -- gohugo.io</generator><language>en-nz</language><lastBuildDate>Mon, 30 Nov 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://whileydave.com/index.xml" rel="self" type="application/rss+xml"/><item><title>Understanding Partial Moves in Rust</title><link>https://whileydave.com/2020/11/30/understanding-partial-moves-in-rust/</link><pubDate>Mon, 30 Nov 2020 00:00:00 +0000</pubDate><guid>https://whileydave.com/2020/11/30/understanding-partial-moves-in-rust/</guid><description>Recently I&amp;rsquo;ve been digging into Rust and, whilst it&amp;rsquo;s a great language on many fronts, I do find lots of hidden complexity. One example which doesn&amp;rsquo;t get much attention is partial moves.</description></item><item><title>Profiling the Java Compiler for Improved Incremental Compiler Design</title><link>https://whileydave.com/publications/oliver20_engr489/</link><pubDate>Sun, 01 Nov 2020 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/oliver20_engr489/</guid><description>Abstract. Compiling a program is a process which can take a long time, thereby breaking up a developer&amp;rsquo;s workflow and productivity. Incremental compilation is a method which aims to solve this problem.</description></item><item><title>Putting the Semantics into Semantic Versioning</title><link/><pubDate>Sun, 18 Oct 2020 00:00:00 +0000</pubDate><guid/><description/></item><item><title>Reverse Engineering of an Obfuscated Binary</title><link>https://whileydave.com/publications/yang20_msc/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/yang20_msc/</guid><description>Abstract: Reverse engineering is an important process employed by both attackers seeking to gain entry to a system as well as the security engineers that protect it. While there are numerous tools developed for this purpose, they often can be tedious to use and rely on prior obtained domain knowledge.</description></item><item><title>Functional Reactive Programming in Whiley</title><link/><pubDate>Sat, 26 Sep 2020 00:00:00 +0000</pubDate><guid/><description/></item><item><title>The Semantics of Semantic Versioning?</title><link>https://whileydave.com/2020/09/24/the-semantics-of-semantic-versioning/</link><pubDate>Thu, 24 Sep 2020 00:00:00 +0000</pubDate><guid>https://whileydave.com/2020/09/24/the-semantics-of-semantic-versioning/</guid><description>Semantic versioning is a surprisingly interesting topic when you get into it. Recently, myself and a few colleagues (Patrick &amp;amp; Jens) have been giving it some thought (and we even wrote an essay on it)!</description></item><item><title>Whiley is Ten Years Old!</title><link>https://whileydave.com/2020/09/01/whiley-is-ten-years-old/</link><pubDate>Tue, 01 Sep 2020 00:00:00 +0000</pubDate><guid>https://whileydave.com/2020/09/01/whiley-is-ten-years-old/</guid><description>The first commit recorded in the WhileyCompiler repository on Github is dated June 25th, 2010. That means Whiley has been going for just over ten years already! Wow, time sure does fly.</description></item><item><title>Putting the Semantics into Semantic Versioning</title><link>https://whileydave.com/publications/ldp20/</link><pubDate>Tue, 04 Aug 2020 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/ldp20/</guid><description>Abstract: The long-standing aspiration for software reuse has made astonishing strides in the past few years. Many modern software development ecosystems now come with rich sets of publicly-available components contributed by the community.</description></item><item><title>Computational Resources</title><link>https://whileydave.com/publications/rp2020_crc/</link><pubDate>Wed, 01 Jan 2020 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/rp2020_crc/</guid><description/></item><item><title>AtmoVis: Visualization of Air Quality Data</title><link>https://whileydave.com/publications/powley19_msc/</link><pubDate>Tue, 01 Jan 2019 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/powley19_msc/</guid><description>Abstract: Air quality has an adverse impact on the health of people living in areas with poor quality air. Monitoring is needed to understand the effects of poor air quality. It is difficult to compare measurements to find trends and patterns between different monitoring sites when data is contained in separate data stores.</description></item><item><title>Compiling Whiley for the Ethereum Virtial Machine</title><link>https://whileydave.com/publications/kumar19_engr489/</link><pubDate>Tue, 01 Jan 2019 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/kumar19_engr489/</guid><description>Abstract. Ethereum is a blockchain based platform that supports a Turing complete contract language. However, methods of writing smart contracts have been error prone. This has resulted in many historically expensive bugs such as the DAO.</description></item><item><title>Compiling Whiley for WebAssembly</title><link>https://whileydave.com/publications/hua19_comp489/</link><pubDate>Tue, 01 Jan 2019 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/hua19_comp489/</guid><description>Abstract. Whiley is a multi-paradigm programming language which supports Extended Static Checking through formal specification. At compile time, Whiley can identify common errors which are uncaught by a type checker, including division by zero, null reference and array out of bounds errors.</description></item><item><title>Dependency Versioning in the Wild</title><link>https://whileydave.com/publications/dpstb19_msr/</link><pubDate>Tue, 01 Jan 2019 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/dpstb19_msr/</guid><description>Abstract: Many modern software systems are built on top of existing packages (modules, components, libraries). The increasing number and complexity of dependencies has given rise to automated dependency management where package managers resolve symbolic dependencies against a central repository.</description></item><item><title>Efficient compilation of a verification-friendly programming language</title><link>https://whileydave.com/publications/weng19_phd/</link><pubDate>Tue, 01 Jan 2019 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/weng19_phd/</guid><description>Abstract. This thesis develops a compiler to convert a program written in the verification friendly programming language Whiley into an efficient implementation in C. Our compiler uses a mixture of static analysis, run-time monitoring and a code generator to and faster integer types, eliminate unnecessary array copies and de-allocate unused memory without garbage collection, so that Whiley programs can be translated into C code to run fast and for long periods on general operating systems as well as limited-resource embedded devices.</description></item><item><title>On the Architecture of a (Verifying) Compiler</title><link/><pubDate>Sun, 16 Dec 2018 00:00:00 +0000</pubDate><guid/><description/></item><item><title>A Symmetry Metric for Graphs and Line Diagrams</title><link>https://whileydave.com/publications/kmp18_diagrams/</link><pubDate>Mon, 01 Jan 2018 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/kmp18_diagrams/</guid><description/></item><item><title>An Introduction to Software Verification with Whiley</title><link>https://whileydave.com/publications/pug18_etss/</link><pubDate>Mon, 01 Jan 2018 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/pug18_etss/</guid><description>Abstract: This tutorial introduces the basic ideas of software specification and verification, which are important techniques for assuring the quality of software and eliminating common kinds of errors such as buffer overflow.</description></item><item><title>Inferring invariants from postconditions in Whiley</title><link>https://whileydave.com/publications/pope18_engr489/</link><pubDate>Mon, 01 Jan 2018 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/pope18_engr489/</guid><description>Abstract. For the formal verification of programs, loop invariants must be used to ensure the verifier understands the properties of a loop. These invariants are often trivial, and many are common between loops.</description></item><item><title>On Declarative Rewriting for Sound and Complete Union, Intersection and Negation Types</title><link>https://whileydave.com/publications/pea18_jvlc/</link><pubDate>Mon, 01 Jan 2018 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/pea18_jvlc/</guid><description>Abstract. Implementing the type system of a programming language is a critical task that is oftendone in an ad-hoc fashion. Whilst this makes it hard to ensure the system is sound, italso makes it difficult to extend as the language evolves.</description></item><item><title>QuickCheck for Whiley</title><link>https://whileydave.com/publications/chin18_engr489/</link><pubDate>Mon, 01 Jan 2018 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/chin18_engr489/</guid><description>Abstract. Whiley is a programming language that verifies code using formal specifications to improve software quality. Whiley contains a verifying compiler which can identify common bugs. However, the compiler is limited in its ability to discover bugs and may take a long time to verify large programs.</description></item><item><title>Rewriting for Sound and Complete Union, Intersection and Negation Types</title><link>https://whileydave.com/publications/pea18_gpce/</link><pubDate>Mon, 01 Jan 2018 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/pea18_gpce/</guid><description>Abstract: Implementing the type system of a programming language is a critical task that is often done in an ad-hoc fashion. Whilst this makes it hard to ensure the system is sound, it also makes it difficult to extend as the language evolves.</description></item><item><title>Towards Compilation of an Imperative Language for FPGAs</title><link>https://whileydave.com/publications/ppp18_vmil/</link><pubDate>Mon, 01 Jan 2018 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/ppp18_vmil/</guid><description>Abstract: Field-Programmable Gate Arrays (FPGA’s) have been around since the early 1980s and have now achieved relatively widespread use. For example, FPGAs are routinely used for high-performance computing, financial applications, seismic modelling, DNA sequence alignment, software defined networking and, occasionally, are even found in smartphones.</description></item><item><title>Version 0.9.18</title><link>https://whileydave.com/downloads/tuttev0.9.18/</link><pubDate>Mon, 01 Jan 2018 00:00:00 +0000</pubDate><guid>https://whileydave.com/downloads/tuttev0.9.18/</guid><description>The following updates have been made:
Updated code to eliminate C++ warnings and errors.
Addresses issue on MacOS High Sierra.</description></item><item><title>What does the Future of Programming Look Like?</title><link/><pubDate>Mon, 24 Jul 2017 00:00:00 +0000</pubDate><guid/><description/></item><item><title>Contracts in the Wild: A Study of Java Programs</title><link/><pubDate>Tue, 27 Jun 2017 00:00:00 +0000</pubDate><guid/><description/></item><item><title>Array Programming in Whiley</title><link>https://whileydave.com/publications/pea17_array/</link><pubDate>Sun, 01 Jan 2017 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/pea17_array/</guid><description>Abstract: Arrays are a fundamental mechanism for developing and reasoning about programs. Using them, one can easily encode a range of important algorithms from various domains, such as for sorting, graph traversal, heap manipulation and more.</description></item><item><title>Classless Object Semantics</title><link>https://whileydave.com/publications/jones17_phd/</link><pubDate>Sun, 01 Jan 2017 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/jones17_phd/</guid><description>Abstract: Objects have been categorised into classes that declare and implement their behaviour ever since the paradigm of object-orientation in programming languages was first conceived. Classes have an integral role in the design and theory of object-oriented languages, and often appear alongside objects as a foundational concept of the paradigm in many theoretical models.</description></item><item><title>Compiling Whiley to FPGAs</title><link>https://whileydave.com/publications/pauget17_project/</link><pubDate>Sun, 01 Jan 2017 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/pauget17_project/</guid><description>Abstract. Improving code performances lies more and more in the relevant use of computational helpers. Computing platforms like OpenCL or CUDA that enable to relocate resource consuming calculations to graphics processing unit (GPU) are now ordinary.</description></item><item><title>Contracts in the Wild: A Study of Java Programs</title><link>https://whileydave.com/publications/dpjb17_ecoop/</link><pubDate>Sun, 01 Jan 2017 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/dpjb17_ecoop/</guid><description>Abstract: The use of formal contracts has long been advocated as an approach to develop programs that are provably correct. However, the reality is that adoption of contracts has been slow in practice.</description></item><item><title>Making Whiley Boogie!</title><link>https://whileydave.com/publications/upg17_ifm/</link><pubDate>Sun, 01 Jan 2017 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/upg17_ifm/</guid><description>Abstract: The quest to develop increasingly sophisticated verification systems continues unabated. Tools such as Dafny, Spec#, ESC/Java, SPARK Ada, and Whiley attempt to seamlessly integrate specification and verification into a programming language, in a similar way to type checking.</description></item><item><title>A Mechanical Soundness Proof for Subtyping over Recursive Types</title><link>https://whileydave.com/publications/jp16_ftfjp/</link><pubDate>Fri, 01 Jan 2016 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/jp16_ftfjp/</guid><description>Abstract: Structural type systems provide an interesting alternative to the more common nominal typing scheme. Several existing languages employ structural types in some form, including Modula-3, Scala and various extensions proposed for Java.</description></item><item><title>A Space Efficient Algorithm for Detecting Strongly Connected Components</title><link>https://whileydave.com/publications/pea16_ipl/</link><pubDate>Fri, 01 Jan 2016 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/pea16_ipl/</guid><description>Abstract. Tarjan’s algorihm for finding the strongly connected components of a directed graph is widely used and acclaimed. His original algorithm required at most v(2 + 5w) bits of storage, where w is the machine’s word size, whilst Nuutila and Soisalon-Soininen reduced this to v(1 + 4w).</description></item><item><title>Lifetime Analysis for Whiley</title><link>https://whileydave.com/publications/schweizer16_msc/</link><pubDate>Fri, 01 Jan 2016 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/schweizer16_msc/</guid><description>Abstract. Safety critical environments require high programming standards. Verification is a way to prove absence of certain faults and to make sure that a program meets a given specification. Unfortunately, most modern programming languages do not actively support verification.</description></item><item><title>Version 0.9.17</title><link>https://whileydave.com/downloads/tuttev0.9.17/</link><pubDate>Fri, 01 Jan 2016 00:00:00 +0000</pubDate><guid>https://whileydave.com/downloads/tuttev0.9.17/</guid><description>The following updates have been made:
Added support for the --split-edges option. This allows splitting a graph based on the number of edges, rather than the number of vertices.</description></item><item><title>The Whiley Programming Language</title><link/><pubDate>Wed, 26 Aug 2015 00:00:00 +0000</pubDate><guid/><description/></item><item><title>Whiley as a Research Project</title><link/><pubDate>Mon, 23 Mar 2015 00:00:00 +0000</pubDate><guid/><description/></item><item><title>Comparing Graph Layouts for Vertex Selection Tasks</title><link>https://whileydave.com/publications/kpm15_ozchi/</link><pubDate>Thu, 01 Jan 2015 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/kpm15_ozchi/</guid><description>Abstract: Different graph layouts can affect a user’s ability to complete both passive understanding and active interaction tasks. While most research exploring the effects of graph layout looks at a user’s ability to accomplish a passive understanding task, this paper’s novel contribution is looking at their ability to complete a selection task.</description></item><item><title>Designing a Verifying Compiler: Lessons Learned from Developing Whiley</title><link>https://whileydave.com/publications/pg15_scp/</link><pubDate>Thu, 01 Jan 2015 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/pg15_scp/</guid><description>Abstract. An ongoing challenge for computer science is the development of a tool which automati- cally verifies programs meet their specifications, and are free from runtime errors such as divide-by-zero, array out-of-bounds and null dereferences.</description></item><item><title>Developing a Whiley-to-JavaScript Translator</title><link>https://whileydave.com/publications/slater15_engr489/</link><pubDate>Thu, 01 Jan 2015 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/slater15_engr489/</guid><description>Abstract. Executing Whiley in the web browser requires a server for processing. With many people using Whiley in the web browser simultaneously, this server can become very slow. JavaScript is programming language designed to execute in the web browser without a server.</description></item><item><title>Identifying Redundant Test Cases</title><link>https://whileydave.com/publications/shaw15_engr489/</link><pubDate>Thu, 01 Jan 2015 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/shaw15_engr489/</guid><description>Abstract. This project investigates tracing the method call information of Java JUnit Tests and using the information to identify redundant tests in a test suite. There are a variety of different methods implemented (and experimented on) to identify redundancy within a suite.</description></item><item><title>Integer Range Analysis for Whiley on Embedded Systems</title><link>https://whileydave.com/publications/pea15_seus/</link><pubDate>Thu, 01 Jan 2015 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/pea15_seus/</guid><description>Abstract: Programs written in the Whiley programming language are verified at compile-time to ensure all function specifications are met. The purpose of doing this is to eliminate as many software bugs as possible and, thus, Whiley is ideally suited for use in safety-critical systems.</description></item><item><title>Some Usability Hypotheses for Verification</title><link>https://whileydave.com/publications/pea15_plateau/</link><pubDate>Thu, 01 Jan 2015 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/pea15_plateau/</guid><description>Abstract: The idea of specifying and verifying software to eliminate errors has been studied extensively over the last three decades or more. Recent advances in automated theorem proving have given rise to a range of new verification tools being developed.</description></item><item><title>The Whiley Rewrite Language (WyRL)</title><link>https://whileydave.com/publications/pea15_sle/</link><pubDate>Thu, 01 Jan 2015 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/pea15_sle/</guid><description>Abstract: The Whiley Rewrite Language (WyRL) is a standalone tool providing a domain-specific declarative rewrite language and code generator. The tool is currently used to generate a critical component of the Whiley verifying compiler, namely the automated theorem prover.</description></item><item><title>An Empirical Evaluation of Force-Directed Graph Layout</title><link>https://whileydave.com/publications/klapaukh14_phd/</link><pubDate>Wed, 01 Jan 2014 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/klapaukh14_phd/</guid><description>Abstract: Force-directed graph layout is a widely used algorithm for the automatic layout of graphs. Little experimental work has been done exploring the behaviour of the algorithm under a variety of conditions.</description></item><item><title>Demonstrating Whiley on an Embedded System</title><link>https://whileydave.com/publications/stevens14_engr489/</link><pubDate>Wed, 01 Jan 2014 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/stevens14_engr489/</guid><description>Abstract. Developing and verifying the software for safety critical embedded systems can be difficult and expensive due to unique constraints, including limited RAM and minimalist operating systems. This report looks at Whiley, a verifying compiler, which is intended to improve the correctness of code on a variety of systems.</description></item><item><title>Graceful Language Extensions and Interfaces</title><link>https://whileydave.com/publications/homer14_phd/</link><pubDate>Wed, 01 Jan 2014 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/homer14_phd/</guid><description>Abstract: Grace is a programming language under development aimed at education. Grace is object-oriented, imperative, and block-structured, and intended for use in first- and second-year object-oriented programming courses. We present a number of language features we have designed for Grace and implemented in our self-hosted compiler.</description></item><item><title>Maintaining Private Views in Java</title><link>https://whileydave.com/publications/haslett14_msc/</link><pubDate>Wed, 01 Jan 2014 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/haslett14_msc/</guid><description>Abstract: When developers collaborate on a project there are times when the code diverges. When this happens the code may need to be refactored to best suit the changes before they are applied.</description></item><item><title>Software Language Engineering - 7th International Conference</title><link>https://whileydave.com/publications/cpbv14_sle/</link><pubDate>Wed, 01 Jan 2014 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/cpbv14_sle/</guid><description>Proceedings of the 7th International Conference on Software Language Engineering (SLE). See the conference homepage here.</description></item><item><title>Towards a Vertex and Edge Label Aware Force Directed Layout Algorithm</title><link>https://whileydave.com/publications/kpm14_acsc/</link><pubDate>Wed, 01 Jan 2014 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/kpm14_acsc/</guid><description>Abstract: Many automatic graph layout algorithms can cause shaped vertices and edge labels (which have a size when drawn on the screen) to overlap in the resulting visualisation. Overlaps can hide information that users expect to see in cases where the graph is small.</description></item><item><title>Verifying Whiley Programs using an Off-the-Shelf SMT Solver</title><link>https://whileydave.com/publications/wylde14_engr489/</link><pubDate>Wed, 01 Jan 2014 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/wylde14_engr489/</guid><description>Abstract. This project investigated the integration of external theorem proving tools with Whiley — specifically, Satisfiability Modulo Theories (SMT) solvers — to increase the number of verifiable Whiley programs. The current verifier, the Whiley Constraint Solver (WyCS), is limited and hence there is a difficulty in verifying Whiley programs.</description></item><item><title>Dave Pearce on Whiley</title><link/><pubDate>Wed, 05 Jun 2013 00:00:00 +0000</pubDate><guid/><description/></item><item><title>Writing Loop Invariants in Whiley</title><link/><pubDate>Sun, 27 Jan 2013 00:00:00 +0000</pubDate><guid/><description/></item><item><title>A Calculus for Constraint-Based Flow Typing</title><link>https://whileydave.com/publications/pea13_beat/</link><pubDate>Tue, 01 Jan 2013 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/pea13_beat/</guid><description/></item><item><title>A Calculus for Constraint-Based Flow Typing</title><link>https://whileydave.com/publications/pea13_ftfjp/</link><pubDate>Tue, 01 Jan 2013 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/pea13_ftfjp/</guid><description>Abstract: Flow typing offers an alternative to traditional Hindley-Milner type inference. A key distinction is that variables may have different types at different program points. Flow typing systems are typically formalised in the style of a dataflow analysis.</description></item><item><title>Balloon Types for Safe Parallelisation over Arbitrary Object Graphs</title><link>https://whileydave.com/publications/spgp13_wodet/</link><pubDate>Tue, 01 Jan 2013 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/spgp13_wodet/</guid><description>Abstract: Safe parallelisation of object-oriented programs requires static guarantees about the shape and/or intended usage of reachable objects. For example, transitively immutable objects lend themselves naturally to concurrent access. However, parallelising tasks which potentially mutate reachable objects is more challenging.</description></item><item><title>Compiling Whiley Programs for a General Purpose GPU</title><link>https://whileydave.com/publications/ruarus13_engr489/</link><pubDate>Tue, 01 Jan 2013 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/ruarus13_engr489/</guid><description>Abstract. This project investigates improving the performance of Whiley programs by executing portions of these programs on GPUs while maintaining as closely as possible the semantics of the language. Programs written in languages such as Whiley are typically not well suited to execution on GPUs which exhibit large-scale data parallelism in contrast to small-scale task parallelism seen on CPUs.</description></item><item><title>OwnKit: Inferring Modularly Checkable Ownership Annotations for Java</title><link>https://whileydave.com/publications/dpp13_aswec/</link><pubDate>Tue, 01 Jan 2013 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/dpp13_aswec/</guid><description>Abstract: Ownership and related systems impose restrictions on the object graph that can help improve program structure, exploit concurrency and verify software. Such systems rely on the presence of appropriate ownership annotations in the source code.</description></item><item><title>Reflections on Verifying Software with Whiley</title><link>https://whileydave.com/publications/pg13_ftscs/</link><pubDate>Tue, 01 Jan 2013 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/pg13_ftscs/</guid><description>Abstract: An ongoing challenge for computer science is the development of a tool which automatically verifies that programs meet their specifications, and are free from runtime errors such as divide-by-zero, array out-of-bounds and null dereferences.</description></item><item><title>Sound and Complete Flow Typing with Unions, Intersections and Negations</title><link>https://whileydave.com/publications/pea13_vmcai/</link><pubDate>Tue, 01 Jan 2013 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/pea13_vmcai/</guid><description>Abstract: Flow typing is becoming a popular mechanism for typing existing programs written in untyped languages (e.g. JavaScript, Racket, Groovy). Such systems require intersections for the true-branch of a type test, negations for the false-branch, and unions to capture the flow of information at meet points.</description></item><item><title>Whiley: a Platform for Research in Software Verification</title><link>https://whileydave.com/publications/pg13_sle/</link><pubDate>Tue, 01 Jan 2013 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/pg13_sle/</guid><description>Abstract: An ongoing challenge for computer science is the development of a tool which automatically verifies programs meet their specifications, and are free from runtime errors such as divide-by-zero, array out-of-bounds and null dereferences.</description></item><item><title>Patterns as Objects in Grace</title><link>https://whileydave.com/publications/hnbbp12_dls/</link><pubDate>Sun, 01 Jan 2012 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/hnbbp12_dls/</guid><description>Abstract: Object orientation and pattern matching are often seen as conflicting approaches to program design. Object oriented programs place type-dependent behaviour inside objects and invoke it via dynamic dispatch, while pattern matching programs place type-dependent behaviour outside data structures and invoke it via multiway conditionals (case statements).</description></item><item><title>Profiling Field Initialization for Java</title><link>https://whileydave.com/publications/npn12_rv/</link><pubDate>Sun, 01 Jan 2012 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/npn12_rv/</guid><description>Abstract: Java encourages programmers to use constructor methods to initialise objects, supports final modifiers for documenting fields which are never modified and employs static checking to ensure such fields are only ever initialised inside constructors.</description></item><item><title>Profiling Initialisation Behaviour in Java</title><link>https://whileydave.com/publications/nelson12_phd/</link><pubDate>Sun, 01 Jan 2012 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/nelson12_phd/</guid><description>Abstract: Freshly created objects are a blank slate: their mutable state and their constant properties must be initialised before they can be used. Programming languages like Java typically support object initialisation by providing constructor methods.</description></item><item><title>The Whiley Programming Language</title><link/><pubDate>Tue, 20 Dec 2011 00:00:00 +0000</pubDate><guid/><description/></item><item><title>Version 0.9.16</title><link>https://whileydave.com/downloads/tuttev0.9.16/</link><pubDate>Thu, 01 Dec 2011 00:00:00 +0000</pubDate><guid>https://whileydave.com/downloads/tuttev0.9.16/</guid><description>The following updates have been made:
Incorporated the vorder push heuristic suggested by Michael Monagan. As part of this, I&amp;rsquo;ve added the ability to sort the vertex order according to a depth-first or breadth-first search.</description></item><item><title>Version 0.9.15</title><link>https://whileydave.com/downloads/tuttev0.9.15/</link><pubDate>Thu, 01 Sep 2011 00:00:00 +0000</pubDate><guid>https://whileydave.com/downloads/tuttev0.9.15/</guid><description>The following updates have been made:
For the --chromatic option, the tool now automatically removes multi-edges on the input graph. Thanks to Alan Sokal for pointing out this bug.</description></item><item><title>Version 0.2</title><link>https://whileydave.com/downloads/jpure-110711/</link><pubDate>Fri, 01 Jul 2011 00:00:00 +0000</pubDate><guid>https://whileydave.com/downloads/jpure-110711/</guid><description/></item><item><title>Version 0.9.14</title><link>https://whileydave.com/downloads/tuttev0.9.14/</link><pubDate>Tue, 01 Feb 2011 00:00:00 +0000</pubDate><guid>https://whileydave.com/downloads/tuttev0.9.14/</guid><description>The following updates have been made:
Added better support for report statistical data on the operation of the cache. This is to help diagnosing cache behaviour, as there&amp;rsquo;s some interesting possibilities for optimising the caching strategies.</description></item><item><title>Formalisation and Implementation of an Algorithm for Bytecode Verification of @NonNull Types</title><link>https://whileydave.com/publications/mppd11_scp/</link><pubDate>Sat, 01 Jan 2011 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/mppd11_scp/</guid><description>Abstract. Java&amp;rsquo;s annotation mechanism allows us to extend its type system with non-null types. Checking such types cannot be done using the existing bytecode verification algorithm. We extend this algorithm to verify non-null types using a novel technique that identifies aliasing relationships between local variables and stack locations in the JVM.</description></item><item><title>Implementing a Language with Flow-Sensitive and Structural Typing on the JVM</title><link>https://whileydave.com/publications/pn11_bytecode/</link><pubDate>Sat, 01 Jan 2011 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/pn11_bytecode/</guid><description>Abstract. Dynamically typed languages are flexible and impose few burdens on the programmer. In contrast, static typing leads to software that is more efficient and has fewer errors. However, static type systems traditionally require every variable to have one type, and that relationships between types (e.</description></item><item><title>Integrating the Actor Model into the Whiley Programming Language</title><link>https://whileydave.com/publications/jones11_engr489/</link><pubDate>Sat, 01 Jan 2011 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/jones11_engr489/</guid><description>Abstract. Introducing concurrent behaviour into a program tends to also introduce unpredictable behaviour. The actor model is an attempt to simplify concurrency and reduce such problems. The Whiley programming language is structured around concurrent processes, which are analogous to actors, but it runs on top of the Java Virtual Machine, which does not provide support for the model.</description></item><item><title>JPure: a Modular Purity System for Java</title><link>https://whileydave.com/publications/pea11_cc/</link><pubDate>Sat, 01 Jan 2011 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/pea11_cc/</guid><description>Abstract: Purity Analysis is the problem of determining whether or not a method may have side-effects. This has applications in automatic parallelisation, extended static checking, and more. We present a novel purity system for Java that employs purity annotations which can be checked modularly.</description></item><item><title>OwnKit: Ownership Inference for Java</title><link>https://whileydave.com/publications/dymnikov11_msc/</link><pubDate>Sat, 01 Jan 2011 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/dymnikov11_msc/</guid><description>Abstract: Object ownership allows us to statically control run-time aliasing in order to provide a strong notion of object encapsulation. Unfortunately in order to use ownership, code must first be annotated with extra type information.</description></item><item><title>Version 0.1</title><link>https://whileydave.com/downloads/jpure-210410/</link><pubDate>Fri, 01 Oct 2010 00:00:00 +0000</pubDate><guid>https://whileydave.com/downloads/jpure-210410/</guid><description/></item><item><title>Short Demonstration of The Whiley Programming Language</title><link/><pubDate>Tue, 10 Aug 2010 00:00:00 +0000</pubDate><guid/><description/></item><item><title>A Batch Algorithm for Maintaining a Topological Order</title><link>https://whileydave.com/publications/pk10_acsc/</link><pubDate>Fri, 01 Jan 2010 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/pk10_acsc/</guid><description>Abstract: The dynamic topological order problem is that of efficiently updating a topological order after some edge(s) are inserted into a graph. Much prior work exists on the unit-change version of this problem, where the order is updated after every single insertion.</description></item><item><title>Computing Tutte Polynomials</title><link>https://whileydave.com/publications/hpr10_toms/</link><pubDate>Fri, 01 Jan 2010 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/hpr10_toms/</guid><description>Abstract: The Tutte polynomial of a graph is a 2-variable polynomial graph invariant of considerable importance in both combinatorics and statistical physics. It contains several other polynomial invariants, such as the chromatic polynomial and flow polynomial as partial evaluations, and various numerical invariants such as the number of spanning trees as complete evaluations.</description></item><item><title>Edge-Selection Heuristics for Computing Tutte Polynomials</title><link>https://whileydave.com/publications/phr10_cjtcs/</link><pubDate>Fri, 01 Jan 2010 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/phr10_cjtcs/</guid><description>Abstract. The Tutte polynomial of a graph, also known as the partition function of theq-statePotts model, is a 2-variable polynomial graph invariant of considerable importance in bothcombinatorics and statistical physics. It contains several other polynomial invariants, such asthe chromatic polynomial and flow polynomial as partial evaluations, and various numericalinvariants such as the number of spanning trees as complete evaluations.</description></item><item><title>JPure</title><link>https://whileydave.com/projects/jpure/</link><pubDate>Fri, 01 Jan 2010 00:00:00 +0000</pubDate><guid>https://whileydave.com/projects/jpure/</guid><description>Purity Analysis is the problem of determining whether or not a method may have side-effects. This has applications in automatic parallelisation, extended static checking, and more. JPure is a novel purity system for Java that employs purity annotations which can be checked modularly.</description></item><item><title>Understanding the Impact of Collection Contracts on Design</title><link>https://whileydave.com/publications/npn10_tools/</link><pubDate>Fri, 01 Jan 2010 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/npn10_tools/</guid><description>Abstract: Java provides a specification for a user-defined general purpose equivalence operator for objects, but collections such as Set have more stringent requirements. This inconsistency breaks polymorphism: programmers must take care to follow Set’s contract rather than the more general Object contract if their object could enter a Set.</description></item><item><title>Whiley</title><link>https://whileydave.com/projects/whiley/</link><pubDate>Fri, 01 Jan 2010 00:00:00 +0000</pubDate><guid>https://whileydave.com/projects/whiley/</guid><description>Whiley is a hybrid imperative and functional programming language which has been under development since 2009. Find out more at whiley.org or try it online at whileylabs.com. The complete source code for the compiler and theorem prover is available on GitHub.</description></item><item><title>Version 0.9.13</title><link>https://whileydave.com/downloads/tuttev0.9.13/</link><pubDate>Sun, 01 Nov 2009 00:00:00 +0000</pubDate><guid>https://whileydave.com/downloads/tuttev0.9.13/</guid><description>The following updates have been made:
Version 0.9.12 introduced a feature whereby &amp;ldquo;large&amp;rdquo; graphs were never displaced from the cache. This was useful for us where we were computing the polynomial of the Truncated Icosahedron.</description></item><item><title>Version 0.9.12</title><link>https://whileydave.com/downloads/tuttev0.9.12/</link><pubDate>Sat, 01 Aug 2009 00:00:00 +0000</pubDate><guid>https://whileydave.com/downloads/tuttev0.9.12/</guid><description>The following updates have been made:
A long standing bug related to memory corruption has been fixed.
Support for 64bit machines now works correctly. This means you can use very large caches (e.</description></item><item><title>Edge-Selection Heuristics for Computing Tutte Polynomials</title><link>https://whileydave.com/publications/phr09_cats/</link><pubDate>Thu, 01 Jan 2009 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/phr09_cats/</guid><description>Abstract: The Tutte polynomial of a graph, also known as the partition function of the q-state Potts model, is a 2-variable polynomial graph invariant of considerable importance in both combinatorics and statistical physics.</description></item><item><title>Implementing relationships using Affinity</title><link>https://whileydave.com/publications/npn09_raool/</link><pubDate>Thu, 01 Jan 2009 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/npn09_raool/</guid><description/></item><item><title>Mocha: Type Inference for Java</title><link>https://whileydave.com/publications/male09_msc/</link><pubDate>Thu, 01 Jan 2009 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/male09_msc/</guid><description>Abstract: Static typing allows type errors to be revealed at compile time, which reduces the amount of maintenance and debugging that must occur later on. However, often the static type information included in source code is duplicate or redundant.</description></item><item><title>Version 0.9.10</title><link>https://whileydave.com/downloads/tuttev0.9.10/</link><pubDate>Fri, 01 Aug 2008 00:00:00 +0000</pubDate><guid>https://whileydave.com/downloads/tuttev0.9.10/</guid><description/></item><item><title>Version 0.9.11</title><link>https://whileydave.com/downloads/tuttev0.9.11/</link><pubDate>Fri, 01 Aug 2008 00:00:00 +0000</pubDate><guid>https://whileydave.com/downloads/tuttev0.9.11/</guid><description/></item><item><title>Version 0.9.9</title><link>https://whileydave.com/downloads/tuttev0.9.9/</link><pubDate>Tue, 01 Jul 2008 00:00:00 +0000</pubDate><guid>https://whileydave.com/downloads/tuttev0.9.9/</guid><description/></item><item><title>Version 0.9.8</title><link>https://whileydave.com/downloads/tuttev0.9.8/</link><pubDate>Sun, 01 Jun 2008 00:00:00 +0000</pubDate><guid>https://whileydave.com/downloads/tuttev0.9.8/</guid><description/></item><item><title>Version 0.9.7</title><link>https://whileydave.com/downloads/tuttev0.9.7/</link><pubDate>Tue, 01 Apr 2008 00:00:00 +0000</pubDate><guid>https://whileydave.com/downloads/tuttev0.9.7/</guid><description/></item><item><title>Caching and Incrementalisation for the Java Query Language</title><link>https://whileydave.com/publications/wpn08_oopsla/</link><pubDate>Tue, 01 Jan 2008 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/wpn08_oopsla/</guid><description>Abstract: Many contemporary object-oriented programming languages support first-class queries or comprehensions. These language extensions make it easier for programmers to write queries, but are generally implemented no more efficiently than the code using collections, iterators, and loops that they replace.</description></item><item><title>Implementing First-Class Relationships in Java</title><link>https://whileydave.com/publications/npn08_raool/</link><pubDate>Tue, 01 Jan 2008 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/npn08_raool/</guid><description/></item><item><title>Introducing Software Modelling with Alloy at VUW</title><link>https://whileydave.com/publications/npg08_formed/</link><pubDate>Tue, 01 Jan 2008 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/npg08_formed/</guid><description/></item><item><title>Java Bytecode Verification for @NonNull Types</title><link>https://whileydave.com/publications/mppd08_cc/</link><pubDate>Tue, 01 Jan 2008 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/mppd08_cc/</guid><description>Abstract: Java’s annotation mechanism allows us to extend its type system with non-null types. However, checking such types cannot be done using the existing bytecode verification algorithm. We extend this algorithm to verify non-null types using a novel technique that identifies aliasing relationships between local variables and stack locations in the JVM.</description></item><item><title>Object State Querying for Optimisation</title><link>https://whileydave.com/publications/pn08_mpool/</link><pubDate>Tue, 01 Jan 2008 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/pn08_mpool/</guid><description/></item><item><title>Patterns for ADT Optimisation</title><link>https://whileydave.com/publications/pn08_plop/</link><pubDate>Tue, 01 Jan 2008 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/pn08_plop/</guid><description>Abstract: Operations on abstract data types can be classified as either queries or updates — those that either query the current state, or update it. Modern object-oriented programming languages require classes/interfaces to support a predefined set of such operations.</description></item><item><title>The Java Compiler Kit</title><link>https://whileydave.com/projects/jkit/</link><pubDate>Tue, 01 Jan 2008 00:00:00 +0000</pubDate><guid>https://whileydave.com/projects/jkit/</guid><description>The Java Compiler Kit is a straightforward implementation of a Java compiler, designed with extensibility in mind. In building the JKit compiler, the aims were: firstly, to help with teaching compilers by considering an implementation for a fully fledged language (Java), rather than a stripped-down imitation language; secondly, to aid research in programming languages, compilers and verification.</description></item><item><title>The Java Query Language</title><link>https://whileydave.com/publications/willis08_msc/</link><pubDate>Tue, 01 Jan 2008 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/willis08_msc/</guid><description>Abstract: This thesis describes JQL, an extension to Java which provides object querying. Object querying is an abstraction of operations over collections, including operations that combine multiple collections, which would otherwise have to be manually implemented.</description></item><item><title>Visualizing the computation tree of the Tutte Polynomial</title><link>https://whileydave.com/publications/tpah08_softviz/</link><pubDate>Tue, 01 Jan 2008 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/tpah08_softviz/</guid><description/></item><item><title>Version 0.9.2</title><link>https://whileydave.com/downloads/tuttev0.9.2/</link><pubDate>Wed, 01 Aug 2007 00:00:00 +0000</pubDate><guid>https://whileydave.com/downloads/tuttev0.9.2/</guid><description/></item><item><title>Version 0.9.3</title><link>https://whileydave.com/downloads/tuttev0.9.3/</link><pubDate>Wed, 01 Aug 2007 00:00:00 +0000</pubDate><guid>https://whileydave.com/downloads/tuttev0.9.3/</guid><description/></item><item><title>Version 0.9.4</title><link>https://whileydave.com/downloads/tuttev0.9.4/</link><pubDate>Wed, 01 Aug 2007 00:00:00 +0000</pubDate><guid>https://whileydave.com/downloads/tuttev0.9.4/</guid><description/></item><item><title>Version 0.9.5</title><link>https://whileydave.com/downloads/tuttev0.9.5/</link><pubDate>Wed, 01 Aug 2007 00:00:00 +0000</pubDate><guid>https://whileydave.com/downloads/tuttev0.9.5/</guid><description/></item><item><title>Version 0.9.6</title><link>https://whileydave.com/downloads/tuttev0.9.6/</link><pubDate>Wed, 01 Aug 2007 00:00:00 +0000</pubDate><guid>https://whileydave.com/downloads/tuttev0.9.6/</guid><description/></item><item><title>Version 0.9.1</title><link>https://whileydave.com/downloads/tuttev0.9.1/</link><pubDate>Fri, 01 Jun 2007 00:00:00 +0000</pubDate><guid>https://whileydave.com/downloads/tuttev0.9.1/</guid><description/></item><item><title>A Dynamic Topological Sort Algorithm for Directed Acyclic Graphs</title><link>https://whileydave.com/publications/pk07_jea/</link><pubDate>Mon, 01 Jan 2007 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/pk07_jea/</guid><description>Abstract. We consider the problem of maintaining the topological order of a directed acyclic graph (DAG) in the presence of edge insertions and deletions. We present a new algorithm and, although this has inferior time complexity compared with the best previously known result, we find that its simplicity leads to better performance in practice.</description></item><item><title>Efficient Field-Sensitive Pointer Analysis for C</title><link>https://whileydave.com/publications/pkh07_toplas/</link><pubDate>Mon, 01 Jan 2007 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/pkh07_toplas/</guid><description>Abstract. The subject of this paper is flow- and context-insensitive pointer analysis. We present a novel approach for precisely modelling struct variables and indirect function calls. Our method em- phasises efficiency and simplicity and is based on a simple language of set constraints.</description></item><item><title>Patterns of Aspect-Oriented Design</title><link>https://whileydave.com/publications/nspb07_europlop/</link><pubDate>Mon, 01 Jan 2007 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/nspb07_europlop/</guid><description>Abstract: Aspect-oriented programming languages are becoming commonplace, and programmers are accumulating experience in building and maintaining aspect-oriented systems. This paper addresses how the use of these languages affects program design: how aspect-oriented languages change the design space, which designs should be emulated and which avoided, and the strengths and weaknesses of particular kinds of design.</description></item><item><title>Profiling with AspectJ</title><link>https://whileydave.com/publications/pwbk07_spe/</link><pubDate>Mon, 01 Jan 2007 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/pwbk07_spe/</guid><description>Abstract. This paper investigates whether AspectJ can be used for efficient profiling of Java programs. Profiling differs from other applications of AOP (e.g. tracing), since it necessitates efficient and often complex interactions with the target program.</description></item><item><title>Visualising the Tutte Polynomial Computation</title><link>https://whileydave.com/publications/tph07_sienz/</link><pubDate>Mon, 01 Jan 2007 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/tph07_sienz/</guid><description>Abstract: The Tutte polynomial is an important concept in graph theory which captures many important properties of graphs (e.g. chromatic number, number of spanning trees etc). It also provides a normalised representation that can be used as an equivalence relation on graphs and has applications in diverse areas such micro-biology and physics.</description></item><item><title>AspectJ for Multilevel Security</title><link>https://whileydave.com/publications/rpw06_acp4is/</link><pubDate>Sun, 01 Jan 2006 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/rpw06_acp4is/</guid><description>Abstract: A multilevel security (MLS) system has two primary goals: first, it is intended to prevent unauthorised personnel from accessing information at higher classification than their authorisation. Second, it is intended to prevent personnel from declassifying information.</description></item><item><title>Efficient Object Querying for Java</title><link>https://whileydave.com/publications/wpn06_ecoop/</link><pubDate>Sun, 01 Jan 2006 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/wpn06_ecoop/</guid><description>Abstract: Modern programming languages have little or no support for querying objects and collections. Programmers are forced to hand code such queries using nested loops, which is both cumbersome and inefficient.</description></item><item><title>Relationship Aspect Patterns</title><link>https://whileydave.com/publications/pn06_europlop/</link><pubDate>Sun, 01 Jan 2006 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/pn06_europlop/</guid><description>Abstract: Relationships between objects are almost as important to designs as the objects themselves. Most programming languages do not support relationships well, so programmers must implement relationships in terms of more primitive constructs.</description></item><item><title>Relationship Aspects</title><link>https://whileydave.com/publications/pn06_aosd/</link><pubDate>Sun, 01 Jan 2006 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/pn06_aosd/</guid><description>Abstract: The relationships between objects in object-oriented programs are as important as the objects themselves. Unfortunately, most object-oriented programming languages provide little support for such relationships, leaving the task of implementing them entirely to the programmer.</description></item><item><title>Towards a Semiotics of Object- and Aspect-Oriented Design</title><link>https://whileydave.com/publications/nbtp06_ecap/</link><pubDate>Sun, 01 Jan 2006 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/nbtp06_ecap/</guid><description>Abstract: Object-oriented design is based on the argument that objects in a program act as a simulation of objects in the real world. This paper will provide a semiotic account of object-oriented design patterns, treating an object as a sign comprised of some part of the real world, its realisation in the program, and the programmers intent about the program design (that the object model the world).</description></item><item><title>Tutte Polynomials</title><link>https://whileydave.com/projects/tutte/</link><pubDate>Sun, 01 Jan 2006 00:00:00 +0000</pubDate><guid>https://whileydave.com/projects/tutte/</guid><description>Overview. Tutte polynomials play an important role in graph theory, combinatorics, matroid theory, knot theory, and experimental physics. For example, the polynomials can be evaluated to find the number of spanning trees in a graph, the number of forests in a graph, the number of connected spanning subgraphs, the number of spanning subgraphs, and the number of acyclic orientations.</description></item><item><title>Some directed graph algorithms and their application to pointer analysis.</title><link>https://whileydave.com/publications/pearce05_phd/</link><pubDate>Sat, 01 Jan 2005 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/pearce05_phd/</guid><description>Abstract: This thesis is focused on improving execution time and precision of scalable pointer analysis. Such an analysis statically determines the targets of all pointer variables in a program. We formulate the analysis as a directed graph problem, where the solution can be obtained by a computation similar, in many ways, to transitive closure.</description></item><item><title>A Dynamic Algorithm for Topologically Sorting Directed Acyclic Graphs</title><link>https://whileydave.com/publications/pk04_wea/</link><pubDate>Thu, 01 Jan 2004 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/pk04_wea/</guid><description>Abstract: We consider how to maintain the topological order of a directed acyclic graph (DAG) in the presence of edge insertions and deletions. We present a new algorithm and, although this has marginally inferior time complexity compared with the best previously known result, we find that its simplicity leads to better performance in practice.</description></item><item><title>Automating Optimized Table-with-Polynomial Function Evaluation for FPGAs</title><link>https://whileydave.com/publications/lmpl04_fpl/</link><pubDate>Thu, 01 Jan 2004 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/lmpl04_fpl/</guid><description>Abstract: Function evaluation is at the core of many compute-intensive applications which perform well on reconfigurable platforms. Yet, in order to implement function evaluation efficiently, the FPGA programmer has to choose between a multitude of function evaluation methods such as table lookup, polynomial approximation, or table lookup combined with polynomial approximation.</description></item><item><title>Dynamic Topological Sort</title><link>https://whileydave.com/projects/dts/</link><pubDate>Thu, 01 Jan 2004 00:00:00 +0000</pubDate><guid>https://whileydave.com/projects/dts/</guid><description>The problem of topologically sorting a directed graph is about arranging its nodes so that all edges go in the same direction. For example, consider the following directed graph:
A topological sort of this graph is:</description></item><item><title>Efficient Field-Sensitive Pointer Analysis for C</title><link>https://whileydave.com/publications/pkh04_paste/</link><pubDate>Thu, 01 Jan 2004 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/pkh04_paste/</guid><description>Abstract: The subject of this paper is flow- and context-insensitive pointer analysis. We present a novel approach for precisely modelling struct variables and indirect function calls. Our method emphasises efficiency and simplicity and extends the language of set-constraints.</description></item><item><title>Online Cycle Detection and Difference Propagation: Applications to Pointer Analysis</title><link>https://whileydave.com/publications/pkh04_sqj/</link><pubDate>Thu, 01 Jan 2004 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/pkh04_sqj/</guid><description>Abstract. This paper presents and evaluates a number of techniques to improve the execution time of interprocedural pointer analysis in the context of C programs. The analysis is formulated as a graph of set constraintsand solved using a worklist algorithm.</description></item><item><title>Design Space Exploration with A Stream Compiler</title><link>https://whileydave.com/publications/mphl03_fpt/</link><pubDate>Wed, 01 Jan 2003 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/mphl03_fpt/</guid><description>Abstract: We consider speeding up general-purpose applications with hardware accelerators. Traditionally hardware accelera- tors are tediously hand-crafted to achieve top performance. ASC (A Stream Compiler) simplifies exploration of hard- ware accelerators by transforming the hardware design task into a software design process using only ’gcc’ and ’make’ to obtain a hardware netlist.</description></item><item><title>DJProf</title><link>https://whileydave.com/projects/djprof/</link><pubDate>Wed, 01 Jan 2003 00:00:00 +0000</pubDate><guid>https://whileydave.com/projects/djprof/</guid><description>DJProf is an experimental Java profiling tool which employs AspectJ to insert the necessary instrumentation for profiling rather than, for example, the Java Machine Profiler Interface (JVMPI). DJProf can be used to profile Java programs without modification (i.</description></item><item><title>Online Cycle Detection and Difference Propagation for Pointer Analysis</title><link>https://whileydave.com/publications/pkh03_scam/</link><pubDate>Wed, 01 Jan 2003 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/pkh03_scam/</guid><description>Abstract. This paper presents and evaluates a number of techniques to improve the execution time of interprocedural pointer analysis in the context of large C programs. The analysis is formulated as a graph of set constraints and solved using a worklist algorithm.</description></item><item><title>GILK: A Dynamic Instrumentation Tool for the Linux Kernel</title><link>https://whileydave.com/publications/pkfh02_tools/</link><pubDate>Tue, 01 Jan 2002 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/pkfh02_tools/</guid><description>Abstract: This paper desribes a dynamic instrumentation tool for the Linux Kernal which allows a stock Linux kernel to be modified while in execution, with instruments implemented as kernel modules. The Intel x86 architecture poses a particular problem, due to variable length instructions, which this paper addresses for the first time.</description></item><item><title>GILK</title><link>https://whileydave.com/projects/gilk/</link><pubDate>Sat, 01 Jan 2000 00:00:00 +0000</pubDate><guid>https://whileydave.com/projects/gilk/</guid><description>The GILK project was part of my master&amp;rsquo;s thesis at Imperial College London. The project is all about dynamic instrumentation of the Linux Kernel. This means that a stock (i.e. without any source code modification) kernel can be instrumented whilst in execution!</description></item><item><title>Instrumenting the Linux Kernel</title><link>https://whileydave.com/publications/pearce00_meng/</link><pubDate>Sat, 01 Jan 2000 00:00:00 +0000</pubDate><guid>https://whileydave.com/publications/pearce00_meng/</guid><description>Abstract: An instrumentation tool has been developed for the Linux kernel that uses the relatively new technique of runtime code splicing. This permits instrumentation of a running system, without any source code modification, by redirecting the flow of control to pass through carefully written code patches.</description></item></channel></rss>