<!doctype html><html lang=en><head><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta property="og:title" content="Formalising the Ethereum Virtual Machine in Dafny"><meta name=twitter:title content="Formalising the Ethereum Virtual Machine in Dafny"><meta property="og:url" content="https://whileydave.com/2023/02/06/formalising-the-ethereum-virtual-machine-in-dafny/"><title>David J. Pearce
(Formalising the Ethereum Virtual Machine in Dafny)</title><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css><link rel=stylesheet href=https://whileydave.com/css/page.css><link rel=stylesheet href=https://whileydave.com/css/menu.css><link rel=stylesheet href=https://whileydave.com/css/style.css><link rel=stylesheet href=https://whileydave.com/css/syntax.css></head><body><script>"use strict";function clearMenu(){var e,t,n=window.matchMedia("(max-width: 992px)");n.matches&&(e=document.getElementById("menu-content"),t=document.getElementById("menu"),e.style.display="none",t.style.filter="")}function toggleMenu(){var e,t,n=window.matchMedia("(max-width: 992px)");n.matches&&(e=document.getElementById("menu-content"),t=document.getElementById("menu"),e.style.display==="block"?(e.style.display="none",t.style.filter=""):(e.style.display="block",t.style.filter="brightness(0.8)"))}function toggleList(e){e.style.display="none";for(var t,o=e.parentNode,s=o.childNodes,n=0;n<s.length;++n)t=s[n],t.classList&&t.classList.contains("hidden")&&(t.style.display==="block"?t.style.display="none":t.style.display="block")}</script><header class=topbar><div class=topbar-header onclick=clearMenu()><div class=topbar-title>Dr. David J. Pearce</div><div class=topbar-subtitle></div></div><div class=topbar-social onclick=clearMenu()><a href=https://github.com/DavePearce><i class="fa fa-github" aria-hidden=true></i></a>
<a href=https://twitter.com/WhileyDave><i class="fa fa-twitter" aria-hidden=true></i></a>
<a href=https://www.youtube.com/user/redjamjar/><i class="fa fa-youtube-play" aria-hidden=true></i></a>
<a href=https://www.linkedin.com/in/david-pearce-8592647/><i class="fa fa-linkedin-square" aria-hidden=true></i></a></div><div class=topbar-menu><div id=menu onclick=toggleMenu()><div id=menu-icon><img src=https://whileydave.com/images/menu.png alt=Menu></div><div id=menu-content><a href=https://whileydave.com/blog/>Blog</a>
<a href=https://whileydave.com/projects/>Projects</a>
<a href=https://whileydave.com/publications/>Publications</a>
<a href=https://whileydave.com/talks/>Talks</a>
<a href=https://whileydave.com/>Home</a></div></div></div></header><div class=container onclick=clearMenu()><div class=content><h1 class=post-title>Formalising the Ethereum Virtual Machine in Dafny</h1><div class=post-date>Monday, February
6th,
2023</div><hr><p>Since starting at <a href=https://consensys.net/>ConsenSys</a>, the main project I have been involved with is a <a href=https://github.com/ConsenSys/evm-dafny>formalisation of the Ethereum Virtual Machine in Dafny</a> called the &ldquo;DafnyEVM&rdquo;. Our goals share some similarity with Runtime Verification&rsquo;s <a href=https://github.com/runtimeverification/evm-semantics>KEVM</a> project. We want a formal semantics of the EVM which is executable so that, for example, we can test it against the <a href=https://github.com/ethereum/tests>Ethereum common tests</a>. Using Dafny, however, offers some advantages over the <a href=https://kframework.org/>K framework</a>:</p><ul><li><p><strong>(Verification)</strong> With Dafny, we can verify security properties
over EVM bytecode directly. For example, we can verify simple
properties (e.g. no arithmetic overflow/underflow) as well as
more complex properties (e.g. that an invariant between fields of
the contract always holds).</p></li><li><p><strong>(Documentation)</strong> Our Dafny formalisation gives a concise and
readable description of the Ethereum Virtual Machine. In my
opinion, it compares well against the <a href=https://ethereum.github.io/yellowpaper/paper.pdf>Yellow
Paper</a> and the
official <a href=https://github.com/ethereum/execution-specs>Python
spec</a> (with the
caveat that the DafnyEVM remains a work-in-progress).</p></li><li><p><strong>(Compilation)</strong> In principle, we could develop a compiler for a
high-level language using the DafnyEVM which guarantees that
generated bytecode is correct. A good example of this is the
<a href=https://en.wikipedia.org/wiki/CompCert>CompCert</a> compiler
developed for the C language.</p></li></ul><p>Whilst the DafnyEVM remains a work-in-progress, it can already pass a
large number of the <a href=https://github.com/ethereum/tests>Ethereum common
tests</a>. So, let&rsquo;s take a look
inside!</p><h2 id=machine-state>Machine State</h2><p>An executing EVM contains various key components of the executing
state such as <em>gas</em>, <em>pc</em>, <em>stack</em>, <em>code</em>, <em>memory</em>, and
<em>worldstate</em>. Roughly speaking, we implement this in Dafny like so:</p><pre tabindex=0><code class=language-dafny data-lang=dafny>datatype ExecutingEvm = EVM(
  gas: nat, 
  pc: nat, 
  stack: Stack, 
  code: Code,
  mem: Memory, 
  world: WorldState, 
  ...
)
</code></pre><p>On top of this, we have a notion of the <em>machine state</em> which maybe an
executing EVM (as above), or a terminated EVM (e.g. having executed a
<code>RETURN</code> or <code>REVERT</code> instruction, or failed with some kind of error):</p><pre tabindex=0><code class=language-dafny data-lang=dafny>datatype State = OK(evm: ExecutingEvm) 
   | REVERTS(gas:nat, data:seq&lt;u8&gt;)
   | RETURNS(gas:nat, data:seq&lt;u8&gt;, ...) 
   | INVALID(Error) 
   | ...
</code></pre><p>Here, the <code>REVERTS</code> and <code>RETURNS</code> states include their <code>RETURNDATA</code> as
a sequence of bytes (i.e. <code>u8</code>) along with any <code>gas</code> returned to the
caller. To simplify our code, we can define a new type which captures
the notion of an <em>executing EVM</em> as follows:</p><pre tabindex=0><code class=language-Dafny data-lang=Dafny>type ExecutingState = st:State | st.OK?
</code></pre><p>Variables of type <code>ExecutingState</code> have type <code>State</code> with the
additional constraint that they are instances of <code>State.OK</code>.</p><h2 id=bytecode-semantics>Bytecode Semantics</h2><p>There are over 140 bytecode instructions supported in the Ethereum
Virtual Machine. These include simple arithmetic operations, memory
reading/writing, storage reading/writing, contract calls, etc. The
<a href=https://en.wikipedia.org/wiki/Semantics_%28computer_science%29>semantics</a>
(i.e. meaning) of every instruction is formalised in the DafnyEVM.</p><p>As a first example, here is our formalisation of the <code>ADD</code> instruction
(opcode <code>0x01</code>):</p><pre tabindex=0><code class=language-dafny data-lang=dafny>function Add(st: ExecutingState): (st&#39;: State) 
{
    if st.Operands() &gt;= 2
    then
        var lhs := st.Peek(0) as int;
        var rhs := st.Peek(1) as int;
        var res := (lhs + rhs) % TWO_256;
        st.Pop().Pop().Push(res as u256).Next()
    else
        State.INVALID(STACK_UNDERFLOW)
}
</code></pre><p>This function takes an executing EVM state, and produces an updated
state (which may or may not be still executing). The function
requires at least two operands on the stack, otherwise execution halts
with a stack underflow exception. Furthermore, the <code>lhs</code>
(i.e. left-hand side) is at offset <code>0</code> from the top of the stack,
whilst the <code>rhs</code> is at offset <code>1</code>. The two operands are then added
together modulo <code>TWO_256</code> to ensure the result fits into a <code>u256</code>.
Thus, we can see from this that the EVM does not automatically catch
arithmetic overflow for us.</p><p>As a second example, consider the semantics given for the <code>MLOAD</code>
instruction (i.e. opcode <code>0x51</code>):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl><span class=kd>function</span> <span class=n>MLoad</span><span class=p>(</span><span class=n>st</span><span class=o>:</span> <span class=n>ExecutingState</span><span class=p>)</span><span class=o>:</span> <span class=p>(</span><span class=n>st</span><span class=err>&#39;</span><span class=o>:</span> <span class=n>State</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=k>if</span> <span class=n>st</span><span class=p>.</span><span class=n>Operands</span><span class=p>()</span> <span class=o>&gt;=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>   <span class=n>then</span>
</span></span><span class=line><span class=cl>      <span class=n>var</span> <span class=n>loc</span> <span class=o>:=</span> <span class=n>st</span><span class=p>.</span><span class=n>Peek</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=n>as</span> <span class=n>nat</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=c1>// Expand memory as necessary
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=n>var</span> <span class=n>nst</span> <span class=o>:=</span> <span class=n>st</span><span class=p>.</span><span class=n>Expand</span><span class=p>(</span><span class=n>loc</span><span class=p>,</span><span class=mi>32</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=c1>// Read from expanded state
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=n>nst</span><span class=p>.</span><span class=n>Pop</span><span class=p>().</span><span class=n>Push</span><span class=p>(</span><span class=n>nst</span><span class=p>.</span><span class=n>Read</span><span class=p>(</span><span class=n>loc</span><span class=p>)).</span><span class=n>Next</span><span class=p>()</span>
</span></span><span class=line><span class=cl>   <span class=k>else</span>
</span></span><span class=line><span class=cl>      <span class=n>State</span><span class=p>.</span><span class=n>INVALID</span><span class=p>(</span><span class=n>STACK_UNDERFLOW</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>In this case, only one operand on the stack is required (i.e. the
address in memory to load from). The purpose of the <code>Expand(loc,32)</code>
is to ensure sufficient memory to store a <code>u256</code> word at address
<code>loc</code>. This also illustrates some benefits from using a language like
Dafny. The <code>Read</code> function is defined like so:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl><span class=kd>function</span> <span class=kd>method</span> <span class=n>Read</span><span class=p>(</span><span class=n>address</span><span class=o>:</span><span class=n>nat</span><span class=p>)</span> <span class=o>:</span> <span class=n>u256</span>
</span></span><span class=line><span class=cl><span class=k>requires</span> <span class=n>address</span> <span class=o>+</span> <span class=mi>31</span> <span class=o>&lt;</span> <span class=n>Memory</span><span class=p>.</span><span class=n>Size</span><span class=p>(</span><span class=n>evm</span><span class=p>.</span><span class=n>memory</span><span class=p>)</span> <span class=p>{</span> 
</span></span><span class=line><span class=cl>  <span class=p>...</span> 
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Thus, if the <code>Expand(loc,32)</code> call above were omitted or specified
incorrectly (e.g. as <code>Expand(loc,31)</code>) then Dafny would flag an error
for us at compile time. Of course, <code>Read()</code> could automatically
expand memory for us &mdash; but, making explicit the places where memory
expansion can occur helps ensure expansion is done correctly.</p><h2 id=verification-example>Verification Example</h2><p>Using the DafnyEVM we can prove properties of interest on bytecode
sequences. An example proof is the following:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl><span class=kd>method</span> <span class=n>AddBytes</span><span class=p>(</span><span class=n>x</span><span class=o>:</span> <span class=n>u8</span><span class=p>,</span> <span class=n>y</span><span class=o>:</span> <span class=n>u8</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// Initialise an EVM.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>var</span> <span class=n>st</span> <span class=o>:=</span> <span class=n>InitEmpty</span><span class=p>(</span><span class=n>gas</span><span class=o>:=</span><span class=mi>1000</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=c1>// Execute three bytecodes
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>st</span> <span class=o>:=</span> <span class=n>Push1</span><span class=p>(</span><span class=n>x</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>st</span> <span class=o>:=</span> <span class=n>Push1</span><span class=p>(</span><span class=n>y</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>st</span> <span class=o>:=</span> <span class=n>Add</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=c1>// Check top of stack is sum of x and y
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>assert</span> <span class=n>st</span><span class=p>.</span><span class=n>Peek</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>==</span> <span class=p>(</span><span class=n>x</span> <span class=n>as</span> <span class=n>u256</span><span class=p>)</span> <span class=o>+</span> <span class=p>(</span><span class=n>y</span> <span class=n>as</span> <span class=n>u256</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This proof roughly states that: <em>for any two byte values <code>x</code> and <code>y</code>
on the stack, <code>ADD</code> returns their sum</em>. Observe that, since <code>x</code> and
<code>y</code> are bytes, overflow is not possible and Dafny recognises this. If
<code>x</code> and <code>y</code> had type <code>u256</code> then Dafny would flag the potential
arithmetic overflow for us at compile time.</p><p>As a second (and more interesting) example, let&rsquo;s consider a more
complete contract:</p><pre tabindex=0><code class=language-Dafny data-lang=Dafny>// Load counter on stack
PUSH1 0x0
SLOAD
// Increment by one
PUSH 0x1
ADD 
// Check for overflow
DUP1
PUSH1 0xf
JUMPI
// Overflow, so revert
PUSH1 0x0
PUSH1 0x0
REVERT,
// No overflow (0xf) 
JUMPDEST
// Write back
PUSH 0x0
SSTORE
// Done
STOP
</code></pre><p>This contract maintains a counter at storage location <code>0</code> which is
incremented by one on every contract call. The contract should revert
if an overflow occurs. Thus, we should be able to prove that whenever
the contract is called: (i) either the counter is incremented; or
(ii), the contract reverts. Using the DafnyEVM, the proof of this
looks (roughly speaking) as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Whiley data-lang=Whiley><span class=line><span class=cl><span class=kd>method</span> <span class=n>IncProof</span><span class=p>(</span><span class=n>st</span><span class=o>:</span> <span class=n>ExecutingState</span><span class=p>)</span> <span class=n>returns</span> <span class=p>(</span><span class=n>st</span><span class=err>&#39;</span><span class=o>:</span> <span class=n>State</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>// Initial state has PC == 0 and an empty stack
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>requires</span> <span class=n>st</span><span class=p>.</span><span class=n>PC</span><span class=p>()</span> <span class=o>==</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=n>st</span><span class=p>.</span><span class=n>Operands</span><span class=p>()</span> <span class=o>==</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=c1>// Assume there is enough gas
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>requires</span> <span class=n>st</span><span class=p>.</span><span class=n>Gas</span><span class=p>()</span> <span class=o>&gt;=</span> <span class=mi>40000</span>
</span></span><span class=line><span class=cl><span class=c1>// Success guaranteed if can increment counter
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>ensures</span> <span class=n>st</span><span class=err>&#39;</span><span class=p>.</span><span class=n>RETURNS</span><span class=o>?</span> <span class=o>&lt;==&gt;</span> <span class=p>(</span><span class=n>st</span><span class=p>.</span><span class=n>Load</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=n>as</span> <span class=n>nat</span><span class=p>)</span> <span class=o>&lt;</span> <span class=n>MAX_U256</span>
</span></span><span class=line><span class=cl><span class=c1>// If success, counter incremented
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>ensures</span> <span class=n>st</span><span class=err>&#39;</span><span class=p>.</span><span class=n>RETURNS</span><span class=o>?</span> <span class=o>==&gt;</span> <span class=n>st</span><span class=err>&#39;</span><span class=p>.</span><span class=n>Load</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>==</span> <span class=p>(</span><span class=n>st</span><span class=p>.</span><span class=n>Load</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>var</span> <span class=n>nst</span> <span class=o>:=</span> <span class=n>st</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=c1>// Load counter
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>nst</span> <span class=o>:=</span> <span class=n>Push1</span><span class=p>(</span><span class=n>nst</span><span class=p>,</span><span class=mh>0x0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>nst</span> <span class=o>:=</span> <span class=n>SLoad</span><span class=p>(</span><span class=n>nst</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=c1>// Increment it by one
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>nst</span> <span class=o>:=</span> <span class=n>Push1</span><span class=p>(</span><span class=n>nst</span><span class=p>,</span><span class=mh>0x1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>nst</span> <span class=o>:=</span> <span class=n>Add</span><span class=p>(</span><span class=n>nst</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=c1>// Check for overflow
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>nst</span> <span class=o>:=</span> <span class=n>Dup</span><span class=p>(</span><span class=n>nst</span><span class=p>,</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>nst</span> <span class=o>:=</span> <span class=n>Push1</span><span class=p>(</span><span class=n>nst</span><span class=p>,</span><span class=mh>0xf</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>nst</span> <span class=o>:=</span> <span class=n>JumpI</span><span class=p>(</span><span class=n>nst</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=c1>// Case analysis on outcome
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=n>nst</span><span class=p>.</span><span class=n>Peek</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Overflow occurred
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>assert</span> <span class=n>nst</span><span class=p>.</span><span class=n>PC</span><span class=p>()</span> <span class=o>==</span> <span class=mh>0xa</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>nst</span> <span class=o>:=</span> <span class=n>Push1</span><span class=p>(</span><span class=n>nst</span><span class=p>,</span><span class=mh>0x0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>nst</span> <span class=o>:=</span> <span class=n>Push1</span><span class=p>(</span><span class=n>nst</span><span class=p>,</span><span class=mh>0x0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>nst</span> <span class=o>:=</span> <span class=n>Revert</span><span class=p>(</span><span class=n>nst</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>assert</span> <span class=n>nst</span><span class=p>.</span><span class=n>REVERTS</span><span class=o>?</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// No overflow!
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>assert</span> <span class=n>nst</span><span class=p>.</span><span class=n>PC</span><span class=p>()</span> <span class=o>==</span> <span class=mh>0xf</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>nst</span> <span class=o>:=</span> <span class=n>JumpDest</span><span class=p>(</span><span class=n>nst</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Write back
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>nst</span> <span class=o>:=</span> <span class=n>Push1</span><span class=p>(</span><span class=n>nst</span><span class=p>,</span><span class=mh>0x0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>nst</span> <span class=o>:=</span> <span class=n>SStore</span><span class=p>(</span><span class=n>nst</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>nst</span> <span class=o>:=</span> <span class=n>Stop</span><span class=p>(</span><span class=n>nst</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>assert</span> <span class=n>nst</span><span class=p>.</span><span class=n>RETURNS</span><span class=o>?</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>nst</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The proof is quite long, but it essentially follows the control-flow
of the original contract. The nice thing is we can reuse Dafny
language constructs (e.g. <code>if</code> and <code>assert</code>) to help manage the proof.
More importantly, Dafny checks at compile time that the various
<code>assert</code> statements and <code>ensures</code> clauses are <em>always</em> true (i.e. that
they hold <em>for all possible inputs which meet the <code>requires</code>
conditions</em>).</p><h2 id=conclusion>Conclusion</h2><p>The DafnyEVM represents an interesting formalisation of the Ethereum
Virtual Machine. This allows us to show strong correctness properties
for arbitrary bytecode sequences. Whilst its not yet finished, it is
certainly showing promise. However, a key challenge lies in scaling
up the proofs to handle larger real-world contracts (and that is
something I will talk more about in the future).</p><hr></div></div><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-5582165-7","auto"),ga("send","pageview"))</script></body></html>