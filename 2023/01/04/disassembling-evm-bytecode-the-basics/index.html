<!doctype html><html lang=en><head><script async src="https://www.googletagmanager.com/gtag/js?id=G-9MRLB1FVZX"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-9MRLB1FVZX",{anonymize_ip:!1})}</script><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta property="og:title" content="Disassembling EVM Bytecode (the Basics)"><meta name=twitter:title content="Disassembling EVM Bytecode (the Basics)"><meta property="og:description" content="Disassembling EVM bytecode using dataflow analysis is an interesting challenge."><meta name=twitter:description content="Disassembling EVM bytecode using dataflow analysis is an interesting challenge."><meta property="og:image" content="https://whileydave.com/images/2022/DecompilingEvm_Preview.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://whileydave.com/images/2022/DecompilingEvm_Preview.png"><meta property="og:url" content="https://whileydave.com/2023/01/04/disassembling-evm-bytecode-the-basics/"><title>David J. Pearce
(Disassembling EVM Bytecode (the Basics))</title><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css><link rel=stylesheet href=https://whileydave.com/css/page.css><link rel=stylesheet href=https://whileydave.com/css/menu.css><link rel=stylesheet href=https://whileydave.com/css/style.css><link rel=stylesheet href=https://whileydave.com/css/syntax.css></head><body><script>"use strict";function clearMenu(){var e,t,n=window.matchMedia("(max-width: 992px)");n.matches&&(e=document.getElementById("menu-content"),t=document.getElementById("menu"),e.style.display="none",t.style.filter="")}function toggleMenu(){var e,t,n=window.matchMedia("(max-width: 992px)");n.matches&&(e=document.getElementById("menu-content"),t=document.getElementById("menu"),e.style.display==="block"?(e.style.display="none",t.style.filter=""):(e.style.display="block",t.style.filter="brightness(0.8)"))}function toggleList(e){e.style.display="none";for(var t,o=e.parentNode,s=o.childNodes,n=0;n<s.length;++n)t=s[n],t.classList&&t.classList.contains("hidden")&&(t.style.display==="block"?t.style.display="none":t.style.display="block")}</script><header class=topbar><div class=topbar-header onclick=clearMenu()><div class=topbar-title>Dr. David J. Pearce</div><div class=topbar-subtitle></div></div><div class=topbar-social onclick=clearMenu()><a href=https://github.com/DavePearce><i class="fa fa-github" aria-hidden=true></i></a>
<a href=https://twitter.com/WhileyDave><i class="fa fa-twitter" aria-hidden=true></i></a>
<a href=https://www.youtube.com/user/redjamjar/><i class="fa fa-youtube-play" aria-hidden=true></i></a>
<a href=https://www.linkedin.com/in/david-pearce-8592647/><i class="fa fa-linkedin-square" aria-hidden=true></i></a></div><div class=topbar-menu><div id=menu onclick=toggleMenu()><div id=menu-icon><img src=https://whileydave.com/images/menu.png alt=Menu></div><div id=menu-content><a href=https://whileydave.com/blog/>Blog</a>
<a href=https://whileydave.com/projects/>Projects</a>
<a href=https://whileydave.com/publications/>Publications</a>
<a href=https://whileydave.com/talks/>Talks</a>
<a href=https://whileydave.com/>Home</a></div></div></div></header><div class=container onclick=clearMenu()><div class=content><h1 class=post-title>Disassembling EVM Bytecode (the Basics)</h1><div class=post-date>Wednesday, January
4th,
2023</div><hr><p>Recently, I&rsquo;ve been looking at how to disassemble (and eventually
decompile) bytecode for the <a href=https://ethereum.org/en/developers/docs/evm/>Ethereum Virtual Machine
(EVM)</a>. This is an
interesting computer science problem which I&rsquo;ve been thinking about
lately. My goal is just to explain the problem and outline a simple
solution.</p><h2 id=background>Background</h2><p>The EVM is a stack-based <a href=https://en.wikipedia.org/wiki/Virtual_machine>virtual
machine</a> which supports <em>volatile</em> and <em>non-volatile</em>
storage. The volatile storage is called <em>memory</em> and exists only for
the life of a transaction. In contrast, the non-volatile storage is
just called <em>storage</em> and persists between transactions.</p><p>Whilst instructions in the EVM are variable length, the vast majority
are only one byte in length. The family of push instructions
(e.g. <code>PUSH1</code>, <code>PUSH2</code>, etc) are the only instructions which have
operands. These simply push a 256bit word constructed from their
operand on the stack. For example, the <code>PUSH1</code> instruction accepts a
one byte operand which is converted into a 256bit word by treating the
operands as the low byte.</p><p>There are a lot of details about the EVM which I&rsquo;m going to ignore
here. But, of relevance, is the fact that all branches (conditional
or unconditional) are <em>indirect</em> as the branch destination is
loaded from the stack. For example, if we wanted to perform an
unconditional jump to location <code>0x1a</code> then we can write this:</p><pre tabindex=0><code>    PUSH1 0x1a
    JUMP
</code></pre><p>In this case, the jump destination can be determined by looking at the
previous instruction. But, in general, it could have been loaded onto
the stack at any time in the past. For example, this is a simple
variation on the above:</p><pre tabindex=0><code>    PUSH1 0x1a
    PUSH1 0x80
    SLOAD
    SWAP1
    JUMP
</code></pre><p>This first loads <code>0x1a</code> onto the stack, then <code>0x80</code>. The <code>SLOAD</code>
instruction loads a word from storage at the address given on top of
the stack (<code>0x80</code>). To execute this instruction, the machine pops the
address and pushes the new word from storage. Say <code>0xff</code> was
currently stored at <code>0x80</code>, then after the <code>SLOAD</code> the stack is
<code>[0x1a,0xff]</code> (right-most element is top). The <code>SWAP1</code> operation
swaps the top two stack items, so after executing this operation the
stack is <code>[0xff,0x1a]</code>. Finally, as before, we perform an
unconditional branch to location <code>0x1a</code>.</p><h3 id=the-problem>The Problem</h3><p>Performing an initial disassembly of the code is actually pretty
straightforward. We can do a linear scan of the bytecode translating
bytes (and operands where appropriate) into instructions. This gives
us a first draft which maybe sufficient. But it lacks information
which, in some cases, maybe important:</p><ul><li><p><strong>(Data vs Code)</strong>. As well as executable instructions, EVM
bytecode can contain data. This is often used for the contract
creation process (where the code of the contract being created is
stored as data), but can be used for other reasons.</p></li><li><p><strong>(Control-Flow)</strong>. Understanding the possible flow of control
through the program can be important for some applications.</p></li><li><p><strong>(Stack Height)</strong>. Some applications need to know the stack
height at certain points within the program.</p></li></ul><p>A linear scan of bytecodes does not reveal this information. For
example, it does not tell us which bytes represent actual code to
execute, versus which represent data. Likewise, it does not tell us
where a given branch might jump to. Furthermore, whilst a linear scan
can be extended to capture some of this, we really need something more
sophisticated to get reliable information.</p><h2 id=analysis-overview>Analysis Overview</h2><p>A simple and effective solution for disassembling EVM bytecode is to
use a <a href=https://en.wikipedia.org/wiki/Data-flow_analysis>data-flow
analysis</a>. Whilst such analyses can be quite complex, even
a relatively simple dataflow analysis (such as described here) is
enough for many programs.</p><p>The basic idea is to simulate execution of the bytecode using a
simplified model of the machine. In fact, we&rsquo;re just going to model
the machine stack here and ignore memory/storage. More sophisticated
analyses may want to model memory in particular (as this can reveal
useful information). Our model of the machine stack is called an
<em>abstract stack</em> (i.e. since it abstracts away information). Our
abstract stack will contain <em>concrete values</em> (when possible) and
<em>unknown values</em> (otherwise). Consider our program from above
annotated with the state of the abstract stack <em>before</em> each
instruction:</p><center><table><thead><tr><th style=text-align:left>Bytecode</th><th style=text-align:left>Abstract Stack</th></tr></thead><tbody><tr><td style=text-align:left><code>PUSH1 0x1a</code></td><td style=text-align:left><code>[]</code></td></tr><tr><td style=text-align:left><code>PUSH1 0x80</code></td><td style=text-align:left><code>[0x1a]</code></td></tr><tr><td style=text-align:left><code>SLOAD</code></td><td style=text-align:left><code>[0x1a,0x80]</code></td></tr><tr><td style=text-align:left><code>SWAP1</code></td><td style=text-align:left><code>[0x1a,????]</code></td></tr><tr><td style=text-align:left><code>JUMP</code></td><td style=text-align:left><code>[????,0x1a]</code></td></tr></tbody></table></center><p>Here <code>0x1a</code> and <code>0x80</code> are concrete values extracted from the <code>PUSH1</code>
operands, whilst <code>????</code> represents an unknown value. Since we are
<em>simulating</em> bytecode execution (i.e. rather than <em>actually</em> executing
it), we don&rsquo;t know what value <code>SLOAD</code> will push on the stack. To
capture this safely, we <em>abstract</em> it with an unknown value that
represents <em>any possible value</em>.</p><p>The above example illustrates the main idea. Whilst our abstract
stack contains unknown values, it also contains known values. By
simulating how instructions manipulate the stack we can determine the
concrete destinations of branching instructions. For example, in the
above, the analysis tells us that the <code>JUMP</code> will branch to <code>0x1a</code>.
Note, however, that this won&rsquo;t work in all cases. For example, if the
branch address is loaded from storage, then <code>????</code> will be on top of
the stack &mdash; meaning we don&rsquo;t know where the branch goes. The
essential goal is to increase analysis precision such that we can (in
many cases) determine correct branch destinations.</p><h3 id=control-flow-joins>Control-Flow Joins</h3><p>A key question arises as to what happens when different abstract
stacks reach the same position in the code. Such a position is
typically referred to as a <em>join point</em>. The following illustrates:</p><center><table><thead><tr><th style=text-align:left>Bytecode</th><th style=text-align:left>Abstract Stack</th></tr></thead><tbody><tr><td style=text-align:left><code>PUSH1 0x8e</code></td><td style=text-align:left><code>[]</code></td></tr><tr><td style=text-align:left><code>PUSH1 0x1f</code></td><td style=text-align:left><code>[0x8e]</code></td></tr><tr><td style=text-align:left><code>PUSH1 0x80</code></td><td style=text-align:left><code>[0x8e,0x1f]</code></td></tr><tr><td style=text-align:left><code>SLOAD</code></td><td style=text-align:left><code>[0x8e,0x1f,0x80]</code></td></tr><tr><td style=text-align:left><code>PUSH1 0x1a</code></td><td style=text-align:left><code>[0x8e,0x1f,????]</code></td></tr><tr><td style=text-align:left><code>JUMPI</code></td><td style=text-align:left><code>[0x8e,0x1f,????,0x1a]</code></td></tr><tr><td style=text-align:left><code>POP</code></td><td style=text-align:left><code>[0x8e,0x1f]</code></td></tr><tr><td style=text-align:left><code>PUSH1 0x2f</code></td><td style=text-align:left><code>[0x8e]</code></td></tr><tr><td style=text-align:left><code>PUSH1 0x1a</code></td><td style=text-align:left><code>[0x8e,0x2f]</code></td></tr><tr><td style=text-align:left><code>JUMP</code></td><td style=text-align:left><code>[0x8e,0x2f,0x1a]</code></td></tr></tbody></table></center><p>This code branches to position <code>0x1a</code> from two locations and, in each
case, a different abstract stack is passed along (<code>[0x8e,0x1f]</code> versus
<code>[0x8e,0x2f]</code>). It looks something like this:</p><figure class=text-center><img width=635px alt="Illustrating types being pulled up the AST of an expresion." src=/images/2022/DecompilingEvm_1.png></figure><p>The question then <em>is what abstract stack should we
use for location <code>0x1a</code>?</em> There are different ways we can solve this
problem, but the simplest is just to <em>merge</em> the two stacks together
in such a way that retains as much information as possible.</p><p>When merging two abstract stacks which have the same concrete value at
the same position, then that concrete value is retained. Otherwise,
we simply use <code>????</code> at that position (since we have no way to
represent more than one concrete value in our model). For example,
merging<code>[0x8e,0x1f]</code> with <code>[0x8e,0x2f]</code> yields the stack <code>[0x8e,????]</code>
which safely approximates the two possible stacks at position <code>0x1a</code>.</p><h3 id=generalising-the-abstraction>Generalising the Abstraction</h3><p>A further limitation with our abstract stack model is that it assumes
a <em>concrete stack height</em>. Consider this variation on our program
from before:</p><center><table><thead><tr><th style=text-align:left>Bytecode</th><th style=text-align:left>Abstract Stack</th></tr></thead><tbody><tr><td style=text-align:left><code>PUSH1 0x8e</code></td><td style=text-align:left><code>[]</code></td></tr><tr><td style=text-align:left><code>PUSH1 0x1f</code></td><td style=text-align:left><code>[0x8e]</code></td></tr><tr><td style=text-align:left><code>PUSH1 0x80</code></td><td style=text-align:left><code>[0x8e,0x1f]</code></td></tr><tr><td style=text-align:left><code>SLOAD</code></td><td style=text-align:left><code>[0x8e,0x1f,0x80]</code></td></tr><tr><td style=text-align:left><code>PUSH1 0x1a</code></td><td style=text-align:left><code>[0x8e,0x1f,????]</code></td></tr><tr><td style=text-align:left><code>JUMPI</code></td><td style=text-align:left><code>[0x8e,0x1f,????,0x1a]</code></td></tr><tr><td style=text-align:left><code>SWAP1</code></td><td style=text-align:left><code>[0x8e,0x1f]</code></td></tr><tr><td style=text-align:left><code>POP</code></td><td style=text-align:left><code>[0x1f,0x8e]</code></td></tr><tr><td style=text-align:left><code>PUSH1 0x1a</code></td><td style=text-align:left><code>[0x1f]</code></td></tr><tr><td style=text-align:left><code>JUMP</code></td><td style=text-align:left><code>[0x1f,0x1a]</code></td></tr></tbody></table></center><p>Again, this program branches to <code>0x1a</code> from two locations each of
which passes along a different stack (<code>[0x8e,0x1f]</code> versus <code>[0x1f]</code>).
This looks something like this:</p><figure class=text-center><img width=635px alt="Illustrating types being pulled up the AST of an expresion." src=/images/2022/DecompilingEvm_2.png></figure><p>The question this time <em>is how do we merge stacks with different
heights?</em> With our current abstract stack model we actually can&rsquo;t!
So, we need to <em>generalise</em> it further to support stacks of different
heights. A simple way to do this is with an <a href=/publications/pea15_seus/>integer
range</a> <code>l..r</code> (where <code>l &lt;= r</code> and the range
is inclusive). For example, the range <code>0..1</code> represents the set
<code>{0,1}</code>, whilst <code>0..0</code> represents the constant <code>0</code> (i.e. singleton set
<code>{0}</code>).</p><p>We can now adjust our stack model to include its <em>length</em> as an
integer range. For example, the stack <code>[0x1a,0x80]</code> in our previous
model now becomes <code>[0x1a,0x80]:2..2</code> (where <code>2..2</code> signals a known
stack height of <code>2</code>). This allows us to represent the merge of
<code>[0x8e,0x1f]</code> with <code>[0x1f]</code> as <code>[0x1f]:1..2</code>. Essentially, this
describes any stack whose top value is <code>0x1f</code> and height is either <code>1</code>
or <code>2</code>. Anyway, there are quite a few details needed to make this
work fully, but hopefully it gives the general idea.</p><h2 id=conclusion>Conclusion</h2><p>This article has given a basic overview of how dataflow analysis can
be used for reasoning about jump destinations. However, to make a
serious analysis which can handle bytecode found in the wild needs
much more work. A good starting point for understanding this are the
following papers:</p><ol><li><strong>Elipmoc: advanced decompilation of Ethereum smart
contracts</strong>. In <em>Proc
OOPSLA</em>, 2022. <a href=https://yanniss.github.io/elipmoc-oopsla22.pdf>PDF</a></li><li><strong>Gigahorse: Thorough, Declarative Decompilation of Smart
Contracts</strong>. In <em>Proc
ICSE</em>, 2019. <a href=https://yanniss.github.io/gigahorse-icse19.pdf>PDF</a></li></ol><p>Enjoy!</p><hr><i>Follow the discussion on
<a href=https://twitter.com/whileydave/status/1612325134215544832>Twitter</a>
or
<a href=https://www.reddit.com/r/ethereum/comments/107oq2c/disassembling_evm_bytecode_the_basics/>Reddit</a></i></div></div></body></html>