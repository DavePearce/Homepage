<!doctype html><html lang=en><head><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta property="og:title" content="Efficient Functions in Dafny"><meta name=twitter:title content="Efficient Functions in Dafny"><meta property="og:description" content="An unusual feature of Dafny is that functions can be implemented _by_ methods."><meta name=twitter:description content="An unusual feature of Dafny is that functions can be implemented _by_ methods."><meta property="og:image" content="https://whileydave.com/images/2023/DafnyByMethod_Preview.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://whileydave.com/images/2023/DafnyByMethod_Preview.png"><meta property="og:url" content="https://whileydave.com/2023/09/16/efficient-functions-in-dafny/"><title>David J. Pearce
(Efficient Functions in Dafny)</title><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css><link rel=stylesheet href=https://whileydave.com/css/page.css><link rel=stylesheet href=https://whileydave.com/css/menu.css><link rel=stylesheet href=https://whileydave.com/css/style.css><link rel=stylesheet href=https://whileydave.com/css/syntax.css></head><body><script>"use strict";function clearMenu(){var e,t,n=window.matchMedia("(max-width: 992px)");n.matches&&(e=document.getElementById("menu-content"),t=document.getElementById("menu"),e.style.display="none",t.style.filter="")}function toggleMenu(){var e,t,n=window.matchMedia("(max-width: 992px)");n.matches&&(e=document.getElementById("menu-content"),t=document.getElementById("menu"),e.style.display==="block"?(e.style.display="none",t.style.filter=""):(e.style.display="block",t.style.filter="brightness(0.8)"))}function toggleList(e){e.style.display="none";for(var t,o=e.parentNode,s=o.childNodes,n=0;n<s.length;++n)t=s[n],t.classList&&t.classList.contains("hidden")&&(t.style.display==="block"?t.style.display="none":t.style.display="block")}</script><header class=topbar><div class=topbar-header onclick=clearMenu()><div class=topbar-title>Dr. David J. Pearce</div><div class=topbar-subtitle></div></div><div class=topbar-social onclick=clearMenu()><a href=https://github.com/DavePearce><i class="fa fa-github" aria-hidden=true></i></a>
<a href=https://twitter.com/WhileyDave><i class="fa fa-twitter" aria-hidden=true></i></a>
<a href=https://www.youtube.com/user/redjamjar/><i class="fa fa-youtube-play" aria-hidden=true></i></a>
<a href=https://www.linkedin.com/in/david-pearce-8592647/><i class="fa fa-linkedin-square" aria-hidden=true></i></a></div><div class=topbar-menu><div id=menu onclick=toggleMenu()><div id=menu-icon><img src=https://whileydave.com/images/menu.png alt=Menu></div><div id=menu-content><a href=https://whileydave.com/blog/>Blog</a>
<a href=https://whileydave.com/projects/>Projects</a>
<a href=https://whileydave.com/publications/>Publications</a>
<a href=https://whileydave.com/talks/>Talks</a>
<a href=https://whileydave.com/>Home</a></div></div></div></header><div class=container onclick=clearMenu()><div class=content><h1 class=post-title>Efficient Functions in Dafny</h1><div class=post-date>Saturday, September
16th,
2023</div><hr><p>In developing an <a href=https://github.com/ConsenSys/evm-dafny>EVM in
Dafny</a>, a key requirement is
to test it against the <a href=https://github.com/ethereum/tests>official EVM test
suite</a>. This means it needs to be
at least reasonably efficient, otherwise completing a test run becomes
impractical. At the same time, our DafnyEVM is intended to serve as a
specification for which can be used to verify bytecode contracts (see
e.g. <a href=https://github.com/Consensys/WrappedEther.dfy>here</a>). This
means we use Dafny <code>function</code>s to implement our EVM, rather than
<code>method</code>s. For various reasons, a <code>function</code> in Dafny is fairly
restricted and, for example, must use recursion instead of
imperative-style loops. Dafny will exploit <a href=https://en.wikipedia.org/wiki/Tail_call>tail
recursion</a> to improve
performance, but this is not always possible. Thus, we have a
problem: we need to use <code>function</code>s for verification, but these are
(sometimes) less efficient than <code>method</code>s.</p><h2 id=example>Example</h2><p>To illustrate, consider the following method taken from our DafnyEVM:</p><pre tabindex=0><code class=language-dafny data-lang=dafny>function ToBytes(v:nat) : (r:seq&lt;u8&gt;)
ensures |r| &gt; 0 {
  // Extract the byte
  var b : u8 := (v % 256) as u8;
  // Determine what&#39;s left
  var w : nat := v/256;
  if w == 0 then [b]
  else
    ToBytes(w) + [b]
}
</code></pre><p>This converts an arbitrary-sized unsigned integer into a sequence of
one or more bytes (in big endian form). When translating this into
Java, Dafny regards it as tail recursive and generates (very roughly
speaking) the following code:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>List</span><span class=o>&lt;</span><span class=n>Byte</span><span class=o>&gt;</span> <span class=nf>ToBytes</span><span class=o>(</span><span class=n>v</span><span class=o>:</span><span class=n>BigInteger</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=n>ArrayList</span><span class=o>&lt;</span><span class=n>Byte</span><span class=o>&gt;</span> <span class=n>r</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;&gt;();</span>
</span></span><span class=line><span class=cl>  <span class=k>while</span> <span class=o>(</span><span class=kc>true</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>byte</span> <span class=n>b</span> <span class=o>=</span> <span class=n>v</span><span class=o>.</span><span class=na>mod</span><span class=o>(</span><span class=n>_256</span><span class=o>).</span><span class=na>byteValue</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=n>BigInteger</span> <span class=n>w</span> <span class=o>=</span> <span class=n>v</span><span class=o>.</span><span class=na>div</span><span class=o>(</span><span class=n>_256</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=o>(</span><span class=n>w</span><span class=o>.</span><span class=na>signum</span><span class=o>()</span> <span class=o>==</span> <span class=n>0</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=n>r</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=n>r</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>b</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span> <span class=o>}</span>
</span></span></code></pre></div><p>Dafny optimises the recursive call into a <code>while</code> loop &mdash; thereby
making it (relatively) efficient. Consider now the analoguous
operation which converts a sequence of bytes back into an
arbitrary-sized unsigned integer:</p><pre tabindex=0><code class=language-dafny data-lang=dafny>function FromBytes(bytes:seq&lt;u8&gt;) : nat {
  if |bytes| == 0 then 0
  else
    var last := |bytes| - 1;
    var byte := bytes[last] as nat;
    var msw := FromBytes(bytes[..last]);
    (msw * 256) + byte
}
</code></pre><p>Dafny does not recognise this as tail recursive and, hence, generates
(very roughly speaking) the following Java:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>BigInteger</span> <span class=nf>FromBytes</span><span class=o>(</span><span class=n>bytes</span><span class=o>:</span> <span class=n>List</span><span class=o>&lt;</span><span class=n>Byte</span><span class=o>&gt;)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=n>bytes</span><span class=o>.</span><span class=na>length</span><span class=o>()</span> <span class=o>==</span> <span class=n>0</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>BigInteger</span><span class=o>.</span><span class=na>ZERO</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span> <span class=k>else</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>last</span> <span class=o>=</span> <span class=n>bytes</span><span class=o>.</span><span class=na>length</span><span class=o>()</span> <span class=o>-</span> <span class=n>1</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>byte</span> <span class=kt>byte</span> <span class=o>=</span> <span class=n>bytes</span><span class=o>.</span><span class=na>get</span><span class=o>(</span><span class=n>last</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=n>bytes</span> <span class=o>=</span> <span class=n>bytes</span><span class=o>.</span><span class=na>subList</span><span class=o>(</span><span class=n>0</span><span class=o>,</span><span class=n>last</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=n>BigInteger</span> <span class=n>msw</span> <span class=o>=</span> <span class=n>FromBytes</span><span class=o>(</span><span class=n>bytes</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=n>msw</span> <span class=o>=</span> <span class=n>msw</span><span class=o>.</span><span class=na>mul</span><span class=o>(</span><span class=n>_256</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=n>msw</span> <span class=o>=</span> <span class=n>msw</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>BigInteger</span><span class=o>.</span><span class=na>valueOf</span><span class=o>(</span><span class=kt>byte</span> <span class=o>&amp;</span> <span class=n>0xff</span><span class=o>));</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>msw</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span> <span class=o>}</span>
</span></span></code></pre></div><p>Unfortunately, on the official Ethereum test suite this implementation
raises a <code>StackOverflowException</code> on some tests. Specifically, on
tests for certain <a href=https://www.evm.codes/precompiled>precompiled
contracts</a> which generate <em>very</em>
large integers from long byte sequences.</p><h2 id=function-by-method>Function <code>by method</code></h2><p>Dafny supports a little-known feature (<code>by method</code>) which allows a
<code>function</code> to be implemented using a <code>method</code>. This means the
specification can still be given in the functional (i.e. recursive)
style whilst the implementation is given in an imperative style
(i.e. with loops).</p><p>To better understand this, consider the following example:</p><pre tabindex=0><code class=language-dafny data-lang=dafny>function sum(items: seq&lt;nat&gt;) : (r:nat) {
  if |items| == 0 then 0
  else items[0] + sum(items[1..])
}
</code></pre><p>This recursively computes the sum of a sequence of unsigned integers
(<code>nat</code>s). Using <code>by method</code>, we can add an imperative implementation
like so:</p><pre tabindex=0><code>function sum(items: seq&lt;nat&gt;) : (r:nat) {
  if |items| == 0 then 0
  else items[0] + sum(items[1..])
} by method {
  r := 0;
  var i : nat := |items|;
  while i &gt; 0
  invariant r == sum(items[i..]) {
    i := i - 1;
    r := r + items[i];
} }
</code></pre><p>This uses a <code>while</code> loop to implement the functional specification.
The key point is that <em>Dafny automatically proves the imperative
version correctly implements the functional specification</em>. Whilst
that is pretty amazing, Dafny does need help to do this: firstly, an
<code>invariant</code> was needed to help Dafny match the loop and the recursive
specification at each step; secondly, to make this work, the loop must
traverse <em>backwards</em> through the sequence (which is perhaps not that
intuitive). However, having done this, we now know <code>sum()</code> will not
exhaust the call stack at runtime on large inputs!</p><p>We can now see the final version of our <code>FromBytes()</code> function from before:</p><pre tabindex=0><code>function FromBytes(bytes:seq&lt;u8&gt;) : (r:nat) {
  if |bytes| == 0 then 0
  else
    var last := |bytes| - 1;
    var byte := bytes[last] as nat;
    var msw := FromBytes(bytes[..last]);
    (msw * 256) + byte
} by method {
  r := 0;
  for i := 0 to |bytes|
  invariant r == FromBytes(bytes[..i]) {
    var ith := bytes[i] as nat;
    r := (r * 256) + ith;
    LemmaFromBytes(bytes,i);
  }
  // Dafny needs help here :)
  assert bytes[..|bytes|] == bytes;
  // Done
  return r;
}
</code></pre><p>The <code>by method</code> implementation is similar to what we did for the
<code>sum()</code> example, though Dafny requires slightly more hand-holding to
show the <code>while</code> loop is equivalent to the recursive specification.
In particular, a lemma <code>LemmaFromBytes()</code> is needed to help
reestablish the loop invariant (not shown). Regardless, the net
effect is the same &mdash; <code>FromBytes()</code> no longer exhausts the call stack
on the official EVM test suite. That is a great result!</p><h2 id=conclusion>Conclusion</h2><p>In languages like Dafny, a dichotomy exists between <em>functional
specifications</em> and <em>imperative implementations</em>: Specifications must
be functional so the underlying theorem prover can safely reason about
them; on the other hand, algorithms are often more efficient when
implemented using loops. The ability to seamlessly cross the divide
between these two extremes is a unique feature of Dafny which (when
the need arises) is compelling.</p><hr></div></div><script async src="https://www.googletagmanager.com/gtag/js?id=G-9MRLB1FVZX"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-9MRLB1FVZX",{anonymize_ip:!1})}</script></body></html>