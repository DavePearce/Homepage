<!doctype html><html lang=en><head><script async src="https://www.googletagmanager.com/gtag/js?id=G-9MRLB1FVZX"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-9MRLB1FVZX",{anonymize_ip:!1})}</script><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta property="og:title" content="Puzzling Strong Updates in Rust"><meta name=twitter:title content="Puzzling Strong Updates in Rust"><meta property="og:url" content="https://whileydave.com/2022/04/27/puzzling-strong-updates-in-rust/"><title>David J. Pearce
(Puzzling Strong Updates in Rust)</title><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css><link rel=stylesheet href=https://whileydave.com/css/page.css><link rel=stylesheet href=https://whileydave.com/css/menu.css><link rel=stylesheet href=https://whileydave.com/css/style.css><link rel=stylesheet href=https://whileydave.com/css/syntax.css></head><body><script>"use strict";function clearMenu(){var e,t,n=window.matchMedia("(max-width: 992px)");n.matches&&(e=document.getElementById("menu-content"),t=document.getElementById("menu"),e.style.display="none",t.style.filter="")}function toggleMenu(){var e,t,n=window.matchMedia("(max-width: 992px)");n.matches&&(e=document.getElementById("menu-content"),t=document.getElementById("menu"),e.style.display==="block"?(e.style.display="none",t.style.filter=""):(e.style.display="block",t.style.filter="brightness(0.8)"))}function toggleList(e){e.style.display="none";for(var t,o=e.parentNode,s=o.childNodes,n=0;n<s.length;++n)t=s[n],t.classList&&t.classList.contains("hidden")&&(t.style.display==="block"?t.style.display="none":t.style.display="block")}</script><header class=topbar><div class=topbar-header onclick=clearMenu()><div class=topbar-title>Dr. David J. Pearce</div><div class=topbar-subtitle></div></div><div class=topbar-social onclick=clearMenu()><a href=https://github.com/DavePearce><i class="fa fa-github" aria-hidden=true></i></a>
<a href=https://twitter.com/WhileyDave><i class="fa fa-twitter" aria-hidden=true></i></a>
<a href=https://www.youtube.com/user/redjamjar/><i class="fa fa-youtube-play" aria-hidden=true></i></a>
<a href=https://www.linkedin.com/in/david-pearce-8592647/><i class="fa fa-linkedin-square" aria-hidden=true></i></a></div><div class=topbar-menu><div id=menu onclick=toggleMenu()><div id=menu-icon><img src=https://whileydave.com/images/menu.png alt=Menu></div><div id=menu-content><a href=https://whileydave.com/blog/>Blog</a>
<a href=https://whileydave.com/projects/>Projects</a>
<a href=https://whileydave.com/publications/>Publications</a>
<a href=https://whileydave.com/talks/>Talks</a>
<a href=https://whileydave.com/>Home</a></div></div></div></header><div class=container onclick=clearMenu()><div class=content><h1 class=post-title>Puzzling Strong Updates in Rust</h1><div class=post-date>Wednesday, April
27th,
2022</div><hr><p>The idea of a <em>strong update</em> comes from earlier work on static
analysis and, in particular, <a href=https://en.wikipedia.org/wiki/Pointer_analysis>pointer
analysis</a>. To
understand this, let&rsquo;s imagine a hypothetical non-null analysis for C:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span><span class=o>*</span> <span class=n>r</span> <span class=o>=</span> <span class=p>(</span><span class=kt>int</span><span class=o>*</span><span class=p>)</span> <span class=n>malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=kt>int</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=kt>int</span><span class=o>**</span> <span class=n>p</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>r</span><span class=p>;</span>
</span></span></code></pre></div><p>At this point, our non-null analysis would conclude that <code>p</code> was
<code>nonnull</code> and that <code>r</code> was <code>nullable</code>. That is, <code>r</code> could be <code>NULL</code> if the
allocation failed. Let&rsquo;s continue the example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=kt>int</span><span class=o>*</span> <span class=n>q</span> <span class=o>=</span> <span class=p>(</span><span class=kt>int</span><span class=o>*</span><span class=p>)</span> <span class=n>malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=kt>int</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=k>if</span><span class=p>(</span><span class=n>q</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// Strong Update
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=n>q</span><span class=p>;</span>
</span></span></code></pre></div><p>At this point, the analysis should conclude that <code>r</code> is <code>nonnull</code>. In
the terminology of static analysis, this requires what we call a
<a href=https://stackoverflow.com/questions/13199335/can-someone-explain-what-are-strong-updates-and-give-an-example-which-illustrate>strong
update</a>.
To perform a strong update, the non-null analysis must know there is
only one possible target for <code>p</code>. If we change the example as
follows, then we lose this property (where <code>flag</code> is unknown):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span><span class=o>*</span> <span class=n>r</span> <span class=o>=</span> <span class=p>(</span><span class=kt>int</span><span class=o>*</span><span class=p>)</span> <span class=n>malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=kt>int</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=kt>int</span><span class=o>*</span> <span class=n>s</span> <span class=o>=</span> <span class=p>(</span><span class=kt>int</span><span class=o>*</span><span class=p>)</span> <span class=n>malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=kt>int</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=kt>int</span><span class=o>**</span> <span class=n>p</span> <span class=o>=</span> <span class=n>flag</span> <span class=o>?</span> <span class=o>&amp;</span><span class=nl>r</span> <span class=p>:</span> <span class=o>&amp;</span><span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span><span class=o>*</span> <span class=n>q</span> <span class=o>=</span> <span class=p>(</span><span class=kt>int</span><span class=o>*</span><span class=p>)</span> <span class=n>malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=kt>int</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=k>if</span><span class=p>(</span><span class=n>q</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// Weak Update
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=n>q</span><span class=p>;</span>
</span></span></code></pre></div><p>Now, the analysis must report both <code>r</code> and <code>s</code> as <code>nullable</code>. This
is because, although it knows one of them is <code>nonnull</code>, it doesn&rsquo;t
know which one.</p><h2 id=strong-updates-in-rust>Strong Updates in Rust</h2><p>Alright, that completes the intro on strong updates. <em>But, what has
this got to do with Rust?</em> Well, the borrow checker performs strong
updates in some situations. <em>But, it doesn&rsquo;t always apply them when
it could</em>. Whilst considering edge cases like this is a somewhat
academic exercise, I find it useful for understanding the borrow
checker. And, perhaps, it could even suggest ways to improve the
borrow checker.</p><p>Here is a simple example accepted by <code>rustc</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Rust data-lang=Rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>r</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>s</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>2</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>p</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>r</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=n>p</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>s</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;r={}, *p={}&#34;</span><span class=p>,</span><span class=n>r</span><span class=p>,</span><span class=o>*</span><span class=n>p</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w> 
</span></span></span></code></pre></div><p>As expected, this compiles and prints <code>r=1, *p=2</code>. They key is that,
since Rust knows <code>p</code> is overwritten in the assignment, it can
relinquish the borrow <code>&mut r</code>. However, if we change this a bit, it
breaks:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Rust data-lang=Rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>r</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>s</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>2</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>p</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Box</span>::<span class=n>new</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>r</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=o>*</span><span class=n>p</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>s</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;r={},**p={}&#34;</span><span class=p>,</span><span class=n>r</span><span class=p>,</span><span class=o>**</span><span class=n>p</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>This is pretty much the same example as before. The contents of <code>*p</code>
must be overwritten in the assignment, and so the borrow <code>&mut r</code>
should be relinquished as before. Unfortunately, <code>rustc</code> rejects this
program with the following error:</p><pre tabindex=0><code>let mut p = Box::new(&amp;mut r);
 mutable borrow here ------
*p = &amp;mut s;
println!(&#34;r={},**p={}&#34;,r,**p);
  mutable borrow  here --- ^
                           |
       immutable borrow here
</code></pre><p>One could argue this is expected since <code>Box&lt;T></code> has no special status
in Rust (i.e. it is just a regular user-defined type). Hence, the
borrow checker cannot be expected to know about its invariants. Ok,
so let&rsquo;s just change up the example like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Rust data-lang=Rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>r</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>s</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>2</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>q</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>r</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=kd>let</span><span class=w> </span><span class=n>p</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>q</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=o>*</span><span class=n>p</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>s</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;r={}, **p={}&#34;</span><span class=p>,</span><span class=n>r</span><span class=p>,</span><span class=o>**</span><span class=n>p</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>Now, instead of using <code>Box&lt;T></code>, we&rsquo;re using a mutable borrow. Its
roughly the same thing but, in this case, mutable borrows do have
special status. So, we could reasonably expect the borrow checker to
know about the invariants they maintain (i.e. and allow a strong
update here). <em>And yet this example is still rejected.</em></p><h2 id=is-that-it>Is that it?</h2><p>Well, not quite. The above suggests the borrow checker <em>doesn&rsquo;t</em>
perform strong updates in some situations when it could. Based on
that, I was thinking the following would fail:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Rust data-lang=Rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>f</span><span class=o>&lt;&#39;</span><span class=na>a</span><span class=o>&gt;</span><span class=p>(</span><span class=n>p</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=o>&amp;&#39;</span><span class=na>a</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=kt>i32</span><span class=p>,</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>         </span><span class=n>q</span>: <span class=kp>&amp;</span><span class=o>&#39;</span><span class=na>a</span> <span class=nc>mut</span><span class=w> </span><span class=kt>i32</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kd>let</span><span class=w> </span><span class=n>r</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=o>**</span><span class=n>p</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>*</span><span class=n>p</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>q</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;r={}, **p={}&#34;</span><span class=p>,</span><span class=n>r</span><span class=p>,</span><span class=o>**</span><span class=n>p</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>This is somehow similar to before, in that it requires a strong update
on <code>*p</code> to know that <code>p</code> and <code>r</code> do not interfere on the last
statement. <em>But, in fact, the above program is accepted!</em> So, the
borrow checker does perform strong updates sometimes&mldr;</p><h2 id=conclusion>Conclusion</h2><p>Well, I&rsquo;m not sure what the conclusion is here. Its not clear that
these kinds of situations are likely to arise in practice. Perhaps
with some further refinement we could figure out a realistic example
which could (in principle) be accepted, but currently is not.
Eitherway, exploring the limits of the borrow checker is fun!</p><hr><i>Follow the discussion on
<a href=https://www.reddit.com/r/rust/comments/uigljf/puzzling_strong_updates_in_rust/>Reddit</a></i></div></div></body></html>