<!doctype html><html lang=en><head><script async src="https://www.googletagmanager.com/gtag/js?id=G-9MRLB1FVZX"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-9MRLB1FVZX",{anonymize_ip:!1})}</script><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta property="og:title" content="Iso-Recursive versus Equi-Recursive Types"><meta name=twitter:title content="Iso-Recursive versus Equi-Recursive Types"><meta property="og:url" content="https://whileydave.com/2013/04/21/iso-recursive-versus-equi-recursive-types/"><title>David J. Pearce
(Iso-Recursive versus Equi-Recursive Types)</title><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css><link rel=stylesheet href=https://whileydave.com/css/page.css><link rel=stylesheet href=https://whileydave.com/css/menu.css><link rel=stylesheet href=https://whileydave.com/css/style.css><link rel=stylesheet href=https://whileydave.com/css/syntax.css></head><body><script>"use strict";function clearMenu(){var e,t,n=window.matchMedia("(max-width: 992px)");n.matches&&(e=document.getElementById("menu-content"),t=document.getElementById("menu"),e.style.display="none",t.style.filter="")}function toggleMenu(){var e,t,n=window.matchMedia("(max-width: 992px)");n.matches&&(e=document.getElementById("menu-content"),t=document.getElementById("menu"),e.style.display==="block"?(e.style.display="none",t.style.filter=""):(e.style.display="block",t.style.filter="brightness(0.8)"))}function toggleList(e){e.style.display="none";for(var t,o=e.parentNode,s=o.childNodes,n=0;n<s.length;++n)t=s[n],t.classList&&t.classList.contains("hidden")&&(t.style.display==="block"?t.style.display="none":t.style.display="block")}</script><header class=topbar><div class=topbar-header onclick=clearMenu()><div class=topbar-title>Dr. David J. Pearce</div><div class=topbar-subtitle></div></div><div class=topbar-social onclick=clearMenu()><a href=https://github.com/DavePearce><i class="fa fa-github" aria-hidden=true></i></a>
<a href=https://twitter.com/WhileyDave><i class="fa fa-twitter" aria-hidden=true></i></a>
<a href=https://www.youtube.com/user/redjamjar/><i class="fa fa-youtube-play" aria-hidden=true></i></a>
<a href=https://www.linkedin.com/in/david-pearce-8592647/><i class="fa fa-linkedin-square" aria-hidden=true></i></a></div><div class=topbar-menu><div id=menu onclick=toggleMenu()><div id=menu-icon><img src=https://whileydave.com/images/menu.png alt=Menu></div><div id=menu-content><a href=https://whileydave.com/blog/>Blog</a>
<a href=https://whileydave.com/projects/>Projects</a>
<a href=https://whileydave.com/publications/>Publications</a>
<a href=https://whileydave.com/talks/>Talks</a>
<a href=https://whileydave.com/>Home</a></div></div></div></header><div class=container onclick=clearMenu()><div class=content><h1 class=post-title>Iso-Recursive versus Equi-Recursive Types</h1><div class=post-date>Sunday, April
21st,
2013</div><hr><p>An important component of the Whiley language is the use of <a href=https://en.wikipedia.org/wiki/Recursive_data_type>recursive data types</a>.  Whilst these are similar to the <a href=https://en.wikipedia.org/wiki/Algebraic_data_type>algebraic data types</a> found in languages like Haskell, they are also more powerful since Whiley employs a <a href=https://en.wikipedia.org/wiki/Structural_type_system>structural type system</a>. <em>So, what does all this mean?</em> Well, let&rsquo;s look at an example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl><span class=n>define</span> <span class=n>IntList</span> <span class=n>as</span> <span class=kc>null</span> <span class=o>|</span> <span class=p>{</span><span class=kt>int</span> <span class=n>data</span><span class=p>,</span> <span class=n>IntList</span> <span class=n>next</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>define</span> <span class=n>AnyList</span> <span class=n>as</span> <span class=kc>null</span> <span class=o>|</span> <span class=p>{</span><span class=n>any</span> <span class=n>data</span><span class=p>,</span> <span class=n>AnyList</span> <span class=n>next</span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>AnyList</span> <span class=n>f</span><span class=p>(</span><span class=n>IntList</span> <span class=n>ls</span><span class=p>)</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>ls</span>
</span></span></code></pre></div><p>Here, we&rsquo;ve got two recursive data types which describe something akin to a linked list. For example, an <code>IntList</code> describes a recursive structure made up of zero or more nodes. Each node contains an <code>int data</code> field, and a <code>next</code> field to access either the next node, or <code>null</code> if the end is reached. An <code>AnyList</code> is very similar, except that its payload consists of arbitrary data, rather than just integer data (as for <code>IntList</code>).</p><p>In the above example, we see that the parameter <code>ls</code> is returned without an explicit cast. In other words, we know that <code>IntList</code> is a subtype of <code>AnyList</code>. This is a key difference from standard algebraic data types, where <code>IntList</code> and <code>AnyList</code> would always be considered distinct (i.e. unrelated) types.</p><h2 id=subtyping-recursive-types>Subtyping Recursive Types</h2><p>The ability to have implicit subtyping relationships between recursive data types is a key strength compared with algebraic data types.  At the same time, it also presents a complex algorithmic challenge and numerous approaches have been proposed in the literature.  Previously, I have written extensively on this subject (see e.g. <a href=/2011/02/16/minimising-recursive-data-types/>here</a>, <a href=/2011/03/07/implementing-structural-types/>here</a> and <a href=/2011/08/30/simplification-vs-minimisation-of-types-in-whiley/>here</a>).  In fact, there are two broad approaches taken to subtyping recursive data types: <em>iso-recursive</em> and <em>equi-recursive</em>.  In Whiley, and my previous writings on this topic, I have strictly followed the equi-recursive approach and I would strongly recommend this to anyone developing a recursive type system.</p><p>A good account of the iso- versus equi-recursive approaches can be found in <a href=http://www.cis.upenn.edu/~bcpierce/tapl/>Pierce&rsquo;s excellent book</a> [1].  The key difference between the two approaches is whether the recursion is &ldquo;implicit&rdquo; (equi-recursive) or &ldquo;explicit&rdquo; (iso-recursive).  In the equi-recursive approach, types are implemented under-the-hood as directed graphs where recursion corresponds to a cycle in the graph (see <a href=/2011/02/16/minimising-recursive-data-types/>here</a> for an example).  In the iso-recursive approach, special types of the form <code>μX.T</code> are used (the so-called &ldquo;mu&rdquo; types). In such a type, <code>X</code> is a recursive variable used within the body <code>T</code>. For example, a mu type corresponding to our <code>IntList</code> example is: <code>μX.(null | {int data, X next})</code>.</p><p>Mu types can be &ldquo;folded&rdquo; and &ldquo;unfolded&rdquo;. To unfold a type <code>μX.T</code> we generate the type <code>T[X/μX.T]</code> (that&rsquo;s <code>T</code> with <code>X</code> replaced by <code>μX.T</code>). For example, unfolding <code>μX.(null | {int data, X next})</code> gives <code>null | {int data, μX.(null | {int data, X next}) next}</code>. Explicit operators for unfolding and folding are provided for manipulating types where <code>fold(unfold(T)) = T</code> holds for any type <code>T</code>. In the iso-recursive scheme (and unlike the equi-recursive scheme), a type and its unfolding are distinct and unrelated. To show that one mu type subtypes another, we must first fold/unfold them to have the same recursive structure, after which we can establish the subtyping relation via the so-called &ldquo;Amber Rule&rdquo; (see e.g. [1,2] for more on this).</p><h2 id=subtyping-iso-recursive-types>Subtyping Iso-Recursive Types</h2><p>Having considered how subtyping is performed for iso-recursive types, the question is: <em>for two types which should be related, can we always fold/unfold them to reach a matching recursive structure?</em> Well, I believe the answer is no. Here&rsquo;s my informal proof:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl><span class=n>define</span> <span class=n>LTree</span> <span class=n>as</span> <span class=kc>null</span> <span class=o>|</span> <span class=p>{</span> <span class=kt>int</span> <span class=n>data</span><span class=p>,</span> <span class=n>LTree</span> <span class=n>left</span><span class=p>,</span> <span class=n>LTree</span> <span class=n>right</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>define</span> <span class=n>RTree</span> <span class=n>as</span> <span class=kc>null</span> <span class=o>|</span> <span class=p>{</span> <span class=kt>int</span> <span class=n>data</span><span class=p>,</span> <span class=n>RTree_b</span> <span class=n>left</span><span class=p>,</span> <span class=n>RTree</span> <span class=n>right</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>define</span> <span class=n>RTree_b</span> <span class=n>as</span> <span class=kc>null</span> <span class=o>|</span> <span class=p>{</span> <span class=kt>int</span> <span class=n>data</span><span class=p>,</span> <span class=n>RTree</span> <span class=n>left</span><span class=p>,</span> <span class=n>RTree</span> <span class=n>right</span><span class=p>}</span>
</span></span></code></pre></div><p>Now, we have to ask ourselves the question: is there a sequence of fold/unfold operations that will transform <code>LTree</code> into <code>RTree</code> (i.e. to show that they are equivalent)? To see why this is impossible, we consider the notion of &ldquo;balance&rdquo; (as in <em>balanced tree</em>). After any number of fold / unfold operations the <code>LTree</code> type will remain balanced; but, for the <code>RTree</code> type, it will never be balanced.</p><p>For a more detailed investigation into the expressiveness of iso-recursive types, I&rsquo;d suggest looking at this <a href=http://www.cse.usf.edu/~ligatti/papers/subIsoTR.pdf>recent paper</a> [2].</p><h1 id=references>References</h1><ol><li><p><a href=http://www.cis.upenn.edu/%7Ebcpierce%22>Types and Programming Languages</a>, Benjamin C. Pierce. The MIT Press, ISBN 0-262-16209-1.</p></li><li><p><a href=http://www.cse.usf.edu/~ligatti/papers/subIsoTR.pdf>Completely Subtyping Iso-recursive Types</a>, Technical Report CSE-071012, Jeremy Blackburn Ivory Hernandez Jay Ligatti Michael Nachtigal, University of South Florida.</p></li></ol><hr></div></div></body></html>