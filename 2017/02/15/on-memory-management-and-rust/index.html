<!doctype html><html lang=en><head><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta property="og:title" content="On Memory Management and Rust"><meta name=twitter:title content="On Memory Management and Rust"><meta property="og:url" content="https://whileydave.com/2017/02/15/on-memory-management-and-rust/"><title>David J. Pearce
(On Memory Management and Rust)</title><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css><link rel=stylesheet href=https://whileydave.com/css/page.css><link rel=stylesheet href=https://whileydave.com/css/menu.css><link rel=stylesheet href=https://whileydave.com/css/style.css><link rel=stylesheet href=https://whileydave.com/css/syntax.css></head><body><script>"use strict";function clearMenu(){var e,t,n=window.matchMedia("(max-width: 992px)");n.matches&&(e=document.getElementById("menu-content"),t=document.getElementById("menu"),e.style.display="none",t.style.filter="")}function toggleMenu(){var e,t,n=window.matchMedia("(max-width: 992px)");n.matches&&(e=document.getElementById("menu-content"),t=document.getElementById("menu"),e.style.display==="block"?(e.style.display="none",t.style.filter=""):(e.style.display="block",t.style.filter="brightness(0.8)"))}function toggleList(e){e.style.display="none";for(var t,o=e.parentNode,s=o.childNodes,n=0;n<s.length;++n)t=s[n],t.classList&&t.classList.contains("hidden")&&(t.style.display==="block"?t.style.display="none":t.style.display="block")}</script><header class=topbar><div class=topbar-header onclick=clearMenu()><div class=topbar-title>Dr. David J. Pearce</div><div class=topbar-subtitle></div></div><div class=topbar-social onclick=clearMenu()><a href=https://github.com/DavePearce><i class="fa fa-github" aria-hidden=true></i></a>
<a href=https://twitter.com/WhileyDave><i class="fa fa-twitter" aria-hidden=true></i></a>
<a href=https://www.youtube.com/user/redjamjar/><i class="fa fa-youtube-play" aria-hidden=true></i></a>
<a href=https://www.linkedin.com/in/david-pearce-8592647/><i class="fa fa-linkedin-square" aria-hidden=true></i></a></div><div class=topbar-menu><div id=menu onclick=toggleMenu()><div id=menu-icon><img src=https://whileydave.com/images/menu.png alt=Menu></div><div id=menu-content><a href=https://whileydave.com/blog/>Blog</a>
<a href=https://whileydave.com/projects/>Projects</a>
<a href=https://whileydave.com/publications/>Publications</a>
<a href=https://whileydave.com/talks/>Talks</a>
<a href=https://whileydave.com/>Home</a></div></div></div></header><div class=container onclick=clearMenu()><div class=content><h1 class=post-title>On Memory Management and Rust</h1><div class=post-date>Wednesday, February
15th,
2017</div><hr><p>Rust is definitely one of the more interesting new programming language I&rsquo;ve come across recently. Memory management is definitely Rust&rsquo;s &ldquo;thing&rdquo;, and the language wants to have its cake and eat it (so to speak). That is, Rust wants <em>safe</em> memory management <em>without</em> garbage collection. This is no easy task, and Rust delivers a modern solution which (it seems to me) is heavily inspired by smart pointers in C++.</p><p>In this post, I&rsquo;m going talk about how Rust addresses the memory management problem. But, I&rsquo;m also want to think about other ways we could solve this problem and, in particular, talk about a rather obscure programming language called <a href=https://en.wikipedia.org/wiki/Cyclone_(programming_language)>Cyclone</a> (which takes a somewhat different approach to solving the same problem).</p><h2 id=background>Background</h2><p>The question of how to safely manage memory has been an ongoing challenge for programming language designers.  There are essentially just two approaches in wide spread use:  on the one hand, we have languages with <em>manual</em> memory management (e.g. C/C++) and, on the other, we have languages with <em><a href=https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)>garbage collection</a></em> (e.g. Java/C#/Haskell/Erlang).  By now, the issues with manual memory management are well known and, for example, are (still) a major source of software vulnerabilities.  Garbage collection, in contrast, has proved to be an excellent solution, and significant research has been directed into efficient algorithms.  In some sense, garbage collection has been a real success story for computer science.</p><p>Systems programming languages avoid garbage collection for various reasons (e.g. to run on bare metal).  The problem is there&rsquo;s no middle ground between manual memory management and garbage collection.  <em>Actually, that&rsquo;s not completely true!</em>  C++ has forged an interesting approach over the years through  <a href=https://en.wikipedia.org/wiki/Smart_pointer><em>smart pointers</em></a>.  The advent of <a href=https://en.wikipedia.org/wiki/C%2B%2B11>C++11</a> brought a bunch of great language updates, especially (from our perspective) support for <em>move semantics</em>.  This allowed smart pointer to evolve and become more sophisticated, leading to <code>auto_ptr</code> being retired and replaced with <code>unique_ptr</code>.  Overall, smart pointers were (it seems to me) a big influence on the design of Rust&mldr;</p><h3 id=rust>Rust</h3><p>In essence, Rust bakes smart pointers into the language and provides proper support for checking them through the so-called <em>borrow checker</em>.  It&rsquo;s easy to get confused with all the Rust &ldquo;lingo&rdquo; but (for me at least) viewing it through the C++ lens helped a lot.  Here&rsquo;s an example in Rust:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Rust data-lang=Rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>dup</span><span class=p>(</span><span class=n>x</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=kt>i32</span><span class=o>&gt;</span><span class=p>)</span><span class=w> </span>-&gt; <span class=p>(</span><span class=nb>Vec</span><span class=o>&lt;</span><span class=kt>i32</span><span class=o>&gt;</span><span class=p>,</span><span class=nb>Vec</span><span class=o>&lt;</span><span class=kt>i32</span><span class=o>&gt;</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>x</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=p>(</span><span class=n>x</span><span class=p>,</span><span class=w> </span><span class=n>y</span><span class=p>);</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>This program <a href="https://play.rust-lang.org/?gist=b813c1ec0196f5a17af85f0bc3b86690&version=stable&backtrace=0">does not compile</a>, and produces the (somewhat) useful error message:</p><pre tabindex=0><code>error[E0382]: use of moved value: `x`
  |
2 |     let y = x;
  |         - value moved here
3 |     return (x, y); 
  |             ^ value used here after move
</code></pre><p>(actually, the error message is pretty good <em>once</em> you get the hang of borrowing in Rust)</p><p>We can view this through the C++11 lens as something like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;utility&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;memory&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;vector&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=o>&gt;</span> <span class=n>Vec</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>pair</span><span class=o>&lt;</span><span class=n>Vec</span><span class=p>,</span><span class=n>Vec</span><span class=o>&gt;</span> <span class=n>dup</span><span class=p>(</span><span class=n>Vec</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>Vec</span> <span class=n>y</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>x</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nf>make_pair</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>x</span><span class=p>),</span><span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>y</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This is actually a pretty fair representation of the original Rust program. But, there&rsquo;s one important difference: <em>it compiles!</em> According to the standard, variable <code>x</code> is in a valid but <em>unspecified</em> state after the move (see e.g. <a href=http://stackoverflow.com/questions/20850196/what-lasts-after-using-stdmove-c11>here</a> and <a href=http://stackoverflow.com/questions/9168823/reusing-a-moved-container>here</a>).</p><p>At this point, I&rsquo;m not going say much more about Rust. Don&rsquo;t take this to mean there isn&rsquo;t anything else to say <em>as that&rsquo;s definitely not true!</em> And, my simple way of looking at Rust through a &ldquo;C++ lens&rdquo; is just that &mdash; a simplification. Nevertheless, it provides a useful way to think about Rust, and to compare with other similar approaches &mldr;</p><h2 id=cyclone>Cyclone</h2><p>The <a href=https://en.wikipedia.org/wiki/Cyclone_(programming_language)>Cyclone language</a> was an attempt to add memory safety to C. In a way, many of its objectives were similar to those of Rust. In fact, Cyclone is highlighted as <a href=https://doc.rust-lang.org/reference.html#appendix-influences>one of the influences</a> on Rust.</p><p>Cyclone adopts the <a href=https://en.wikipedia.org/wiki/Region-based_memory_management>region-based approach to memory management</a>. In this approach, data is allocated into <em>regions</em> and references are annotated to identify the region in which the data they refer to resides. The following is the canonical illustration which reports a compile-time error:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>f</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>x</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=o>*</span><span class=err>@</span><span class=n>region</span><span class=p>(</span><span class=err>`</span><span class=n>f</span><span class=p>)</span> <span class=n>y</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=nl>L</span><span class=p>:{</span>
</span></span><span class=line><span class=cl>      <span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=n>y</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl>   <span class=p>}</span>
</span></span><span class=line><span class=cl>   <span class=k>return</span> <span class=o>*</span><span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Here, variable <code>y</code> is a pointer into the region automatically associated with function <code>f()</code>, whilst variable <code>a</code> is declared in region <code>L</code>. Thus, the assignment <code>y=&a</code> is not permitted as, if allowed, it would lead to a dangling pointer.</p><p>For Rustaceans, the above example should be somewhat familiar. Simplistically, we can say that regions are like lifetimes in Rust. Certainly, they exhibit many similar properties. But, they are also subtly different:</p><ul><li><p><strong>Regions do not impose ownership</strong>.  There is no problem with multiple mutable pointers to the same heap location, provided both pointers are appropriately typed.  Amongst other things, this means cyclic structures within a region are permitted. However, it also means this mechanism cannot be used for managing shared resources (in fact, Cyclone has a separate notion of <code>unique</code> pointer for this).</p></li><li><p><strong>All pointers are associated with regions</strong>.  This may seem an odd thing to say.  But, in Rust, this is not actually the case.  That is, in Rust, all <em>borrowed references</em> are associated with a lifetime (either explicitly or implicitly).  However, owned references are not.  This means we can return a <code>Vec</code> from a function and it can migrate throughout our program as we see fit. In Cyclone, however, heap objects are tied to a specific region and <em>cannot outlive that region</em>.</p></li></ul><p>My goal here is not to suggest that one approach is better than the other. Only to highlight the interesting differences. It seems to me that Cyclone&rsquo;s approach offers more flexibility in terms of the structures it can represent but, at the same time, is perhaps more &ldquo;relaxed&rdquo; about deallocation of memory (i.e. because you must wait for an entire region to be deallocated). Rust is quite strict, on the otherhand, but as a result can be more aggressive in deallocating memory. Rust also perhaps hides users from memory management to some extent, as such details are often hidden behind abstract data types (like <code>Vec</code>).</p><hr></div></div><script async src="https://www.googletagmanager.com/gtag/js?id=G-9MRLB1FVZX"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-9MRLB1FVZX",{anonymize_ip:!1})}</script></body></html>