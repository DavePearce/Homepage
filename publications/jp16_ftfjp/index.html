<!doctype html><html><head><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><title>A Mechanical Soundness Proof for Subtyping over Recursive Types</title><link rel=stylesheet href=https://davepearce.github.io/Homepage/css/page.css><link rel=stylesheet href=https://davepearce.github.io/Homepage/css/menu.css><link rel=stylesheet href=https://davepearce.github.io/Homepage/css/style.css></head><body><script>function toggleMenu(){if(window.innerWidth<=768){var content=document.getElementById("menu-content");var menu=document.getElementById("menu");if(content.style.display==='block'){content.style.display='none';menu.style.filter='';}else{content.style.display='block';menu.style.filter="brightness(0.8)";}}}
function clearMenu(){if(window.innerWidth<=768){document.getElementById("menu-content").style.display='none';document.getElementById("menu").style.filter='';}}</script><header class=topbar onclick=toggleMenu()><div class=topbar-title>Dr. David J. Pearce</div><div class=topbar-subtitle>Associate Professor of Computer Science</div><div class=topbar-menu><div id=menu><div id=menu-icon></div><div id=menu-content><a href=https://davepearce.github.io/Homepage/>Home</a>
<a href=https://davepearce.github.io/Homepage/projects/>Projects</a>
<a href=https://davepearce.github.io/Homepage/publications/>Publications</a></div></div></div></header><div class=container><div class=content><h1>A Mechanical Soundness Proof for Subtyping over Recursive Types</h1><p><strong>Abstract:</strong> Structural type systems provide an interesting alternative to the more common nominal typing scheme. Several existing languages employ structural types in some form, including Modula-3, Scala and various extensions proposed for Java. However, formalising a recursive structural type system is challenging. In particular, the need to use structural coinduction remains a hindrance for many. We formalise in Agda a simple recursive and structural type system with products and unions. Agda proves useful here because it has explicit support for coinduction and will raise an error if this is misused. The implementation distinguishes between inductively and coinductively defined types: the former corresponds to a finite representation, such as found in source code or the internals of a compiler, while the latter corresponds to a mathematical ideal with which we can coinductively define relations and proofs that are easily applied back to the inductive interpretation. As an application of this, we provide a mechanised proof of subtyping soundness against a semantic embedding of the types into Agda.</p><b>Links:</b>
<a href=https://doi.org/10.1145/2955811.2955812>DOI</a>
/
<a href=https://davepearce.github.io/Homepage//publications/JP16_FTFJP_preprint.pdf>PDF</a>
/
<a href=http://2016.ecoop.org/track/FTfJP-2016>Website</a></div></div><script></script></body></html>