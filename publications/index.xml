<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Publications on Dave's Homepage</title><link>https://davepearce.github.io/Homepage/publications/</link><description>Recent content in Publications on Dave's Homepage</description><generator>Hugo -- gohugo.io</generator><language>en-nz</language><lastBuildDate>Fri, 13 Oct 2017 20:31:39 -0500</lastBuildDate><atom:link href="https://davepearce.github.io/Homepage/publications/index.xml" rel="self" type="application/rss+xml"/><item><title>Computational Resources</title><link>https://davepearce.github.io/Homepage/publications/rp2020_crc/</link><pubDate>Wed, 01 Jan 2020 00:00:00 +0000</pubDate><guid>https://davepearce.github.io/Homepage/publications/rp2020_crc/</guid><description/></item><item><title>AtmoVis: Visualization of Air Quality Data</title><link>https://davepearce.github.io/Homepage/publications/powley19_msc/</link><pubDate>Tue, 01 Jan 2019 00:00:00 +0000</pubDate><guid>https://davepearce.github.io/Homepage/publications/powley19_msc/</guid><description/></item><item><title>Dependency Versioning in the Wild</title><link>https://davepearce.github.io/Homepage/publications/dpstb19_msr/</link><pubDate>Tue, 01 Jan 2019 00:00:00 +0000</pubDate><guid>https://davepearce.github.io/Homepage/publications/dpstb19_msr/</guid><description/></item><item><title>A Symmetry Metric for Graphs and Line Diagrams</title><link>https://davepearce.github.io/Homepage/publications/kmp18_diagrams/</link><pubDate>Mon, 01 Jan 2018 00:00:00 +0000</pubDate><guid>https://davepearce.github.io/Homepage/publications/kmp18_diagrams/</guid><description/></item><item><title>An Introduction to Software Verification with Whiley</title><link>https://davepearce.github.io/Homepage/publications/pug18_etss/</link><pubDate>Mon, 01 Jan 2018 00:00:00 +0000</pubDate><guid>https://davepearce.github.io/Homepage/publications/pug18_etss/</guid><description>Abstract: This tutorial introduces the basic ideas of software specification and verification, which are important techniques for assuring the quality of software and eliminating common kinds of errors such as buffer overflow. The tutorial takes a practical hands-on approach using the Whiley language and its verifying compiler. This verifying compiler uses an automated proof engine to try to prove that the code will execute without errors and will satisfy its specifications.</description></item><item><title>On Declarative Rewriting for Sound and Complete Union, Intersection and Negation Types</title><link>https://davepearce.github.io/Homepage/publications/pea18_jvlc/</link><pubDate>Mon, 01 Jan 2018 00:00:00 +0000</pubDate><guid>https://davepearce.github.io/Homepage/publications/pea18_jvlc/</guid><description>Abstract. Implementing the type system of a programming language is a critical task that is oftendone in an ad-hoc fashion. Whilst this makes it hard to ensure the system is sound, italso makes it difficult to extend as the language evolves. We are interested in describing type systems using rewrite rules from which an implementation can be automaticallygenerated. Whilst not all type systems are easily expressed in this manner, those involving unions, intersections and negations are well-suited for this.</description></item><item><title>Rewriting for Sound and Complete Union, Intersection and Negation Types</title><link>https://davepearce.github.io/Homepage/publications/pea18_gpce/</link><pubDate>Mon, 01 Jan 2018 00:00:00 +0000</pubDate><guid>https://davepearce.github.io/Homepage/publications/pea18_gpce/</guid><description>Abstract: Implementing the type system of a programming language is a critical task that is often done in an ad-hoc fashion. Whilst this makes it hard to ensure the system is sound, it also makes it difficult to extend as the language evolves. We are interested in describing type systems using declarative rewrite rules from which an implementation can be automatically generated. Whilst not all type systems are easily expressed in this manner, those involving unions, intersections and negations are well-suited for this.</description></item><item><title>Towards Compilation of an Imperative Language for FPGAs</title><link>https://davepearce.github.io/Homepage/publications/ppp18_vmil/</link><pubDate>Mon, 01 Jan 2018 00:00:00 +0000</pubDate><guid>https://davepearce.github.io/Homepage/publications/ppp18_vmil/</guid><description>Abstract: Field-Programmable Gate Arrays (FPGA’s) have been around since the early 1980s and have now achieved relatively widespread use. For example, FPGAs are routinely used for high-performance computing, financial applications, seismic modelling, DNA sequence alignment, software defined networking and, occasionally, are even found in smartphones. And yet, despite their success, there still remains something of a gap between programming languages and circuit designs for an FPGA. We consider the compilation of an imperative programming language, Whiley, to VHDL for use on an FPGA.</description></item><item><title>Array Programming in Whiley</title><link>https://davepearce.github.io/Homepage/publications/pea17_array/</link><pubDate>Sun, 01 Jan 2017 00:00:00 +0000</pubDate><guid>https://davepearce.github.io/Homepage/publications/pea17_array/</guid><description>Abstract: Arrays are a fundamental mechanism for developing and reasoning about programs. Using them, one can easily encode a range of important algorithms from various domains, such as for sorting, graph traversal, heap manipulation and more. However, the encoding of such problems in traditional languages is relatively opaque. That is, such programming languages do not allow those properties important for the given problem to be encoded within the language itself and, instead, rely up on programmer-supplied comments.</description></item><item><title>Classless Object Semantics</title><link>https://davepearce.github.io/Homepage/publications/jones17_phd/</link><pubDate>Sun, 01 Jan 2017 00:00:00 +0000</pubDate><guid>https://davepearce.github.io/Homepage/publications/jones17_phd/</guid><description/></item><item><title>Contracts in the Wild: A Study of Java Programs</title><link>https://davepearce.github.io/Homepage/publications/dpjb17_ecoop/</link><pubDate>Sun, 01 Jan 2017 00:00:00 +0000</pubDate><guid>https://davepearce.github.io/Homepage/publications/dpjb17_ecoop/</guid><description>Abstract: The use of formal contracts has long been advocated as an approach to develop programs that are provably correct. However, the reality is that adoption of contracts has been slow in practice. Despite this, the adoption of lightweight contracts — typically utilising runtime checking — has progressed. In the case of Java, built-in features of the language (e.g. assertions and exceptions) can be used for this. Furthermore, a number of libraries which facilitate contract checking have arisen.</description></item><item><title>Making Whiley Boogie!</title><link>https://davepearce.github.io/Homepage/publications/upg17_ifm/</link><pubDate>Sun, 01 Jan 2017 00:00:00 +0000</pubDate><guid>https://davepearce.github.io/Homepage/publications/upg17_ifm/</guid><description>Abstract: The quest to develop increasingly sophisticated verification systems continues unabated. Tools such as Dafny, Spec#, ESC/Java, SPARK Ada, and Whiley attempt to seamlessly integrate specification and verification into a programming language, in a similar way to type checking. A common integration approach is to generate verification conditions that are handed off to an automated theorem prover. This provides a nice separation of concerns, and allows different theorem provers to be used interchangeably.</description></item><item><title>A Mechanical Soundness Proof for Subtyping over Recursive Types</title><link>https://davepearce.github.io/Homepage/publications/jp16_ftfjp/</link><pubDate>Fri, 01 Jan 2016 00:00:00 +0000</pubDate><guid>https://davepearce.github.io/Homepage/publications/jp16_ftfjp/</guid><description/></item><item><title>A Space Efficient Algorithm for Detecting Strongly Connected Components</title><link>https://davepearce.github.io/Homepage/publications/pea16_ipl/</link><pubDate>Fri, 01 Jan 2016 00:00:00 +0000</pubDate><guid>https://davepearce.github.io/Homepage/publications/pea16_ipl/</guid><description>Abstract. Tarjan’s algorihm for finding the strongly connected components of a directed graph is widely used and acclaimed. His original algorithm required at most v(2 + 5w) bits of storage, where w is the machine’s word size, whilst Nuutila and Soisalon-Soininen reduced this to v(1 + 4w). Many real world applications routinely operate on very large graphs where the storage requirements of such algorithms is a concern. We present a novel improvement on Tarjan’s algorithm which reduces the space requirements to v(1 + 3w) bits in the worst case.</description></item><item><title>Comparing Graph Layouts for Vertex Selection Tasks</title><link>https://davepearce.github.io/Homepage/publications/kpm15_ozchi/</link><pubDate>Thu, 01 Jan 2015 00:00:00 +0000</pubDate><guid>https://davepearce.github.io/Homepage/publications/kpm15_ozchi/</guid><description/></item><item><title>Designing a Verifying Compiler: Lessons Learned from Developing Whiley</title><link>https://davepearce.github.io/Homepage/publications/pg15_scp/</link><pubDate>Thu, 01 Jan 2015 00:00:00 +0000</pubDate><guid>https://davepearce.github.io/Homepage/publications/pg15_scp/</guid><description>Abstract. An ongoing challenge for computer science is the development of a tool which automati- cally verifies programs meet their specifications, and are free from runtime errors such as divide-by-zero, array out-of-bounds and null dereferences. Several impressive systems have been developed to this end, such as ESC/Java and Spec#, which build on existing programming languages (e.g., Java, C#). We have been developing a programming language from scratch to simplify verification, called Whiley, and an accompanying verifying compiler.</description></item><item><title>Integer Range Analysis for Whiley on Embedded Systems</title><link>https://davepearce.github.io/Homepage/publications/pea15_seus/</link><pubDate>Thu, 01 Jan 2015 00:00:00 +0000</pubDate><guid>https://davepearce.github.io/Homepage/publications/pea15_seus/</guid><description>Abstract: Programs written in the Whiley programming language are verified at compile-time to ensure all function specifications are met. The purpose of doing this is to eliminate as many software bugs as possible and, thus, Whiley is ideally suited for use in safety-critical systems. The language was designed from scratch to simplify verification as much as possible. To that end, arithmetic types in Whiley consist of unbounded integers and rationals and this poses a problem for use in memory constrained embedded devices.</description></item><item><title>Some Usability Hypotheses for Verification</title><link>https://davepearce.github.io/Homepage/publications/pea15_plateau/</link><pubDate>Thu, 01 Jan 2015 00:00:00 +0000</pubDate><guid>https://davepearce.github.io/Homepage/publications/pea15_plateau/</guid><description>Abstract: The idea of specifying and verifying software to eliminate errors has been studied extensively over the last three decades or more. Recent advances in automated theorem proving have given rise to a range of new verification tools being developed. Despite this, very little is known about the effect of using such tools on software development. In this paper, we present several verification-related usability hypotheses which we believe warrant further investigation.</description></item><item><title>The Whiley Rewrite Language (WyRL)</title><link>https://davepearce.github.io/Homepage/publications/pea15_sle/</link><pubDate>Thu, 01 Jan 2015 00:00:00 +0000</pubDate><guid>https://davepearce.github.io/Homepage/publications/pea15_sle/</guid><description>Abstract: The Whiley Rewrite Language (WyRL) is a standalone tool providing a domain-specific declarative rewrite language and code generator. The tool is currently used to generate a critical component of the Whiley verifying compiler, namely the automated theorem prover. The tool automatically generates Java source code from a given rule set. The runtime library provides support for different heuristics to control aspects of the generated system, such as the order in which rewrite rules are applied.</description></item><item><title>An Empirical Evaluation of Force-Directed Graph Layout</title><link>https://davepearce.github.io/Homepage/publications/klapaukh14_phd/</link><pubDate>Wed, 01 Jan 2014 00:00:00 +0000</pubDate><guid>https://davepearce.github.io/Homepage/publications/klapaukh14_phd/</guid><description/></item><item><title>Graceful Language Extensions and Interfaces</title><link>https://davepearce.github.io/Homepage/publications/homer14_phd/</link><pubDate>Wed, 01 Jan 2014 00:00:00 +0000</pubDate><guid>https://davepearce.github.io/Homepage/publications/homer14_phd/</guid><description/></item><item><title>Maintaining Private Views in Java</title><link>https://davepearce.github.io/Homepage/publications/haslett14_msc/</link><pubDate>Wed, 01 Jan 2014 00:00:00 +0000</pubDate><guid>https://davepearce.github.io/Homepage/publications/haslett14_msc/</guid><description/></item><item><title>Software Language Engineering - 7th International Conference</title><link>https://davepearce.github.io/Homepage/publications/cpbv14_sle/</link><pubDate>Wed, 01 Jan 2014 00:00:00 +0000</pubDate><guid>https://davepearce.github.io/Homepage/publications/cpbv14_sle/</guid><description>Proceedings of the 7th International Conference on Software Language Engineering (SLE)</description></item><item><title>Towards a Vertex and Edge Label Aware Force Directed Layout Algorithm</title><link>https://davepearce.github.io/Homepage/publications/kpm14_acsc/</link><pubDate>Wed, 01 Jan 2014 00:00:00 +0000</pubDate><guid>https://davepearce.github.io/Homepage/publications/kpm14_acsc/</guid><description/></item><item><title>A Calculus for Constraint-Based Flow Typing</title><link>https://davepearce.github.io/Homepage/publications/pea13_beat/</link><pubDate>Tue, 01 Jan 2013 00:00:00 +0000</pubDate><guid>https://davepearce.github.io/Homepage/publications/pea13_beat/</guid><description/></item><item><title>A Calculus for Constraint-Based Flow Typing</title><link>https://davepearce.github.io/Homepage/publications/pea13_ftfjp/</link><pubDate>Tue, 01 Jan 2013 00:00:00 +0000</pubDate><guid>https://davepearce.github.io/Homepage/publications/pea13_ftfjp/</guid><description>Abstract: Flow typing offers an alternative to traditional Hindley-Milner type inference. A key distinction is that variables may have different types at different program points. Flow typing systems are typically formalised in the style of a dataflow analysis. In the presence of loops, this requires a fix-point computation over typing environments. Unfortunately, for some flow typing problems, the standard iterative fix-point computation may not terminate. We formalise such a problem we encountered in developing the Whiley programming language, and present a novel constraint-based solution which is guaranteed to terminate.</description></item><item><title>Balloon Types for Safe Parallelisation over Arbitrary Object Graphs</title><link>https://davepearce.github.io/Homepage/publications/spgp13_wodet/</link><pubDate>Tue, 01 Jan 2013 00:00:00 +0000</pubDate><guid>https://davepearce.github.io/Homepage/publications/spgp13_wodet/</guid><description>Abstract: Safe parallelisation of object-oriented programs requires static guarantees about the shape and/or intended usage of reachable objects. For example, transitively immutable objects lend themselves naturally to concurrent access. However, parallelising tasks which potentially mutate reachable objects is more challenging. One approach to avoiding race conditions is to ensure the reachable object graphs of any concurrently executing tasks are disjoint. Numerous systems have been developed which provide guarantees of this kind (e.</description></item><item><title>OwnKit: Inferring Modularly Checkable Ownership Annotations for Java</title><link>https://davepearce.github.io/Homepage/publications/dpp13_aswec/</link><pubDate>Tue, 01 Jan 2013 00:00:00 +0000</pubDate><guid>https://davepearce.github.io/Homepage/publications/dpp13_aswec/</guid><description/></item><item><title>Reflections on Verifying Software with Whiley</title><link>https://davepearce.github.io/Homepage/publications/pg13_ftscs/</link><pubDate>Tue, 01 Jan 2013 00:00:00 +0000</pubDate><guid>https://davepearce.github.io/Homepage/publications/pg13_ftscs/</guid><description/></item><item><title>Sound and Complete Flow Typing with Unions, Intersections and Negations</title><link>https://davepearce.github.io/Homepage/publications/pea13_vmcai/</link><pubDate>Tue, 01 Jan 2013 00:00:00 +0000</pubDate><guid>https://davepearce.github.io/Homepage/publications/pea13_vmcai/</guid><description/></item><item><title>Whiley: a Platform for Research in Software Verification</title><link>https://davepearce.github.io/Homepage/publications/pg13_sle/</link><pubDate>Tue, 01 Jan 2013 00:00:00 +0000</pubDate><guid>https://davepearce.github.io/Homepage/publications/pg13_sle/</guid><description/></item><item><title>Patterns as Objects in Grace</title><link>https://davepearce.github.io/Homepage/publications/hnbbp12_dls/</link><pubDate>Sun, 01 Jan 2012 00:00:00 +0000</pubDate><guid>https://davepearce.github.io/Homepage/publications/hnbbp12_dls/</guid><description/></item><item><title>Profiling Field Initialization for Java</title><link>https://davepearce.github.io/Homepage/publications/npn12_rv/</link><pubDate>Sun, 01 Jan 2012 00:00:00 +0000</pubDate><guid>https://davepearce.github.io/Homepage/publications/npn12_rv/</guid><description/></item><item><title>Profiling Initialisation Behaviour in Java</title><link>https://davepearce.github.io/Homepage/publications/nelson12_phd/</link><pubDate>Sun, 01 Jan 2012 00:00:00 +0000</pubDate><guid>https://davepearce.github.io/Homepage/publications/nelson12_phd/</guid><description/></item><item><title>Formalisation and Implementation of an Algorithm for Bytecode Verification of @NonNull Types</title><link>https://davepearce.github.io/Homepage/publications/mppd11_scp/</link><pubDate>Sat, 01 Jan 2011 00:00:00 +0000</pubDate><guid>https://davepearce.github.io/Homepage/publications/mppd11_scp/</guid><description>Abstract. Java&amp;rsquo;s annotation mechanism allows us to extend its type system with non-null types. Checking such types cannot be done using the existing bytecode verification algorithm. We extend this algorithm to verify non-null types using a novel technique that identifies aliasing relationships between local variables and stack locations in the JVM. We formalise this for a subset of Java Bytecode and report on experiences using our implementation.</description></item><item><title>Implementing a Language with Flow-Sensitive and Structural Typing on the JVM</title><link>https://davepearce.github.io/Homepage/publications/pn11_bytecode/</link><pubDate>Sat, 01 Jan 2011 00:00:00 +0000</pubDate><guid>https://davepearce.github.io/Homepage/publications/pn11_bytecode/</guid><description>Abstract. Dynamically typed languages are flexible and impose few burdens on the programmer. In contrast, static typing leads to software that is more efficient and has fewer errors. However, static type systems traditionally require every variable to have one type, and that relationships between types (e.g. subclassing) be declared explicitly. The Whiley language aims to hit a sweet spot between dynamic and static typing. This is achieved through structural subtyping and by typing variables in a flow-sensitive fashion.</description></item><item><title>JPure: a Modular Purity System for Java</title><link>https://davepearce.github.io/Homepage/publications/pea11_cc/</link><pubDate>Sat, 01 Jan 2011 00:00:00 +0000</pubDate><guid>https://davepearce.github.io/Homepage/publications/pea11_cc/</guid><description>Abstract: Purity Analysis is the problem of determining whether or not a method may have side-effects. This has applications in automatic parallelisation, extended static checking, and more. We present a novel purity system for Java that employs purity annotations which can be checked modularly. This is done using a flow-sensitive, intraprocedural analysis. The system exploits two properties, called freshness and locality, to increase the range of methods that can be considered pure.</description></item><item><title>OwnKit: Ownership Inference for Java</title><link>https://davepearce.github.io/Homepage/publications/dymnikov11_msc/</link><pubDate>Sat, 01 Jan 2011 00:00:00 +0000</pubDate><guid>https://davepearce.github.io/Homepage/publications/dymnikov11_msc/</guid><description/></item><item><title>A Batch Algorithm for Maintaining a Topological Order</title><link>https://davepearce.github.io/Homepage/publications/pk10_acsc/</link><pubDate>Fri, 01 Jan 2010 00:00:00 +0000</pubDate><guid>https://davepearce.github.io/Homepage/publications/pk10_acsc/</guid><description/></item><item><title>Computing Tutte Polynomials</title><link>https://davepearce.github.io/Homepage/publications/hpr10_toms/</link><pubDate>Fri, 01 Jan 2010 00:00:00 +0000</pubDate><guid>https://davepearce.github.io/Homepage/publications/hpr10_toms/</guid><description>The Tutte polynomial of a graph is a 2-variable polynomial graph invariant of considerable impor- tance in both combinatorics and statistical physics. It contains several other polynomial invariants, such as the chromatic polynomial and flow polynomial as partial evaluations, and various numer- ical invariants such as the number of spanning trees as complete evaluations. However, despite its ubiquity, there are no widely-available effective computational tools able to compute the Tutte polynomial of a general graph of reasonable size.</description></item><item><title>Edge-Selection Heuristics for Computing Tutte Polynomials</title><link>https://davepearce.github.io/Homepage/publications/phr10_cjtcs/</link><pubDate>Fri, 01 Jan 2010 00:00:00 +0000</pubDate><guid>https://davepearce.github.io/Homepage/publications/phr10_cjtcs/</guid><description>Abstract. The Tutte polynomial of a graph, also known as the partition function of theq-statePotts model, is a 2-variable polynomial graph invariant of considerable importance in bothcombinatorics and statistical physics. It contains several other polynomial invariants, such asthe chromatic polynomial and flow polynomial as partial evaluations, and various numericalinvariants such as the number of spanning trees as complete evaluations. We have developedthe most efficient algorithm to-date for computing the Tutte polynomial of a graph.</description></item><item><title>Understanding the Impact of Collection Contracts on Design</title><link>https://davepearce.github.io/Homepage/publications/npn10_tools/</link><pubDate>Fri, 01 Jan 2010 00:00:00 +0000</pubDate><guid>https://davepearce.github.io/Homepage/publications/npn10_tools/</guid><description/></item><item><title>Edge-Selection Heuristics for Computing Tutte Polynomials</title><link>https://davepearce.github.io/Homepage/publications/phr09_cats/</link><pubDate>Thu, 01 Jan 2009 00:00:00 +0000</pubDate><guid>https://davepearce.github.io/Homepage/publications/phr09_cats/</guid><description/></item><item><title>Implementing relationships using Affinity</title><link>https://davepearce.github.io/Homepage/publications/npn09_raool/</link><pubDate>Thu, 01 Jan 2009 00:00:00 +0000</pubDate><guid>https://davepearce.github.io/Homepage/publications/npn09_raool/</guid><description/></item><item><title>Mocha: Type Inference for Java</title><link>https://davepearce.github.io/Homepage/publications/male09_msc/</link><pubDate>Thu, 01 Jan 2009 00:00:00 +0000</pubDate><guid>https://davepearce.github.io/Homepage/publications/male09_msc/</guid><description/></item><item><title>Caching and Incrementalisation for the Java Query Language</title><link>https://davepearce.github.io/Homepage/publications/wpn08_oopsla/</link><pubDate>Tue, 01 Jan 2008 00:00:00 +0000</pubDate><guid>https://davepearce.github.io/Homepage/publications/wpn08_oopsla/</guid><description>Abstract: Many contemporary object-oriented programming languages support first-class queries or comprehensions. These language extensions make it easier for programmers to write queries, but are generally implemented no more efficiently than the code using collections, iterators, and loops that they replace. Crucially, whenever a query is re-executed, it is recomputed from scratch. We describe a general approach to optimising queries over mutable objects: query results are cached, and those caches are incrementally maintained whenever the collections and objects underlying those queries are updated.</description></item><item><title>Implementing First-Class Relationships in Java</title><link>https://davepearce.github.io/Homepage/publications/npn08_raool/</link><pubDate>Tue, 01 Jan 2008 00:00:00 +0000</pubDate><guid>https://davepearce.github.io/Homepage/publications/npn08_raool/</guid><description/></item><item><title>Introducing Software Modelling with Alloy at VUW</title><link>https://davepearce.github.io/Homepage/publications/npg08_formed/</link><pubDate>Tue, 01 Jan 2008 00:00:00 +0000</pubDate><guid>https://davepearce.github.io/Homepage/publications/npg08_formed/</guid><description/></item><item><title>Java Bytecode Verification for @NonNull Types</title><link>https://davepearce.github.io/Homepage/publications/mppd08_cc/</link><pubDate>Tue, 01 Jan 2008 00:00:00 +0000</pubDate><guid>https://davepearce.github.io/Homepage/publications/mppd08_cc/</guid><description/></item><item><title>Object State Querying for Optimisation</title><link>https://davepearce.github.io/Homepage/publications/pn08_mpool/</link><pubDate>Tue, 01 Jan 2008 00:00:00 +0000</pubDate><guid>https://davepearce.github.io/Homepage/publications/pn08_mpool/</guid><description/></item><item><title>Patterns for ADT Optimisation</title><link>https://davepearce.github.io/Homepage/publications/pn08_plop/</link><pubDate>Tue, 01 Jan 2008 00:00:00 +0000</pubDate><guid>https://davepearce.github.io/Homepage/publications/pn08_plop/</guid><description>Abstract: Operations on abstract data types can be classified as either queries or updates — those that either query the current state, or update it. Modern object-oriented programming languages require classes/interfaces to support a predefined set of such operations. This presents a challenge for software designers, since a fixed interface can severely restrict the opportunities for optimisation. In this paper, we present two common patterns — Specific Query Optimisation and Generalised Query Optimisation — for optimising such operations.</description></item><item><title>The Java Query Language</title><link>https://davepearce.github.io/Homepage/publications/willis08_msc/</link><pubDate>Tue, 01 Jan 2008 00:00:00 +0000</pubDate><guid>https://davepearce.github.io/Homepage/publications/willis08_msc/</guid><description/></item><item><title>Visualizing the computation tree of the Tutte Polynomial</title><link>https://davepearce.github.io/Homepage/publications/tpah08_softviz/</link><pubDate>Tue, 01 Jan 2008 00:00:00 +0000</pubDate><guid>https://davepearce.github.io/Homepage/publications/tpah08_softviz/</guid><description/></item><item><title>A Dynamic Topological Sort Algorithm for Directed Acyclic Graphs</title><link>https://davepearce.github.io/Homepage/publications/pk07_jea/</link><pubDate>Mon, 01 Jan 2007 00:00:00 +0000</pubDate><guid>https://davepearce.github.io/Homepage/publications/pk07_jea/</guid><description>Abstract. We consider the problem of maintaining the topological order of a directed acyclic graph (DAG) in the presence of edge insertions and deletions. We present a new algorithm and, although this has inferior time complexity compared with the best previously known result, we find that its simplicity leads to better performance in practice. In addition, we provide an empirical comparison against the three main alternatives over a large number of random DAGs.</description></item><item><title>Efficient Field-Sensitive Pointer Analysis for C</title><link>https://davepearce.github.io/Homepage/publications/pkh07_toplas/</link><pubDate>Mon, 01 Jan 2007 00:00:00 +0000</pubDate><guid>https://davepearce.github.io/Homepage/publications/pkh07_toplas/</guid><description>Abstract. The subject of this paper is flow- and context-insensitive pointer analysis. We present a novel approach for precisely modelling struct variables and indirect function calls. Our method em- phasises efficiency and simplicity and is based on a simple language of set constraints. We obtain an O(v^4) bound on the time needed to solve a set of constraints from this language, where v is the number of constraint variables. This gives, for the first time, some insight into the hardness of performing field-sensitive pointer analysis of C.</description></item><item><title>Patterns of Aspect-Oriented Design</title><link>https://davepearce.github.io/Homepage/publications/nspb07_europlop/</link><pubDate>Mon, 01 Jan 2007 00:00:00 +0000</pubDate><guid>https://davepearce.github.io/Homepage/publications/nspb07_europlop/</guid><description/></item><item><title>Profiling with AspectJ</title><link>https://davepearce.github.io/Homepage/publications/pwbk07_spe/</link><pubDate>Mon, 01 Jan 2007 00:00:00 +0000</pubDate><guid>https://davepearce.github.io/Homepage/publications/pwbk07_spe/</guid><description>Abstract. This paper investigates whether AspectJ can be used for efficient profiling of Java programs. Profiling differs from other applications of AOP (e.g. tracing), since it necessitates efficient and often complex interactions with the target program. As such, it was uncertain whether AspectJ could achieve this goal. Therefore, we investigate four common profiling problems (heap usage, object lifetime, wasted time and time-spent) and report on how well AspectJ handles them. For each, we provide an efficient implementation, discuss any trade-offs or limitations and present the results of an experimental evaluation into the costs of using it.</description></item><item><title>Visualising the Tutte Polynomial Computation</title><link>https://davepearce.github.io/Homepage/publications/tph07_sienz/</link><pubDate>Mon, 01 Jan 2007 00:00:00 +0000</pubDate><guid>https://davepearce.github.io/Homepage/publications/tph07_sienz/</guid><description>Abstract: The Tutte polynomial is an important concept in graph theory which captures many important properties of graphs (e.g. chromatic number, number of spanning trees etc). It also provides a normalised representation that can be used as an equivalence relation on graphs and has applications in diverse areas such micro-biology and physics. A highly efficient algorithm for computing Tutte polynomials has been elsewhere developed by Haggard and Pearce. This relies on various optimisations and heuristics to improve performance; however, understanding the effect of a particular heuristic remains challenging, since the computation trees involved are very large.</description></item><item><title>AspectJ for Multilevel Security</title><link>https://davepearce.github.io/Homepage/publications/rpw06_acp4is/</link><pubDate>Sun, 01 Jan 2006 00:00:00 +0000</pubDate><guid>https://davepearce.github.io/Homepage/publications/rpw06_acp4is/</guid><description>Abstract: A multilevel security (MLS) system has two primary goals: first, it is intended to prevent unauthorised personnel from accessing information at higher classification than their authorisation. Second, it is intended to prevent personnel from declassifying information. Using an object-oriented approach to implementing MLS results not only with the problem of code scattering and code tangling, but also results in weaker enforcement of security. This weaker enforcement of security could be due to the inherent design of the system or due to a programming error.</description></item><item><title>Efficient Object Querying for Java</title><link>https://davepearce.github.io/Homepage/publications/wpn06_ecoop/</link><pubDate>Sun, 01 Jan 2006 00:00:00 +0000</pubDate><guid>https://davepearce.github.io/Homepage/publications/wpn06_ecoop/</guid><description>Abstract: Modern programming languages have little or no support for querying objects and collections. Programmers are forced to hand code such queries using nested loops, which is both cumbersome and inefficient. We demonstrate that first-class queries over objects and collections improve program readability, provide good performance and are applicable to a large number of common programming problems. We have developed a prototype extension to Java which tracks all objects in a program using AspectJ and allows first-class queries over them in the program.</description></item><item><title>Relationship Aspect Patterns</title><link>https://davepearce.github.io/Homepage/publications/pn06_europlop/</link><pubDate>Sun, 01 Jan 2006 00:00:00 +0000</pubDate><guid>https://davepearce.github.io/Homepage/publications/pn06_europlop/</guid><description/></item><item><title>Relationship Aspects</title><link>https://davepearce.github.io/Homepage/publications/pn06_aosd/</link><pubDate>Sun, 01 Jan 2006 00:00:00 +0000</pubDate><guid>https://davepearce.github.io/Homepage/publications/pn06_aosd/</guid><description/></item><item><title>Towards a Semiotics of Object- and Aspect-Oriented Design</title><link>https://davepearce.github.io/Homepage/publications/nbtp06_ecap/</link><pubDate>Sun, 01 Jan 2006 00:00:00 +0000</pubDate><guid>https://davepearce.github.io/Homepage/publications/nbtp06_ecap/</guid><description/></item><item><title>Some directed graph algorithms and their application to pointer analysis.</title><link>https://davepearce.github.io/Homepage/publications/pearce05_phd/</link><pubDate>Sat, 01 Jan 2005 00:00:00 +0000</pubDate><guid>https://davepearce.github.io/Homepage/publications/pearce05_phd/</guid><description>Abstract: This thesis is focused on improving execution time and precision of scalable pointer analysis. Such an analysis statically determines the targets of all pointer variables in a program. We formulate the analysis as a directed graph problem, where the solution can be obtained by a computation similar, in many ways, to transitive closure. As with transitive closure, identifying strongly connected components and transitive edges offers significant gains. However, our problem differs as the computation can result in new edges being added to the graph and, hence, dynamic algorithms are needed to efficiently identify these structures.</description></item><item><title>A Dynamic Algorithm for Topologically Sorting Directed Acyclic Graphs</title><link>https://davepearce.github.io/Homepage/publications/pk04_wea/</link><pubDate>Thu, 01 Jan 2004 00:00:00 +0000</pubDate><guid>https://davepearce.github.io/Homepage/publications/pk04_wea/</guid><description/></item><item><title>Automating Optimized Table-with-Polynomial Function Evaluation for FPGAs</title><link>https://davepearce.github.io/Homepage/publications/lmpl04_fpl/</link><pubDate>Thu, 01 Jan 2004 00:00:00 +0000</pubDate><guid>https://davepearce.github.io/Homepage/publications/lmpl04_fpl/</guid><description/></item><item><title>Efficient Field-Sensitive Pointer Analysis for C</title><link>https://davepearce.github.io/Homepage/publications/pkh04_paste/</link><pubDate>Thu, 01 Jan 2004 00:00:00 +0000</pubDate><guid>https://davepearce.github.io/Homepage/publications/pkh04_paste/</guid><description/></item><item><title>Online Cycle Detection and Difference Propagation: Applications to Pointer Analysis</title><link>https://davepearce.github.io/Homepage/publications/pkh04_sqj/</link><pubDate>Thu, 01 Jan 2004 00:00:00 +0000</pubDate><guid>https://davepearce.github.io/Homepage/publications/pkh04_sqj/</guid><description>Abstract. This paper presents and evaluates a number of techniques to improve the execution time of interprocedural pointer analysis in the context of C programs. The analysis is formulated as a graph of set constraintsand solved using a worklist algorithm. Indirections lead to new constraints being added during this procedure.The solution process can be simplified by identifying cycles, and we present a novel online algorithm for doingthis. We also present a difference propagation scheme which avoids redundant work by tracking changes to eachsolution set.</description></item><item><title>Design Space Exploration with A Stream Compiler</title><link>https://davepearce.github.io/Homepage/publications/mphl03_fpt/</link><pubDate>Wed, 01 Jan 2003 00:00:00 +0000</pubDate><guid>https://davepearce.github.io/Homepage/publications/mphl03_fpt/</guid><description/></item><item><title>Online Cycle Detection and Difference Propagation for Pointer Analysis</title><link>https://davepearce.github.io/Homepage/publications/pkh03_scam/</link><pubDate>Wed, 01 Jan 2003 00:00:00 +0000</pubDate><guid>https://davepearce.github.io/Homepage/publications/pkh03_scam/</guid><description>Abstract.</description></item><item><title>GILK: A Dynamic Instrumentation Tool for the Linux Kernel</title><link>https://davepearce.github.io/Homepage/publications/pkfh02_tools/</link><pubDate>Tue, 01 Jan 2002 00:00:00 +0000</pubDate><guid>https://davepearce.github.io/Homepage/publications/pkfh02_tools/</guid><description/></item></channel></rss>