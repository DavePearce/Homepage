<!doctype html><html><head><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><title>Profiling with AspectJ</title><link href="https://fonts.googleapis.com/css?family=Neucha" rel=stylesheet><link rel=stylesheet href=https://davepearce.github.io/Homepage/css/style.css></head><body><header><div id=name><b>Dr. David J. Pearce</b>, <i>Associate Professor of Computer Science</i></div><nav><ul id=menubar><li><a href=https://davepearce.github.io/Homepage/>Home</a></li><li><a href=https://davepearce.github.io/Homepage/projects/>Projects</a></li><li><a href=https://davepearce.github.io/Homepage/publications/>Publications</a></li></ul></nav></header><div id=container><div id=content><h1>Profiling with AspectJ</h1><p><strong>Abstract.</strong> This paper investigates whether AspectJ can be used for efficient profiling of Java programs. Profiling differs from other applications of AOP (e.g. tracing), since it necessitates efficient and often complex interactions with the target program. As such, it was uncertain whether AspectJ could achieve this goal. Therefore, we investigate four common profiling problems (heap usage, object lifetime, wasted time and time-spent) and report on how well AspectJ handles them. For each, we provide an efficient implementation, discuss any trade-offs or limitations and present the results of an experimental evaluation into the costs of using it. Our conclusions are mixed. On the one hand, we find that AspectJ is sufficiently expressive to describe the four profiling problems and reasonably efficient in most cases. On the other hand, we find several limitations with the current AspectJ implementation that severely hamper its suitability for profiling.</p></div></div></body></html>