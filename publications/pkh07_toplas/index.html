<!doctype html><html><head><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><title>Efficient Field-Sensitive Pointer Analysis for C</title><link rel=stylesheet href=https://davepearce.github.io/Homepage/css/page.css><link rel=stylesheet href=https://davepearce.github.io/Homepage/css/menu.css><link rel=stylesheet href=https://davepearce.github.io/Homepage/css/style.css></head><body><script>function toggleMenu(){var content=document.getElementById("menu-content");if(content.style.display==='none'){content.style.display='block';}else{content.style.display='none';}}</script><header class=topbar><div class=name><b>Dr. David J. Pearce</b><i>, Associate Professor of Computer Science</i></div><nav><div id=menu onclick=toggleMenu();><img src=https://davepearce.github.io/Homepage//images/menu.png><div id=menu-content><a href=https://davepearce.github.io/Homepage/>Home</a>
<a href=https://davepearce.github.io/Homepage/projects/>Projects</a>
<a href=https://davepearce.github.io/Homepage/publications/>Publications</a></div></div></nav></header><div class=container><div class=content><h1>Efficient Field-Sensitive Pointer Analysis for C</h1><p><strong>Abstract.</strong> The subject of this paper is flow- and context-insensitive pointer analysis. We present a novel approach for precisely modelling struct variables and indirect function calls. Our method em- phasises efficiency and simplicity and is based on a simple language of set constraints. We obtain an <code>O(v^4)</code> bound on the time needed to solve a set of constraints from this language, where v is the number of constraint variables. This gives, for the first time, some insight into the hardness of performing field-sensitive pointer analysis of C. Furthermore, we experimentally evaluate the time versus precision trade-off for our method by comparing against the field-insensitive equivalent. Our benchmark suite consists of 11 common C programs ranging in size from 15,000 to 200,000 lines of code. Our results indicate the field-sensitive analysis is more expensive to compute, but yields significantly better precision. In addition, our technique has been integrated into the latest release (version 4.1) of the GNU Compiler GCC. Finally, we identify several previously unknown issues with an alternative and less precise approach to modelling struct variables, known as field-based analysis.</p><p><strong>Notes.</strong> This algorithm is currently used in the <a href=https://github.com/gcc-mirror/gcc/blob/master/gcc/tree-ssa-structalias.c>GNU C Compiler (GCC)</a> and in the <a href=https://github.com/golang/tools/blob/master/go/pointer/doc.go>godoc</a> tool for <a href=https://golang.org>Go</a>. An implementation of the algorithm in C++ is availale <a href=../../files/pcs-2.1-060204-01.tgz>here</a>. You can also find discussion of the GCC implementation in this paper: <em>Structure Aliasing in GCC</em> by Dan Berlin, in <em>Proceedings of the GCC Developers Summit</em>, 2005 <a href="https://gcc.gnu.org/wiki/HomePage?action=AttachFile&do=get&target=2005-GCC-Summit-Proceedings.pdf">PDF</a>.</p></div></div></body></html>