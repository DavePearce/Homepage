<!doctype html><html><head><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><title>Computing Tutte Polynomials</title><link href="https://fonts.googleapis.com/css?family=Neucha" rel=stylesheet><link rel=stylesheet href=https://davepearce.github.io/Homepage/css/style.css></head><body><header><div id=name><b>Dr. David J. Pearce</b>, <i>Associate Professor of Computer Science</i></div><nav><ul id=menubar><li><a href=https://davepearce.github.io/Homepage/>Home</a></li><li><a href=https://davepearce.github.io/Homepage/projects/>Projects</a></li><li><a href=https://davepearce.github.io/Homepage/publications/>Publications</a></li></ul></nav></header><div id=container><div id=content><h1>Computing Tutte Polynomials</h1><p><strong>Abstract:</strong> The <a href=https://en.wikipedia.org/wiki/Tutte_polynomial>Tutte polynomial</a> of a graph is a 2-variable polynomial graph invariant of considerable importance in both combinatorics and statistical physics. It contains several other polynomial invariants, such as the chromatic polynomial and flow polynomial as partial evaluations, and various numerical invariants such as the number of spanning trees as complete evaluations. However, despite its ubiquity, there are no widely-available effective computational tools able to compute the Tutte polynomial of a general graph of reasonable size. In this paper we describe the implementation of an algorithm that exploits isomorphisms in the computation tree to extend the range of graphs for which it is feasible to compute their Tutte polynomials, and we demonstrate the utility of the program by finding counterexamples to a conjecture of Welsh on the location of the real flow roots of a graph.</p><p><strong>Notes.</strong> The latest version of my C++ implementation is available <a href=../../files/tuttepoly-v0.9.18.tgz>here</a> and also on <a href=https://github.com/DavePearce/TuttePoly>GitHub</a>. A Java implementation is maintained separately <a href=https://github.com/klapaukh/JTuttePoly>here</a>. Finally, the algorithm has also been incorporated into both <a href=https://mathworld.wolfram.com/TuttePolynomial.html>Mathematica</a> and <a href=https://doc.sagemath.org/html/en/reference/graphs/sage/graphs/tutte_polynomial.html>Sage</a>.</p><p><strong>History.</strong> The code released was originally based on that by Prof. Gary Haggard from Bucknell. He had developed a version in C over several years which was very efficient. Gary was visiting me at Victoria University of Wellington in 2007, and we decided to reimplemented his code in C++. This proved beneficial, since the new version is more modular and extensible. New features added included a proper cache replacement system + heuristics, different edge-selection heuristics and the ability to break up an intermediate graph when it is no longer biconnected. Since then, <a href=https://github.com/DavePearce/DynamicTopologicalSort>Prof Gordon Royle</a> provided lots of help with the design and development of the tool; he has also been using it to investigate flow polynomials, and recently discovered a counter-example to a 25-year old conjecture by Dominic Welsh. More recently, in 2009, Gary an myself computed the Tutte polynomial of the <a href=http://en.wikipedia.org/wiki/Truncated_icosahedron>Truncated Icosahedron</a>, which represents something of a landmark for us. This took about one week to compute on a grid of 150 machines and, for those particularly interested in such things, the polynomial is <a href=../../files/ti_poly.txt>here</a> and some more information can be found <a href=../../publications/TI10.pdf>here</a>.</p></div></div></body></html>