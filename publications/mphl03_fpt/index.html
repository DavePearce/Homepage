<!doctype html><html><head><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><title>Design Space Exploration with A Stream Compiler</title><link href="https://fonts.googleapis.com/css?family=Neucha" rel=stylesheet><link rel=stylesheet href=https://davepearce.github.io/Homepage/css/style.css></head><body><header><div id=name><b>Dr. David J. Pearce</b>, <i>Associate Professor of Computer Science</i></div><nav><ul id=menubar><li><a href=https://davepearce.github.io/Homepage/>Home</a></li><li><a href=https://davepearce.github.io/Homepage/projects/>Projects</a></li><li><a href=https://davepearce.github.io/Homepage/publications/>Publications</a></li></ul></nav></header><div class=container><div id=content><h1>Design Space Exploration with A Stream Compiler</h1><p><strong>Abstract:</strong> We consider speeding up general-purpose applications with hardware accelerators. Traditionally hardware accelera- tors are tediously hand-crafted to achieve top performance. ASC (A Stream Compiler) simplifies exploration of hard- ware accelerators by transforming the hardware design task into a software design process using only ’gcc’ and ’make’ to obtain a hardware netlist. ASC enables programmers to customize hardware accelerators at three levels of abstraction: the architecture level, the functional block level, and the bit level. All three customizations are based on one uniform representation: a single C++ program with custom types and operators for each level of abstraction.
This representation allows ASC users to express and reason about the design space, extract parallelism at each level and quickly evaluate different design choices. In addition, since the user has full control over each gate-level resource in the entire design, ASC accelerator performance can always be equal to or better than hand-crafted designs, usually with much less effort. We present several ASC benchmarks, including wavelet compression and Kasumi encryption.</p></div></div></body></html>