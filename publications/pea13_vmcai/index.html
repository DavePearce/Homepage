<!doctype html><html><head><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><title>Sound and Complete Flow Typing with Unions, Intersections and Negations</title><link rel=stylesheet href=https://davepearce.github.io/Homepage/css/page.css><link rel=stylesheet href=https://davepearce.github.io/Homepage/css/menu.css><link rel=stylesheet href=https://davepearce.github.io/Homepage/css/style.css></head><body><script>function toggleMenu(){var content=document.getElementById("menu-content");var menu=document.getElementById("menu");if(content.style.display==='block'){content.style.display='none';menu.style.filter='';}else{content.style.display='block';menu.style.filter="brightness(0.8)";}}
function clearMenu(){document.getElementById("menu-content").style.display='none';document.getElementById("menu").style.filter='';}</script><header class=topbar><div class=topbar-title>Dr. David J. Pearce</div><div class=topbar-subtitle>Associate Professor of Computer Science</div><div class=topbar-menu onclick=toggleMenu();><div id=menu onclick=toggleMenu();><div id=menu-icon onclick=toggleMenu();></div><div id=menu-content><a href=https://davepearce.github.io/Homepage/>Home</a>
<a href=https://davepearce.github.io/Homepage/projects/>Projects</a>
<a href=https://davepearce.github.io/Homepage/publications/>Publications</a></div></div></div></header><div class=container><div class=content><h1>Sound and Complete Flow Typing with Unions, Intersections and Negations</h1><p><strong>Abstract:</strong> Flow typing is becoming a popular mechanism for typing existing programs written in untyped languages (e.g. JavaScript, Racket, Groovy). Such systems require intersections for the true-branch of a type test, negations for the false-branch, and unions to capture the flow of information at meet points. Type systems involving unions, intersections and negations require a subtype operator which is non-trivial to implement. Frisch et al. demonstrated that this problem was decidable. However, their proof was not constructive and does not lend itself naturally to an implementation. In this paper, we present a sound and complete algorithm for subtype testing in the presence of unions, intersections and negations.</p></div></div><script></script></body></html>