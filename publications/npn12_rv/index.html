<!doctype html><html><head><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><title>Profiling Field Initialization for Java</title><link href="https://fonts.googleapis.com/css?family=Neucha" rel=stylesheet><link rel=stylesheet href=https://davepearce.github.io/Homepage/css/style.css></head><body><header><div id=name>A/Prof. David J. Pearce</div><nav><ul id=menubar><li><a href=https://davepearce.github.io/Homepage/>Home</a></li><li><a href=https://davepearce.github.io/Homepage/projects/>Projects</a></li><li><a href=https://davepearce.github.io/Homepage/publications/>Publications</a></li></ul></nav></header><div id=container><div id=content><h1>Profiling Field Initialization for Java</h1><p><strong>Abstract:</strong> Java encourages programmers to use constructor methods to initialise objects, supports final modifiers for documenting fields which are never modified and employs static checking to ensure such fields are only ever initialised inside constructors. Unkel and Lam observed that relatively few fields are actually declared final and showed using static analysis that many more fields have final behaviour, and even more fields are stationary (i.e. all writes occur before all reads). We present results from a runtime analysis of 14 real-world Java programs which not only replicates Unkel and Lamâ€™s results, but suggests their analysis may have under-approximated the true figure. Our results indicate a remarkable 72-82% of fields are stationary, that final is poorly utilised by Java programmers, and that initialisation of immutable fields frequently occurs after constructor return. This suggests that the final modifier for fields does a poor job of supporting common programming practices.</p></div></div></body></html>