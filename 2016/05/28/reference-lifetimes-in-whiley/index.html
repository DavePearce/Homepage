<!doctype html><html lang=en><head><script async src="https://www.googletagmanager.com/gtag/js?id=G-9MRLB1FVZX"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-9MRLB1FVZX",{anonymize_ip:!1})}</script><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta property="og:title" content="Reference Lifetimes in Whiley"><meta name=twitter:title content="Reference Lifetimes in Whiley"><meta property="og:url" content="https://whileydave.com/2016/05/28/reference-lifetimes-in-whiley/"><title>David J. Pearce
(Reference Lifetimes in Whiley)</title><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css><link rel=stylesheet href=https://whileydave.com/css/page.css><link rel=stylesheet href=https://whileydave.com/css/menu.css><link rel=stylesheet href=https://whileydave.com/css/style.css><link rel=stylesheet href=https://whileydave.com/css/syntax.css></head><body><script>"use strict";function clearMenu(){var e,t,n=window.matchMedia("(max-width: 992px)");n.matches&&(e=document.getElementById("menu-content"),t=document.getElementById("menu"),e.style.display="none",t.style.filter="")}function toggleMenu(){var e,t,n=window.matchMedia("(max-width: 992px)");n.matches&&(e=document.getElementById("menu-content"),t=document.getElementById("menu"),e.style.display==="block"?(e.style.display="none",t.style.filter=""):(e.style.display="block",t.style.filter="brightness(0.8)"))}function toggleList(e){e.style.display="none";for(var t,o=e.parentNode,s=o.childNodes,n=0;n<s.length;++n)t=s[n],t.classList&&t.classList.contains("hidden")&&(t.style.display==="block"?t.style.display="none":t.style.display="block")}</script><header class=topbar><div class=topbar-header onclick=clearMenu()><div class=topbar-title>Dr. David J. Pearce</div><div class=topbar-subtitle></div></div><div class=topbar-social onclick=clearMenu()><a href=https://github.com/DavePearce><i class="fa fa-github" aria-hidden=true></i></a>
<a href=https://twitter.com/WhileyDave><i class="fa fa-twitter" aria-hidden=true></i></a>
<a href=https://www.youtube.com/user/redjamjar/><i class="fa fa-youtube-play" aria-hidden=true></i></a>
<a href=https://www.linkedin.com/in/david-pearce-8592647/><i class="fa fa-linkedin-square" aria-hidden=true></i></a></div><div class=topbar-menu><div id=menu onclick=toggleMenu()><div id=menu-icon><img src=https://whileydave.com/images/menu.png alt=Menu></div><div id=menu-content><a href=https://whileydave.com/blog/>Blog</a>
<a href=https://whileydave.com/projects/>Projects</a>
<a href=https://whileydave.com/publications/>Publications</a>
<a href=https://whileydave.com/talks/>Talks</a>
<a href=https://whileydave.com/>Home</a></div></div></div></header><div class=container onclick=clearMenu()><div class=content><h1 class=post-title>Reference Lifetimes in Whiley</h1><div class=post-date>Saturday, May
28th,
2016</div><hr><p>The concept of <a href=https://doc.rust-lang.org/book/lifetimes.html>lifetimes</a> was pioneered in the Rust programming language, and builds on earlier notions of <a href=https://en.wikipedia.org/wiki/Region-based_memory_management>regions</a> and ownership types. Lifetimes are considered one of Rust&rsquo;s &ldquo;most unique and compelling features&rdquo;.</p><p>Recently, the concept of reference lifetimes has been added to Whiley by Sebastian Schweizer (<a href=https://github.com/SebastianS90>@SebastianS90</a>). In this post, I&rsquo;m going to try and summarise the basic idea and how it looks in Whiley. To start with, let&rsquo;s consider the following (broken) program written in C:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=o>*</span><span class=nf>getPointer</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>local</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=o>&amp;</span><span class=n>local</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This method returns the address of a local variable thereby creating a <em><a href=https://en.wikipedia.org/wiki/Dangling_pointer>dangling pointer</a></em>. We say that the returned pointer <em>outlives</em> the lifetime of the data it refers to.  The purpose of reference lifetimes is to ensure <em>dangling pointers cannot be created</em>. Or, put it another way, to ensure memory deallocation <em>can be handled safely without a garbage collector</em>.</p><h2 id=lifetime-syntax>Lifetime Syntax</h2><p>In Whiley, we can&rsquo;t take the address of a local variable so we cannot exactly recreate the above example. A similar example using the new lifetime syntax would be:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl><span class=kd>method</span> <span class=n>getReference</span><span class=p>()</span> <span class=o>-&gt;</span> <span class=o>&amp;</span><span class=kt>int</span><span class=o>:</span>
</span></span><span class=line><span class=cl>   <span class=o>&amp;</span><span class=n>this</span><span class=o>:</span><span class=kt>int</span> <span class=n>local</span> <span class=o>=</span> <span class=n>this</span><span class=o>:</span><span class=k>new</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>   <span class=k>return</span> <span class=n>local</span>
</span></span></code></pre></div><p>This defines a simple method which allocates a new integer on the heap and returns a reference to it. As expected, this example now produces a compile-time error. This is because the reference <code>local</code> is declared to have lifetime <code>this</code>. This means the data to which it refers has the same lifetime as the enclosing method and, hence, we cannot return a reference to it.</p><p>Previously Whiley supported references without lifetimes. For example, we would have declared <code>local</code> above to be <code>&int</code> rather than <code>&this:int</code>. Since there is no deallocation primitive in Whiley, this meant that all heap allocated data had to be garbage collected. With lifetimes we can now avoid garbage collection when we want to (e.g. on an embedded system). However, Whiley still supports references of the form <code>&int</code>. These are now syntactic sugar for <code>&*:int</code>, where <code>*</code> is the &ldquo;global&rdquo; lifetime.</p><h2 id=lifetime-parameters>Lifetime Parameters</h2><p>Like Rust, Whiley allows methods to declare <em>lifetime parameters</em>. The following illustrates:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl><span class=kd>method</span> <span class=o>&lt;</span><span class=n>l1</span><span class=p>,</span><span class=n>l2</span><span class=o>&gt;</span> <span class=n>swap</span><span class=p>(</span><span class=o>&amp;</span><span class=n>l1</span><span class=o>:</span><span class=kt>int</span> <span class=n>r1</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>l2</span><span class=o>:</span><span class=kt>int</span> <span class=n>r2</span><span class=p>)</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>tmp</span> <span class=o>=</span> <span class=o>*</span><span class=n>r1</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=n>r1</span> <span class=o>=</span> <span class=o>*</span><span class=n>r2</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=n>r2</span> <span class=o>=</span> <span class=n>tmp</span>
</span></span></code></pre></div><p>The above method accepts two references of lifetimes <code>l1</code> and <code>l2</code>. These lifetimes must be provided as arguments when calling the method, so the body can just assume they exist. For example, we could call the method as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl><span class=kd>method</span> <span class=n>caller</span><span class=p>()</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=o>&amp;</span><span class=n>this</span><span class=o>:</span><span class=kt>int</span> <span class=n>i1</span> <span class=o>=</span> <span class=n>this</span><span class=o>:</span><span class=k>new</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=o>&amp;</span><span class=n>this</span><span class=o>:</span><span class=kt>int</span> <span class=n>i2</span> <span class=o>=</span> <span class=n>this</span><span class=o>:</span><span class=k>new</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>    <span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>swap</span><span class=o>&lt;</span><span class=n>this</span><span class=p>,</span><span class=n>this</span><span class=o>&gt;</span><span class=p>(</span><span class=n>i1</span><span class=p>,</span><span class=n>i2</span><span class=p>)</span>
</span></span></code></pre></div><p>Here, we&rsquo;ve created two references with lifetime <code>this</code> and passed them into <code>swap()</code>, providing <code>this</code> as the lifetime argument.</p><p>Whiley also now supports the notion of <em>named blocks</em>, which can be used for identifying a subscope within a method.  For example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl><span class=kd>method</span> <span class=n>caller</span><span class=p>()</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=o>&amp;</span><span class=n>this</span><span class=o>:</span><span class=kt>int</span> <span class=n>i1</span> <span class=o>=</span> <span class=n>this</span><span class=o>:</span><span class=k>new</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=n>inner</span><span class=o>:</span>
</span></span><span class=line><span class=cl>       <span class=o>&amp;</span><span class=n>inner</span><span class=o>:</span><span class=kt>int</span> <span class=n>i2</span> <span class=o>=</span> <span class=n>inner</span><span class=o>:</span><span class=k>new</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>       <span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>       <span class=n>swap</span><span class=o>&lt;</span><span class=n>this</span><span class=p>,</span><span class=n>inner</span><span class=o>&gt;</span><span class=p>(</span><span class=n>i1</span><span class=p>,</span><span class=n>i2</span><span class=p>)</span>
</span></span></code></pre></div><p>Here, the <code>inner</code> scope identifies a smaller lifetime than that of the enclosing method. We say that <code>inner</code> is <em>outlived</em> by the lifetime of method body (<code>this</code>).</p><h2 id=lifetime-inference>Lifetime Inference</h2><p>The Whiley compiler will try to infer lifetime arguments where possible. For example, the above method <code>caller()</code> can be written as:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl><span class=kd>method</span> <span class=n>caller</span><span class=p>()</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=o>&amp;</span><span class=n>this</span><span class=o>:</span><span class=kt>int</span> <span class=n>i1</span> <span class=o>=</span> <span class=n>this</span><span class=o>:</span><span class=k>new</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=n>inner</span><span class=o>:</span>
</span></span><span class=line><span class=cl>       <span class=o>&amp;</span><span class=n>inner</span><span class=o>:</span><span class=kt>int</span> <span class=n>i2</span> <span class=o>=</span> <span class=n>inner</span><span class=o>:</span><span class=k>new</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>       <span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>       <span class=n>swap</span><span class=p>(</span><span class=n>i1</span><span class=p>,</span><span class=n>i2</span><span class=p>)</span>
</span></span></code></pre></div><p>Here, the lifetimes necessary for <code>swap()</code> have been omitted and, instead, are inferred by the compiler from the arguments <code>i1</code> and <code>i2</code>. In general, lifetime inference works pretty well, although there are cases where ambiguity arises and the compiler cannot infer correct lifetimes. In such cases, it reports an error indicating the ambiguity.</p><h2 id=ownership-or-not>Ownership (or not)</h2><p>In Rust, the concept of lifetimes, <a href=https://doc.rust-lang.org/book/ownership.html><em>ownership</em></a> and <a href=https://doc.rust-lang.org/book/references-and-borrowing.html><em>borrowing</em></a> are closely tied together and, in fact, can be hard to distinguish. Roughly speaking, ownership ensures there is at most one mutable reference to any data allocated on the heap, whilst borrowing is the mechanism by which temporary mutable and non-mutable references are obtained.</p><p><em>The lifetime extension to Whiley does not include the concept of ownership</em>. This is because lifetimes are being used primarily to ensure safe memory deallocation. In the future, we may still introduce ownership into Whiley as, for example, it is important for preventing data races. However, it is likely that ownership in Whiley will be quite different from ownership in Rust. In particular, rather than using a simplistic flow analysis (i.e. as in Rust&rsquo;s borrow checker), <em>we can use Whiley&rsquo;s more sophisticated verifier to help enforce ownership</em>.</p><h2 id=conclusion>Conclusion</h2><p>The introduction of lifetimes in Whiley is a big step in the evolution of the language which, eventually, will pave the way for running Whiley on platforms which don&rsquo;t support garbage collection (i.e. as native code). And, over the next few months, I&rsquo;ll be talking more about how this is going to work.</p><hr></div></div></body></html>