<!doctype html><html lang=en><head><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta property="og:title" content="Flow Typing with Constrained Types"><meta name=twitter:title content="Flow Typing with Constrained Types"><meta property="og:url" content="https://whileydave.com/2016/08/03/flow-typing-with-constrained-types/"><title>David J. Pearce
(Flow Typing with Constrained Types)</title><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css><link rel=stylesheet href=https://whileydave.com/css/page.css><link rel=stylesheet href=https://whileydave.com/css/menu.css><link rel=stylesheet href=https://whileydave.com/css/style.css><link rel=stylesheet href=https://whileydave.com/css/syntax.css></head><body><script>"use strict";function clearMenu(){var e,t,n=window.matchMedia("(max-width: 992px)");n.matches&&(e=document.getElementById("menu-content"),t=document.getElementById("menu"),e.style.display="none",t.style.filter="")}function toggleMenu(){var e,t,n=window.matchMedia("(max-width: 992px)");n.matches&&(e=document.getElementById("menu-content"),t=document.getElementById("menu"),e.style.display==="block"?(e.style.display="none",t.style.filter=""):(e.style.display="block",t.style.filter="brightness(0.8)"))}function toggleList(e){e.style.display="none";for(var t,o=e.parentNode,s=o.childNodes,n=0;n<s.length;++n)t=s[n],t.classList&&t.classList.contains("hidden")&&(t.style.display==="block"?t.style.display="none":t.style.display="block")}</script><header class=topbar><div class=topbar-header onclick=clearMenu()><div class=topbar-title>Dr. David J. Pearce</div><div class=topbar-subtitle></div></div><div class=topbar-social onclick=clearMenu()><a href=https://github.com/DavePearce><i class="fa fa-github" aria-hidden=true></i></a>
<a href=https://twitter.com/WhileyDave><i class="fa fa-twitter" aria-hidden=true></i></a>
<a href=https://www.youtube.com/user/redjamjar/><i class="fa fa-youtube-play" aria-hidden=true></i></a>
<a href=https://www.linkedin.com/in/david-pearce-8592647/><i class="fa fa-linkedin-square" aria-hidden=true></i></a></div><div class=topbar-menu><div id=menu onclick=toggleMenu()><div id=menu-icon><img src=https://whileydave.com/images/menu.png alt=Menu></div><div id=menu-content><a href=https://whileydave.com/blog/>Blog</a>
<a href=https://whileydave.com/projects/>Projects</a>
<a href=https://whileydave.com/publications/>Publications</a>
<a href=https://whileydave.com/talks/>Talks</a>
<a href=https://whileydave.com/>Home</a></div></div></div></header><div class=container onclick=clearMenu()><div class=content><h1 class=post-title>Flow Typing with Constrained Types</h1><div class=post-date>Wednesday, August
3rd,
2016</div><hr><p><a href=https://en.wikipedia.org/wiki/Flow-sensitive_typing>Flow-sensitive typing</a> (a.k.a. &ldquo;Flow Typing&rdquo;) is definitely getting more popular these days. <a href=https://en.wikipedia.org/wiki/Ceylon_%28programming_language%29>Ceylon</a>, <a href=https://en.wikipedia.org/wiki/Kotlin_%28programming_language%29>Kotlin</a>, <a href=https://en.wikipedia.org/wiki/TypeScript>TypeScript</a>, <a href=https://en.wikipedia.org/wiki/Racket_%28programming_language%29>Racket</a>, <a href=https://en.wikipedia.org/wiki/Whiley_%28programming_language%29>Whiley</a> all support flow typing in some form. Then, of course, there&rsquo;s <a href=https://flow.org>Facebook Flow</a> and the list goes on!</p><p>Recently, I&rsquo;ve made some fairly major updates to the internals of the Whiley compiler (basically, redesigning the intermediate language). In doing so, I came across an interesting problem which I wanted to get down on paper. The problem arises when flow typing meets constrained types (a.k.a. types with invariants). <em>What does a constrained type look like?</em> Here&rsquo;s an example in Whiley:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl><span class=kd>type</span> <span class=n>nat</span> <span class=k>is</span> <span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>)</span> <span class=k>where</span> <span class=n>x</span> <span class=o>&gt;=</span> <span class=mi>0</span>
</span></span></code></pre></div><p>This defines a type <code>nat</code> which contain all integer values <code>x</code>, where <code>x >= 0</code>. Constrained types are quite powerful and Whiley attempts to seamlessly integrate them with flow typing. Here&rsquo;s a simple program to illustrate:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl><span class=kd>function</span> <span class=n>abs</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=p>(</span><span class=n>nat</span> <span class=n>r</span><span class=p>)</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>x</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>x</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>-</span><span class=n>x</span>
</span></span></code></pre></div><p>The type of <code>x</code> is initially <code>int</code>. On the true branch, we know <code>x >= 0</code> and (roughly speaking) the compiler automatically promotes <code>x</code> to type <code>nat</code> as needed.</p><h2 id=the-problem>The Problem</h2><p>An interesting challenge arises within the compiler when reasoning about constrained types and flow typing. To understand, we need to consider how flow typing works in general. The following gives a rough outline:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl><span class=n>S</span> <span class=n>x</span> <span class=o>=</span> <span class=p>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=n>x</span> <span class=k>is</span> <span class=n>T</span><span class=o>:</span>
</span></span><span class=line><span class=cl>   <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=k>else</span><span class=o>:</span>
</span></span><span class=line><span class=cl>   <span class=p>...</span>
</span></span></code></pre></div><p>Here, <code>S</code> and <code>T</code> are some arbitrary types where <code>T</code> is a subtype of <code>S</code>. The compiler <em>retypes</em> variable <code>x</code> on the true branch to have type <code>S & T</code> and, on the false branch, to type <code>S & !T</code> (which you can think of as <code>S - T</code>). To make it concrete, consider the case for <code>int|null</code> and <code>int</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl><span class=kt>int</span><span class=o>|</span><span class=kc>null</span> <span class=n>x</span> <span class=o>=</span> <span class=p>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=n>x</span> <span class=k>is</span> <span class=kt>int</span><span class=o>:</span>
</span></span><span class=line><span class=cl>   <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=k>else</span><span class=o>:</span>
</span></span><span class=line><span class=cl>   <span class=p>...</span>
</span></span></code></pre></div><p>On the true branch, <code>x</code> has type <code>(int|null)&int</code> (which reduces to <code>int</code>) and, on the false branch, it has type <code>(int|null)&!int</code> (which reduces to <code>null</code>).</p><p>The basic plan outlined above works pretty well, but things get interesting with constrained types. For example, let&rsquo;s use <code>nat</code> for the type test instead of <code>int</code> above:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl><span class=kt>int</span><span class=o>|</span><span class=kc>null</span> <span class=n>x</span> <span class=o>=</span> <span class=p>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=n>x</span> <span class=k>is</span> <span class=n>nat</span><span class=o>:</span>
</span></span><span class=line><span class=cl>   <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=k>else</span><span class=o>:</span>
</span></span><span class=line><span class=cl>   <span class=p>...</span>
</span></span></code></pre></div><p>The type of <code>x</code> on the true branch is <code>(int|null)&nat</code>, <em>but what does this reduce to?</em> A simple idea is to replace <code>nat</code> with its <em>underlying type</em> (i.e. <code>int</code>). We know this works as it&rsquo;s exactly what we had before. <em>But, what about the false branch?</em> Reducing <code>(int|null)&!nat</code> in this way gives us <code>null</code> as before which, unfortunately, is wrong. The problem is that, on the false branch, <code>x</code> can still hold values of <code>int</code> type (i.e. <em>negative</em> values).</p><h2 id=mitigating-factors>Mitigating Factors</h2><p>The Whiley compiler already reasons correctly about flow typing in the presence of arbitrary conditionals. For example, consider this variant on our example from before:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl><span class=kt>int</span><span class=o>|</span><span class=kc>null</span> <span class=n>x</span> <span class=o>=</span> <span class=p>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=n>x</span> <span class=k>is</span> <span class=kt>int</span> <span class=o>&amp;&amp;</span> <span class=n>x</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=o>:</span>
</span></span><span class=line><span class=cl>   <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=k>else</span><span class=o>:</span>
</span></span><span class=line><span class=cl>   <span class=p>...</span>
</span></span></code></pre></div><p>In this case, the Whiley compiler will correctly conclude that <code>x</code> has type <code>int|null</code> on the false branch. <em>Then why not just expand constrained types like this and be done?</em> That&rsquo;s a good question. The answer is that, if we expand types in this way, <em>we lose nominal information about them</em>. For example, we&rsquo;d lose the connection between <code>x</code> and type <code>nat</code> above, as <code>x</code>&rsquo;s type on the either branch would be in terms of <code>int</code> and <code>null</code> only.</p><p><em>So, do we really need this nominal information?</em> The answer is, technically speaking, no we don&rsquo;t. Expanding types in this way is how the Whiley compiler currently works. But, nominal information helps with providing good error messages and, turns out, that&rsquo;s important!</p><h2 id=the-solution>The Solution?</h2><p>My proposed solution stems from ideas currently being used in the Whiley compiler, namely the concept of <em>maximal</em> and <em>minimal</em> consumption of types. The idea is that the maximal consumption of a type is the largest set of values it could consume. For type <code>nat</code>, the maximal consumption is <code>int</code>. The minimal consumption is the exact oppostite &mdash; the smallest set of values it must consume. For type <code>nat</code>, this is <code>void</code> because <code>nat</code> does not consume all possible integers. Note that the minimal consumption is not always <code>void</code>. For example, the minimal consumption for <code>null|nat</code> is <code>null</code> because <code>null</code> values are <em>always</em> consumed.</p><p>This probably seems a little confusing right now, but it will start to make sense! The key idea behind my solution is the introduction of two new operators over types, namely <code>⌈T⌉</code> (ceiling) and <code>⌊T⌋</code> (floor) for representing maximal and minimal consumption for a type <code>T</code>. With these, we can now correctly type our program from before <em>without losing nominal information</em>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl><span class=kt>int</span><span class=o>|</span><span class=kc>null</span> <span class=n>x</span> <span class=o>=</span> <span class=p>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=n>x</span> <span class=k>is</span> <span class=n>nat</span><span class=o>:</span>
</span></span><span class=line><span class=cl>   <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=k>else</span><span class=o>:</span>
</span></span><span class=line><span class=cl>   <span class=p>...</span>
</span></span></code></pre></div><p>On the true branch, <code>x</code> is given the type <code>(int|null) & ⌈nat⌉</code>, whilst on the false branch it&rsquo;s given the type <code>(int|null) & !⌊nat⌋</code>. Here, the underlying type for <code>(int|null) & ⌈nat⌉</code> is <code>int</code>, whilst for <code>(int|null) & !⌊nat⌋</code> it&rsquo;s <code>int|null</code>.</p><p>The point of these new operators is that they allow us to delay calculating the underlying type for <code>x</code> <em>until we need it</em>. In other words, they allow us to retain nominal information for as long as possible.</p><h2 id=observations>Observations</h2><p>These two operators are interesting and it turns out there are few observations we can make about them:</p><ul><li><p>For any <strong>primitive type</strong> <code>T</code>, we have that <code>T</code> is equivalent to both <code>⌊T⌋</code> and <code>⌈T⌉</code>.</p></li><li><p>For any <strong>negation type</strong> <code>!T</code>, we have that <code>⌊!T⌋</code> is equivalent to <code>!⌈T⌉</code> and <code>⌈!T⌉</code> is equivalent to <code>!⌊T⌋</code>.</p></li><li><p>For any <strong>union type</strong> <code>T1 || T2</code>, we have that <code>⌊T1 || T2⌋</code> is equivalent to <code>⌊T1⌋ || ⌊T2⌋</code>, whilst <code>⌈T1 || T2⌉</code> is equivalent to <code>⌈T1⌉ || ⌈T2⌉</code>.</p></li><li><p>For any <strong>intersection type</strong> <code>T1 && T2</code>, we have that <code>⌊T1 && T2⌋</code> is equivalent to <code>⌊T1⌋ && ⌊T2⌋</code>, whilst <code>⌈T1 && T2⌉</code> is equivalent to <code>⌈T1⌉ || ⌈T2⌉</code>.</p></li><li><p>For any <strong>nominal type</strong> <code>N</code> declared as <code>T where e</code>, we have that <code>⌊N⌋</code> is equivalent to <code>void</code> and <code>⌈T⌉</code> is equivalent to <code>T</code>.</p></li></ul><h2 id=conclusion>Conclusion</h2><p>Using these two new operators provides a simple way to reason about flow typing over constrained types. The next job for me is to implement this within the Whiley compiler!</p><h2 id=references>References</h2><p>Here&rsquo;s an interesting paper on constrained types:</p><ul><li><strong>Constrained types for object-oriented languages</strong>, Nathaniel Nystrom, Vijay Saraswat, Jens Palsberg, Christian Grothoff. In <em>Proceedings of OOPSLA</em>, 2008. (<a href="http://dl.acm.org/citation.cfm?id=1449800">LINK</a>)</li></ul><hr></div></div><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-5582165-7","auto"),ga("send","pageview"))</script></body></html>