<!doctype html><html lang=en><head><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta property="og:title" content="A Problem with Structural Subtyping and Recusive Types"><meta name=twitter:title content="A Problem with Structural Subtyping and Recusive Types"><meta property="og:url" content="https://whileydave.com/2011/02/15/a-problem-with-structural-subtyping-and-recusive-types/"><title>David J. Pearce
(A Problem with Structural Subtyping and Recusive Types)</title><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css><link rel=stylesheet href=https://whileydave.com/css/page.css><link rel=stylesheet href=https://whileydave.com/css/menu.css><link rel=stylesheet href=https://whileydave.com/css/style.css></head><body><script>"use strict";function clearMenu(){var e,t,n=window.matchMedia("(max-width: 992px)");n.matches&&(e=document.getElementById("menu-content"),t=document.getElementById("menu"),e.style.display="none",t.style.filter="")}function toggleMenu(){var e,t,n=window.matchMedia("(max-width: 992px)");n.matches&&(e=document.getElementById("menu-content"),t=document.getElementById("menu"),e.style.display==="block"?(e.style.display="none",t.style.filter=""):(e.style.display="block",t.style.filter="brightness(0.8)"))}function toggleList(e){e.style.display="none";for(var t,o=e.parentNode,s=o.childNodes,n=0;n<s.length;++n)t=s[n],t.classList&&t.classList.contains("hidden")&&(t.style.display==="block"?t.style.display="none":t.style.display="block")}</script><header class=topbar><div class=topbar-header onclick=clearMenu()><div class=topbar-title>Dr. David J. Pearce</div><div class=topbar-subtitle></div></div><div class=topbar-social onclick=clearMenu()><a href=https://github.com/DavePearce><i class="fa fa-github" aria-hidden=true></i></a>
<a href=https://twitter.com/WhileyDave><i class="fa fa-twitter" aria-hidden=true></i></a>
<a href=https://www.youtube.com/user/redjamjar/><i class="fa fa-youtube-play" aria-hidden=true></i></a>
<a href=https://www.linkedin.com/in/david-pearce-8592647/><i class="fa fa-linkedin-square" aria-hidden=true></i></a></div><div class=topbar-menu><div id=menu onclick=toggleMenu()><div id=menu-icon><img src=https://whileydave.com/images/menu.png alt=Menu></div><div id=menu-content><a href=https://whileydave.com/blog/>Blog</a>
<a href=https://whileydave.com/projects/>Projects</a>
<a href=https://whileydave.com/publications/>Publications</a>
<a href=https://whileydave.com/talks/>Talks</a>
<a href=https://whileydave.com/>Home</a></div></div></div></header><div class=container onclick=clearMenu()><div class=content><h1 class=post-title>A Problem with Structural Subtyping and Recusive Types</h1><div class=post-date>Tuesday, February
15th,
2011</div><hr><p>One problem causing me a headache is how to implement <a href=http://wikipedia.org/wiki/Structural_type_system>structural subtyping</a> for <a href=http://wikipedia.org/wiki/recursive_data_type>recursive types</a> (which I first blogged about <a href=/2010/09/19/normalising-recursive-data-types/>here</a>). The following example illustrates the basic idea:</p><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-whiley data-lang=whiley><span style=display:flex><span>define Link as { <span style=color:#078;font-weight:700>int</span> data, LinkedList next }
</span></span><span style=display:flex><span>define LinkedList as <span style=color:#069;font-weight:700>null</span> <span style=color:#555>|</span> Link
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>LinkedList f(Link list)<span style=color:#555>:</span>
</span></span><span style=display:flex><span>    <span style=color:#069;font-weight:700>return</span> list
</span></span></code></pre></div><p>This is a fairly straightforward definition of a <a href=http://wikipedia.org/wiki/linked_list>linked list</a>, along with a dumb function <code>f()</code> that just returns its parameter. The key here, is that for <code>f()</code> to type check, we must show <code>Link</code> to be a subtype of <code>LinkedList</code>. In otherwords, to show that <code>Y &lt; {int data, null|Y next} ></code> is a subtype of <code>X &lt; null | {int data, X next} ></code>.</p><p>Here&rsquo;s a pictorial representation of the problem:</p><figure class=text-center><img width=50% src=/images/2011/RecursiveTypes.png></figure><p>Now, the following illustrates my current (abbreviated) subtyping implementation, with each rule annotated with its corresponding name from the <a href=/publications/ECSTR10-23.pdf>technical report</a>:</p><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-whiley data-lang=whiley><span style=display:flex><span>define T_INT as <span style=color:#f60>1</span>
</span></span><span style=display:flex><span>define T_NULL as <span style=color:#f60>0</span>
</span></span><span style=display:flex><span>define T_UNION as {Type}           <span style=color:#09f;font-style:italic>// a union (i.e. set) of types
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>define T_STRUCT as {string<span style=color:#555>-&gt;</span>Type}  <span style=color:#09f;font-style:italic>// map fields to types
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>define T_REC as { string var, Type body } <span style=color:#09f;font-style:italic>// recursive types
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>
</span></span><span style=display:flex><span>define Type as T_INT <span style=color:#555>|</span> T_NULL <span style=color:#555>|</span> T_REC <span style=color:#555>|</span> T_UNION <span style=color:#555>|</span> T_STRUCT
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#078;font-weight:700>bool</span> isSubtype(Type t1, Type t2)<span style=color:#555>:</span>
</span></span><span style=display:flex><span> <span style=color:#069;font-weight:700>if</span> t1 <span style=color:#555>==</span> t2<span style=color:#555>:</span>
</span></span><span style=display:flex><span>     <span style=color:#069;font-weight:700>return</span> <span style=color:#069;font-weight:700>true</span>
</span></span><span style=display:flex><span> <span style=color:#069;font-weight:700>else</span> <span style=color:#069;font-weight:700>if</span> t1 <span style=color:#555>~=</span> T_UNION<span style=color:#555>:</span>
</span></span><span style=display:flex><span>     <span style=color:#09f;font-style:italic>// rule S_UNION1
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>     <span style=color:#069;font-weight:700>for</span> Type t <span style=color:#069;font-weight:700>in</span> t1<span style=color:#555>:</span>
</span></span><span style=display:flex><span>         <span style=color:#069;font-weight:700>if</span> isSubtype(t,t2)<span style=color:#555>:</span>
</span></span><span style=display:flex><span>             <span style=color:#069;font-weight:700>return</span> <span style=color:#069;font-weight:700>true</span>
</span></span><span style=display:flex><span>     <span style=color:#069;font-weight:700>return</span> <span style=color:#069;font-weight:700>false</span>
</span></span><span style=display:flex><span> <span style=color:#069;font-weight:700>else</span> <span style=color:#069;font-weight:700>if</span> t2 <span style=color:#555>~=</span> T_UNION<span style=color:#555>:</span>
</span></span><span style=display:flex><span>     <span style=color:#09f;font-style:italic>// rule S_UNION2
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>     <span style=color:#069;font-weight:700>for</span> Type t <span style=color:#069;font-weight:700>in</span> t2<span style=color:#555>:</span>
</span></span><span style=display:flex><span>         <span style=color:#069;font-weight:700>if</span> isSubtype(t1,t)<span style=color:#555>:</span>
</span></span><span style=display:flex><span>             <span style=color:#069;font-weight:700>return</span> <span style=color:#069;font-weight:700>true</span>
</span></span><span style=display:flex><span>     <span style=color:#069;font-weight:700>return</span> <span style=color:#069;font-weight:700>false</span>
</span></span><span style=display:flex><span> <span style=color:#069;font-weight:700>else</span> <span style=color:#069;font-weight:700>if</span> t1 <span style=color:#555>~=</span> T_STRUCT <span style=color:#555>&amp;&amp;</span> t2 <span style=color:#555>~=</span> T_STRUCT
</span></span><span style=display:flex><span>     <span style=color:#555>&amp;&amp;</span> dom(t1) <span style=color:#555>==</span> dom(t2)<span style=color:#555>:</span>
</span></span><span style=display:flex><span>     <span style=color:#09f;font-style:italic>// rule S_DEPTH
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>     <span style=color:#069;font-weight:700>for</span> (f<span style=color:#555>-&gt;</span>t) <span style=color:#069;font-weight:700>in</span> t1<span style=color:#555>:</span>
</span></span><span style=display:flex><span>         <span style=color:#069;font-weight:700>if</span> <span style=color:#555>!</span>isSubtype(t,t2[f])<span style=color:#555>:</span>
</span></span><span style=display:flex><span>             <span style=color:#069;font-weight:700>return</span> <span style=color:#069;font-weight:700>false</span>
</span></span><span style=display:flex><span>     <span style=color:#069;font-weight:700>return</span> <span style=color:#069;font-weight:700>true</span>
</span></span><span style=display:flex><span> <span style=color:#069;font-weight:700>else</span> <span style=color:#069;font-weight:700>if</span> t1 <span style=color:#555>~=</span> T_REC <span style=color:#555>&amp;&amp;</span> t2 <span style=color:#555>~=</span> T_REC<span style=color:#555>:</span>
</span></span><span style=display:flex><span>     <span style=color:#09f;font-style:italic>// rule S_RECURSE
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>     <span style=color:#069;font-weight:700>return</span> isSubtype(t1.body,t2.body)
</span></span><span style=display:flex><span> <span style=color:#069;font-weight:700>else</span> <span style=color:#069;font-weight:700>if</span> t1 <span style=color:#555>~=</span> T_REC<span style=color:#555>:</span>
</span></span><span style=display:flex><span>     <span style=color:#09f;font-style:italic>// rule Q_UNFOLD (part of)
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>     t1 <span style=color:#555>=</span> unroll(t1)
</span></span><span style=display:flex><span>     <span style=color:#069;font-weight:700>return</span> isSubtype(t1,t2)
</span></span><span style=display:flex><span> <span style=color:#069;font-weight:700>else</span> <span style=color:#069;font-weight:700>if</span> t2 <span style=color:#555>~=</span> T_REC<span style=color:#555>:</span>
</span></span><span style=display:flex><span>     <span style=color:#09f;font-style:italic>// rule Q_UNFOLD (part of)
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>     t2 <span style=color:#555>=</span> unroll(t2)
</span></span><span style=display:flex><span>     <span style=color:#069;font-weight:700>return</span> isSubtype(t1,t2)
</span></span><span style=display:flex><span> <span style=color:#069;font-weight:700>else</span><span style=color:#555>:</span>
</span></span><span style=display:flex><span>     <span style=color:#069;font-weight:700>return</span> <span style=color:#069;font-weight:700>false</span>
</span></span></code></pre></div><p>The <code>unroll()</code> function does what you&rsquo;d expect: it takes a recursive type and substitutes its body for itself. So, for example:
<code>X &lt; null | {int data, X next} ></code>
unrolls to this:
<code>null | {int data, (X &lt; null | {int data, X next} >) next}</code>
Unfortunately, <code>isSubtype()</code> will not conclude that <code>Link</code> is a subtype of <code>LinkedList</code>.  The problem is that, on entry, we have two instances of <code>T_REC</code> with different bodies.  Thus, <code>isSubtype()</code> will attempt to recursively identify whether the first body is a subtype of the second (which it is not because it ends up with the case <code>isSubtype(X,null|X)</code>).</p><p>Apparently, the following papers tell me how to solve this problem:</p><ul><li><p>Efficient Recursive Subtyping, Dexter Kozen, Jens Palsberg and Michael Schwartzbach.  POPL, 1993. [<a href=http://dx.doi.org/10.1145/158511.158700>ACM DL</a>] [<a href="http://citeseerx.ist.psu.edu/viewdoc/download;jsessionid=9C9C66C3B2B15D858FC794EF562A4361?doi=10.1.1.55.8186&rep=rep1&type=pdf">PDF</a>]</p></li><li><p><em>Subtyping Recursive Types</em>, Roberto M. Amadio1 Luca Cardelli, TOPLAS, 1993.  [<a href="http://portal.acm.org/citation.cfm?id=155231">ACM DL</a>] [<a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.65.4769&rep=rep1&type=pdf">PDF</a>]</p></li><li><p><em>Efficient Inclusion Checking for Deterministic Tree Automata and DTDs</em>, Jérôme Champavère, Rémi Gilleron, Aurélien Lemay, and Joachim Niehren, 2008. [<a href=http://www.grappa.univ-lille3.fr/~champavere/Recherche/publications/lata08_paper.pdf>PDF</a>]</p></li></ul><p>&mldr; I just need to figure them out first!</p><hr></div></div><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-5582165-7","auto"),ga("send","pageview"))</script></body></html>