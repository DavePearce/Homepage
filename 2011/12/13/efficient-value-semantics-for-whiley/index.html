<!doctype html><html lang=en><head><script async src="https://www.googletagmanager.com/gtag/js?id=G-9MRLB1FVZX"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-9MRLB1FVZX",{anonymize_ip:!1})}</script><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta property="og:title" content="Efficient Value Semantics for Whiley"><meta name=twitter:title content="Efficient Value Semantics for Whiley"><meta property="og:url" content="https://whileydave.com/2011/12/13/efficient-value-semantics-for-whiley/"><title>David J. Pearce
(Efficient Value Semantics for Whiley)</title><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css><link rel=stylesheet href=https://whileydave.com/css/page.css><link rel=stylesheet href=https://whileydave.com/css/menu.css><link rel=stylesheet href=https://whileydave.com/css/style.css><link rel=stylesheet href=https://whileydave.com/css/syntax.css></head><body><script>"use strict";function clearMenu(){var e,t,n=window.matchMedia("(max-width: 992px)");n.matches&&(e=document.getElementById("menu-content"),t=document.getElementById("menu"),e.style.display="none",t.style.filter="")}function toggleMenu(){var e,t,n=window.matchMedia("(max-width: 992px)");n.matches&&(e=document.getElementById("menu-content"),t=document.getElementById("menu"),e.style.display==="block"?(e.style.display="none",t.style.filter=""):(e.style.display="block",t.style.filter="brightness(0.8)"))}function toggleList(e){e.style.display="none";for(var t,o=e.parentNode,s=o.childNodes,n=0;n<s.length;++n)t=s[n],t.classList&&t.classList.contains("hidden")&&(t.style.display==="block"?t.style.display="none":t.style.display="block")}</script><header class=topbar><div class=topbar-header onclick=clearMenu()><div class=topbar-title>Dr. David J. Pearce</div><div class=topbar-subtitle></div></div><div class=topbar-social onclick=clearMenu()><a href=https://github.com/DavePearce><i class="fa fa-github" aria-hidden=true></i></a>
<a href=https://twitter.com/WhileyDave><i class="fa fa-twitter" aria-hidden=true></i></a>
<a href=https://www.youtube.com/user/redjamjar/><i class="fa fa-youtube-play" aria-hidden=true></i></a>
<a href=https://www.linkedin.com/in/david-pearce-8592647/><i class="fa fa-linkedin-square" aria-hidden=true></i></a></div><div class=topbar-menu><div id=menu onclick=toggleMenu()><div id=menu-icon><img src=https://whileydave.com/images/menu.png alt=Menu></div><div id=menu-content><a href=https://whileydave.com/blog/>Blog</a>
<a href=https://whileydave.com/projects/>Projects</a>
<a href=https://whileydave.com/publications/>Publications</a>
<a href=https://whileydave.com/talks/>Talks</a>
<a href=https://whileydave.com/>Home</a></div></div></div></header><div class=container onclick=clearMenu()><div class=content><h1 class=post-title>Efficient Value Semantics for Whiley</h1><div class=post-date>Tuesday, December
13th,
2011</div><hr><p>The latest release of the Whiley compiler (v0.3.12) includes an optimisation for passing compound structures (e.g. lists, sets and records) by value.  This is really important because all compound structures in Whiley have <em>value semantics</em>, meaning they are always passed by value.  In fact, Whiley does not support references or pointers as found in other languages (e.g. Java, C, etc).  This means Whiley is really more of a <a href=http://wikipedia.org/wiki/Functional_programming>functional programming language</a> than an <a href=http://wikipedia.org/wiki/Imperative_programming>imperative language</a>.  As we&rsquo;ll see, compared to other functional languages, Whiley is a little unusual as it supports <em>imperative updates</em> to compound structures.</p><h2 id=an-example>An Example</h2><p><em>So, what does this all mean?</em> Well, let&rsquo;s have a look at an examples:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl><span class=p>[</span><span class=n>real</span><span class=p>]</span> <span class=n>normalise</span><span class=p>([</span><span class=n>real</span><span class=p>]</span> <span class=n>data</span><span class=p>,</span> <span class=n>real</span> <span class=n>max</span><span class=p>)</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=k>in</span> <span class=mi>0</span><span class=p>..</span><span class=o>|</span><span class=n>data</span><span class=o>|:</span>
</span></span><span class=line><span class=cl>        <span class=n>data</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>data</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>/</span> <span class=n>max</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>data</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=o>::</span><span class=n>main</span><span class=p>(</span><span class=n>System</span> <span class=n>sys</span><span class=p>)</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>original</span> <span class=o>=</span> <span class=p>[</span><span class=mi>1</span><span class=p>.</span><span class=mi>2</span><span class=p>,</span><span class=mi>2</span><span class=p>.</span><span class=mi>3</span><span class=p>,</span><span class=mi>4</span><span class=p>.</span><span class=mi>5</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=n>normalised</span> <span class=o>=</span> <span class=n>normalise</span><span class=p>(</span><span class=n>original</span><span class=p>,</span><span class=mi>0</span><span class=p>.</span><span class=mi>5</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>sys</span><span class=p>.</span><span class=n>out</span><span class=p>.</span><span class=n>println</span><span class=p>(</span><span class=n>original</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>sys</span><span class=p>.</span><span class=n>out</span><span class=p>.</span><span class=n>println</span><span class=p>(</span><span class=n>normalised</span><span class=p>)</span>
</span></span></code></pre></div><p>This function updates a list of real values in-place using a typical (imperative) list assignment of the form <code>data[i] = ...</code>.  In Java, where variables of array type are references to array objects, this would simultaneously update the callers version of this array as well.  In Whiley, however, this is not the case.  The list assignment inside <code>normalise()</code> does not modify the <code>original</code> list in <code>main()</code>.  This is because the list is <em>passed-by-value</em> in the true sense of the word.  You can think of this as meaning that <em>the whole list is copied when the normalise function is called</em> to prevent any interference between caller and callee.</p><h2 id=inefficiency>(In)efficiency?</h2><p><em>Ok, but that all that copying must be crazily inefficient!</em> Well, not so.  This is because, whilst the semantics of Whiley dictate pass-by-value for compound structures, the underlying implementation actually passes them by reference.  Furthermore, it clones them lazily with reference counting being employed to reduce the situations where a clone is actually required.  Before explaining how the reference counting works, let&rsquo;s look at some actual data first:</p><table><thead><tr><th>Name</th><th>Description</th><th>LOC</th><th># Clones</th><th>%</th><th>Time</th></tr></thead><tbody><tr><td>Jasm</td><td><em>A Java bytecode disassembler.</em></td><td>2333</td><td>12878 / 29968</td><td>43.0%</td><td>2.1s</td></tr><tr><td>Gunzip</td><td><em>An implementation of DEFLATE.</em></td><td>815</td><td>873 / 140561</td><td>0.62%</td><td>1.6s</td></tr><tr><td>Chess</td><td><em>Validates chess games in short algebraic notation.</em></td><td>784</td><td>6438 / 416116</td><td>1.6%</td><td>1.4s</td></tr><tr><td>Calculator</td><td><em>An arithmetic expression evaluator.</em></td><td>225</td><td>0 / 81527</td><td>0.0%</td><td>8.8s</td></tr></tbody></table><p><em>What is this data showing us?</em> Well, &ldquo;# Clones&rdquo; shows the number of clones actually performed versus the number that a naive implementation of value semantics would have performed.   The naive version clones whenever an argument is passed or returned from a function, whenever a list element is assigned, etc.  It represents an upper bound on the number of clones required.  So, for example, looking at the Gunzip benchmark we see that only 873 clones were required out of a maximum of 140561.  This indicates that, in the vast majority of cases, value semantics does not actually result in many extra clones.</p><p><em>But the results for Jasm look quite bad?</em> Well, yes.  But, actually, they&rsquo;re not too bad if we consider the cause.  Essentially, the Jasm benchmark consists of an inner loop for decoding bytecodes.  Roughly speaking, it looks like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl><span class=p>([</span><span class=n>Bytecode</span><span class=p>],</span><span class=kt>int</span><span class=p>)</span> <span class=n>decode</span><span class=p>([</span><span class=kt>byte</span><span class=p>]</span> <span class=n>data</span><span class=p>,</span> <span class=kt>int</span> <span class=n>pos</span><span class=p>)</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>opcode</span> <span class=o>=</span> <span class=n>Byte</span><span class=p>.</span><span class=n>toUnsignedInt</span><span class=p>(</span><span class=n>data</span><span class=p>[</span><span class=n>pos</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    <span class=n>kind</span><span class=p>,</span><span class=n>fmt</span><span class=p>,</span><span class=kd>type</span> <span class=o>=</span> <span class=n>decodeTable</span><span class=p>[</span><span class=n>opcode</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=k>switch</span> <span class=n>fmt</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=n>FMT_EMPTY</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=p>....</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=n>FMT_I8</span><span class=o>:</span>
</span></span><span class=line><span class=cl>            <span class=n>idx</span> <span class=o>=</span> <span class=n>Byte</span><span class=p>.</span><span class=n>toUnsignedInt</span><span class=p>(</span><span class=n>data</span><span class=p>[</span><span class=n>pos</span><span class=o>+</span><span class=mi>1</span><span class=p>..</span><span class=n>pos</span><span class=o>+</span><span class=mi>2</span><span class=p>])</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=p>{</span><span class=n>offset</span><span class=o>:</span> <span class=n>pos</span><span class=o>-</span><span class=mi>14</span><span class=p>,</span> <span class=n>op</span><span class=o>:</span> <span class=n>opcode</span><span class=p>},</span><span class=n>pos</span><span class=o>+</span><span class=mi>2</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=n>FMT_I16</span><span class=o>:</span>
</span></span><span class=line><span class=cl>            <span class=n>idx</span> <span class=o>=</span> <span class=n>Byte</span><span class=p>.</span><span class=n>toUnsignedInt</span><span class=p>(</span><span class=n>data</span><span class=p>[</span><span class=n>pos</span><span class=o>+</span><span class=mi>3</span><span class=p>..</span><span class=n>pos</span><span class=o>+</span><span class=mi>1</span><span class=p>])</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=p>{</span><span class=n>offset</span><span class=o>:</span> <span class=n>pos</span><span class=o>-</span><span class=mi>14</span><span class=p>,</span> <span class=n>op</span><span class=o>:</span> <span class=n>opcode</span><span class=p>},</span><span class=n>pos</span><span class=o>+</span><span class=mi>3</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=n>FMT_VARIDX</span><span class=o>:</span>
</span></span><span class=line><span class=cl>            <span class=n>index</span> <span class=o>=</span> <span class=n>Byte</span><span class=p>.</span><span class=n>toUnsignedInt</span><span class=p>(</span><span class=n>data</span><span class=p>[</span><span class=n>pos</span><span class=o>+</span><span class=mi>1</span><span class=p>..</span><span class=n>pos</span><span class=o>+</span><span class=mi>2</span><span class=p>])</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>VarIndex</span><span class=p>(</span><span class=n>pos</span><span class=o>-</span><span class=mi>14</span><span class=p>,</span> <span class=n>opcode</span><span class=p>,</span> <span class=n>index</span><span class=p>),</span><span class=n>pos</span><span class=o>+</span><span class=mi>2</span>
</span></span><span class=line><span class=cl>        <span class=p>...</span>
</span></span></code></pre></div><p>What we see is that the loop first reads the opcode byte and then, based on this, reads zero or more additional bytes  (e.g. <code>data[pos+1..pos+2]</code>).  This sublist operation is the root cause of almost every  clone reported in the above table for Jasm.  In fact, it&rsquo;s not a clone of the entire <code>data</code> list; rather, it just copies those few bytes being read into a new list &mdash; meaning it&rsquo;s not really very expensive.</p><h2 id=implementation>Implementation</h2><p><em>So, how does the reference counting work?</em> One of the key optimisations is knowledge of when a variable is no longer <em>live</em>. For example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl><span class=p>[</span><span class=kt>int</span><span class=p>]</span> <span class=n>f</span><span class=p>([</span><span class=kt>int</span><span class=p>]</span> <span class=n>xs</span><span class=p>)</span><span class=o>:</span>
</span></span><span class=line><span class=cl>   <span class=n>ys</span> <span class=o>=</span> <span class=n>xs</span> <span class=c1>// ref count not increased
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=n>ys</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>   <span class=k>return</span> <span class=n>ys</span>
</span></span></code></pre></div><p>Here, the variable <code>xs</code> is dead after the assignment to <code>ys</code>.  Therefore, we don&rsquo;t need to increase the reference count of the object it refers to as, effectively, ownership is transferred from <code>xs</code> to <code>ys</code>.  If the reference count of <code>xs</code> on entry was 1, then it will still be 1 at the assignment <code>ys[0] = 1</code> and, hence, the assignment can be performed in place.  Now, let&rsquo;s consider a more detailed example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl>  <span class=p>[</span><span class=kt>int</span><span class=p>]</span> <span class=n>f</span><span class=p>([</span><span class=kt>int</span><span class=p>]</span> <span class=n>z</span><span class=p>)</span><span class=o>:</span>
</span></span><span class=line><span class=cl>      <span class=n>z</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span> <span class=c1>// Object #2 created
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=k>return</span> <span class=n>z</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=p>[</span><span class=kt>int</span><span class=p>]</span> <span class=n>g</span><span class=p>()</span><span class=o>:</span>
</span></span><span class=line><span class=cl>      <span class=n>x</span> <span class=o>=</span> <span class=p>[</span><span class=mi>1</span><span class=p>,</span><span class=mi>2</span><span class=p>,</span><span class=mi>3</span><span class=p>]</span> <span class=c1>// Object #1 created
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=n>y</span> <span class=o>=</span> <span class=n>f</span><span class=p>(</span><span class=n>x</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=n>x</span> <span class=o>+</span> <span class=n>y</span>
</span></span></code></pre></div><p>On Line 6, Object #1 (which represents the constructed list) has an initial reference count of one. This does not change when it is assigned to <code>x</code>. Its reference count is then increased by one on Line 7, as <code>x</code> is used in the invocation expression and <em>remains live afterward</em>. On entry to <code>f()</code>, parameter <code>z</code> refers to Object #1, which now has reference count two. Therefore, the list assignment on Line 2 creates an entirely new object before updating it. It also decrements the reference count of Object #1. On Line 8, <code>x</code> still refers to Object #1 (now with reference count one) and, hence, the append is performed in place without cloning.</p><h2 id=conclusion>Conclusion</h2><p>Reference counting is a critical optimisation to improving the performance of Whiley programs.  The latest version of the compiler (finally) supports this, although there is still room for considerable improvement.  In fact, a good starting point is the following paper:</p><ul><li>Staged Static Techniques to Efficiently Implement Array Copy Semantics in a MATLAB JIT Compiler, N. Lameed and L. Hendren.  In <em>Proceedings of the Conference on Compiler Construction</em>, 2011. [<a href=http://www.sable.mcgill.ca/mclab/mcvm/mcvmcc2011.pdf>PDF</a>]</li></ul><p>Anyway, that&rsquo;s all folks!</p><hr></div></div></body></html>