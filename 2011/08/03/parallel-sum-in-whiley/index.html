<!doctype html><html lang=en><head><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta property="og:title" content="Parallel Sum in Whiley"><meta name=twitter:title content="Parallel Sum in Whiley"><meta property="og:url" content="https://whileydave.com/2011/08/03/parallel-sum-in-whiley/"><title>David J. Pearce
(Parallel Sum in Whiley)</title><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css><link rel=stylesheet href=https://whileydave.com/css/page.css><link rel=stylesheet href=https://whileydave.com/css/menu.css><link rel=stylesheet href=https://whileydave.com/css/style.css></head><body><script>"use strict";function clearMenu(){var e,t,n=window.matchMedia("(max-width: 992px)");n.matches&&(e=document.getElementById("menu-content"),t=document.getElementById("menu"),e.style.display="none",t.style.filter="")}function toggleMenu(){var e,t,n=window.matchMedia("(max-width: 992px)");n.matches&&(e=document.getElementById("menu-content"),t=document.getElementById("menu"),e.style.display==="block"?(e.style.display="none",t.style.filter=""):(e.style.display="block",t.style.filter="brightness(0.8)"))}function toggleList(e){e.style.display="none";for(var t,o=e.parentNode,s=o.childNodes,n=0;n<s.length;++n)t=s[n],t.classList&&t.classList.contains("hidden")&&(t.style.display==="block"?t.style.display="none":t.style.display="block")}</script><header class=topbar><div class=topbar-header onclick=clearMenu()><div class=topbar-title>Dr. David J. Pearce</div><div class=topbar-subtitle></div></div><div class=topbar-social onclick=clearMenu()><a href=https://github.com/DavePearce><i class="fa fa-github" aria-hidden=true></i></a>
<a href=https://twitter.com/WhileyDave><i class="fa fa-twitter" aria-hidden=true></i></a>
<a href=https://www.youtube.com/user/redjamjar/><i class="fa fa-youtube-play" aria-hidden=true></i></a>
<a href=https://www.linkedin.com/in/david-pearce-8592647/><i class="fa fa-linkedin-square" aria-hidden=true></i></a></div><div class=topbar-menu><div id=menu onclick=toggleMenu()><div id=menu-icon><img src=https://whileydave.com/images/menu.png alt=Menu></div><div id=menu-content><a href=https://whileydave.com/blog/>Blog</a>
<a href=https://whileydave.com/projects/>Projects</a>
<a href=https://whileydave.com/publications/>Publications</a>
<a href=https://whileydave.com/talks/>Talks</a>
<a href=https://whileydave.com/>Home</a></div></div></div></header><div class=container onclick=clearMenu()><div class=content><h1 class=post-title>Parallel Sum in Whiley</h1><div class=post-date>Wednesday, August
3rd,
2011</div><hr><p>Recently, I&rsquo;ve been working on a variety of sequential and concurrent micro benchmarks for testing Whiley&rsquo;s performance.  An interesting and relatively simple example, is the parallel sum.  The idea is to sum a large list of integers whilst performing as much work as possible in parallel.</p><p>To implement the parallel sum, I divide the list into roughly equal sized chunks and assign one process to each:</p><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-whiley data-lang=whiley><span style=display:flex><span>define Sum as process {
</span></span><span style=display:flex><span>    [<span style=color:#078;font-weight:700>int</span>] items,
</span></span><span style=display:flex><span>    <span style=color:#078;font-weight:700>int</span> start,
</span></span><span style=display:flex><span>    <span style=color:#078;font-weight:700>int</span> end,
</span></span><span style=display:flex><span>    <span style=color:#078;font-weight:700>int</span> result
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#078;font-weight:700>void</span> Sum<span style=color:#555>::</span>start()<span style=color:#555>:</span>
</span></span><span style=display:flex><span>    sum <span style=color:#555>=</span> <span style=color:#f60>0</span>
</span></span><span style=display:flex><span>    <span style=color:#069;font-weight:700>for</span> i <span style=color:#069;font-weight:700>in</span> start..end<span style=color:#555>:</span>
</span></span><span style=display:flex><span>        sum <span style=color:#555>=</span> sum <span style=color:#555>+</span> items[i]
</span></span><span style=display:flex><span>    this.result <span style=color:#555>=</span> sum
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#078;font-weight:700>int</span> Sum<span style=color:#555>::</span>get()<span style=color:#555>:</span>
</span></span><span style=display:flex><span>    <span style=color:#069;font-weight:700>return</span> result
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#09f;font-style:italic>// Sum constructor
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>Sum <span style=color:#555>::</span>Sum([<span style=color:#078;font-weight:700>int</span>] <span style=color:#069;font-weight:700>is</span>, <span style=color:#078;font-weight:700>int</span> s, <span style=color:#078;font-weight:700>int</span> e)<span style=color:#555>:</span>
</span></span><span style=display:flex><span>    <span style=color:#069;font-weight:700>return</span> spawn {
</span></span><span style=display:flex><span>        items<span style=color:#555>:</span> i,
</span></span><span style=display:flex><span>        start<span style=color:#555>:</span> s,
</span></span><span style=display:flex><span>        end<span style=color:#555>:</span> e,
</span></span><span style=display:flex><span>        result<span style=color:#555>:</span> <span style=color:#f60>0</span>
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>Essentially, each <code>Sum</code> process holds the original list of <code>items</code> and a range <code>start..end</code> over which to operate. The <code>result</code> is used to store the final sum until it is requested by the outer loop.  The idea is that we first construct the processes, then start them all asynchronously and, finally, collect up the results.</p><p>The outer loop looks something like this:</p><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-whiley data-lang=whiley><span style=display:flex><span>define N as <span style=color:#f60>100</span> <span style=color:#09f;font-style:italic>// block size to use
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#078;font-weight:700>int</span> <span style=color:#555>::</span>parSum([<span style=color:#078;font-weight:700>int</span>] items)<span style=color:#555>:</span>
</span></span><span style=display:flex><span>    <span style=color:#069;font-weight:700>while</span> <span style=color:#555>|</span>items<span style=color:#555>|</span> <span style=color:#555>!=</span> <span style=color:#f60>1</span><span style=color:#555>:</span>
</span></span><span style=display:flex><span>        <span style=color:#09f;font-style:italic>// Calculate how many workers required
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>        nworkers <span style=color:#555>=</span> max(<span style=color:#f60>1</span>,<span style=color:#555>|</span>items<span style=color:#555>|</span> <span style=color:#555>/</span> N)
</span></span><span style=display:flex><span>        size <span style=color:#555>=</span> <span style=color:#555>|</span>items<span style=color:#555>|</span> <span style=color:#555>/</span> nworkers
</span></span><span style=display:flex><span>        <span style=color:#09f;font-style:italic>// Construct and start workers
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>        pos <span style=color:#555>=</span> <span style=color:#f60>0</span>
</span></span><span style=display:flex><span>        workers <span style=color:#555>=</span> []
</span></span><span style=display:flex><span>        <span style=color:#069;font-weight:700>for</span> i <span style=color:#069;font-weight:700>in</span> <span style=color:#f60>0</span>..nworkers<span style=color:#555>:</span>
</span></span><span style=display:flex><span>            <span style=color:#069;font-weight:700>if</span> i <span style=color:#555>&lt;</span> (nworkers<span style=color:#555>-</span><span style=color:#f60>1</span>)<span style=color:#555>:</span>
</span></span><span style=display:flex><span>                worker <span style=color:#555>=</span> Sum(items,pos,pos<span style=color:#555>+</span>size)
</span></span><span style=display:flex><span>            <span style=color:#069;font-weight:700>else</span><span style=color:#555>:</span>
</span></span><span style=display:flex><span>                <span style=color:#09f;font-style:italic>// Last worker picks up the slack
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>                worker <span style=color:#555>=</span> Sum(items,pos,<span style=color:#555>|</span>items<span style=color:#555>|</span>)
</span></span><span style=display:flex><span>            <span style=color:#09f;font-style:italic>// Start worker asynchronously
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>            worker<span style=color:#555>!</span>start()
</span></span><span style=display:flex><span>            <span style=color:#09f;font-style:italic>// Bookkeeping
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>            workers <span style=color:#555>=</span> workers <span style=color:#555>+</span> [worker]
</span></span><span style=display:flex><span>            pos <span style=color:#555>=</span> pos <span style=color:#555>+</span> size
</span></span><span style=display:flex><span>     <span style=color:#09f;font-style:italic>// Collect up results
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>     items <span style=color:#555>=</span> []
</span></span><span style=display:flex><span>     <span style=color:#069;font-weight:700>for</span> i <span style=color:#069;font-weight:700>in</span> <span style=color:#f60>0</span> .. nworkers<span style=color:#555>:</span>
</span></span><span style=display:flex><span>         items <span style=color:#555>=</span> items <span style=color:#555>+</span> [workers[i].get()]
</span></span><span style=display:flex><span> <span style=color:#069;font-weight:700>return</span> items[<span style=color:#f60>0</span>]
</span></span></code></pre></div><p>The key here is that the outer loop continues until the original list of <code>items</code> is reduced to a single result. There maybe several iterations required, depending on the block size. Furthermore, the block size determines how many items will be processed by each process in one go. Smaller block sizes lead to more parallelism, but have higher overheads. The optimal block size probably depends on the underlying architecture, and would ideally be chosen at runtime.</p><hr></div></div><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-5582165-7","auto"),ga("send","pageview"))</script></body></html>