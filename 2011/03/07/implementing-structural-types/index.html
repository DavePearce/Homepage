<!doctype html><html lang=en><head><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta property="og:title" content="Implementing Structural Types"><meta name=twitter:title content="Implementing Structural Types"><meta property="og:url" content="https://whileydave.com/2011/03/07/implementing-structural-types/"><title>David J. Pearce
(Implementing Structural Types)</title><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css><link rel=stylesheet href=https://whileydave.com/css/page.css><link rel=stylesheet href=https://whileydave.com/css/menu.css><link rel=stylesheet href=https://whileydave.com/css/style.css><link rel=stylesheet href=https://whileydave.com/css/syntax.css></head><body><script>"use strict";function clearMenu(){var e,t,n=window.matchMedia("(max-width: 992px)");n.matches&&(e=document.getElementById("menu-content"),t=document.getElementById("menu"),e.style.display="none",t.style.filter="")}function toggleMenu(){var e,t,n=window.matchMedia("(max-width: 992px)");n.matches&&(e=document.getElementById("menu-content"),t=document.getElementById("menu"),e.style.display==="block"?(e.style.display="none",t.style.filter=""):(e.style.display="block",t.style.filter="brightness(0.8)"))}function toggleList(e){e.style.display="none";for(var t,o=e.parentNode,s=o.childNodes,n=0;n<s.length;++n)t=s[n],t.classList&&t.classList.contains("hidden")&&(t.style.display==="block"?t.style.display="none":t.style.display="block")}</script><header class=topbar><div class=topbar-header onclick=clearMenu()><div class=topbar-title>Dr. David J. Pearce</div><div class=topbar-subtitle></div></div><div class=topbar-social onclick=clearMenu()><a href=https://github.com/DavePearce><i class="fa fa-github" aria-hidden=true></i></a>
<a href=https://twitter.com/WhileyDave><i class="fa fa-twitter" aria-hidden=true></i></a>
<a href=https://www.youtube.com/user/redjamjar/><i class="fa fa-youtube-play" aria-hidden=true></i></a>
<a href=https://www.linkedin.com/in/david-pearce-8592647/><i class="fa fa-linkedin-square" aria-hidden=true></i></a></div><div class=topbar-menu><div id=menu onclick=toggleMenu()><div id=menu-icon><img src=https://whileydave.com/images/menu.png alt=Menu></div><div id=menu-content><a href=https://whileydave.com/blog/>Blog</a>
<a href=https://whileydave.com/projects/>Projects</a>
<a href=https://whileydave.com/publications/>Publications</a>
<a href=https://whileydave.com/talks/>Talks</a>
<a href=https://whileydave.com/>Home</a></div></div></div></header><div class=container onclick=clearMenu()><div class=content><h1 class=post-title>Implementing Structural Types</h1><div class=post-date>Monday, March
7th,
2011</div><hr><h2 id=introduction>Introduction</h2><p>Over the last few months, I&rsquo;ve been working on the type system underpinning Whiley.  A key feature is the use of <a href=http://wikipedia.org/wiki/Structural_type_system>structural typing</a>, rather than <a href=http://wikipedia.org/wiki/nominal_typing>nominal typing</a>, and I&rsquo;ve blogged about this quite a bit already (see [<a href=http://whiley.org/2010/12/13/why-not-use-structural-subtyping/>1</a>][<a href=http://whiley.org/2010/12/13/why-not-use-structural-subtyping/>2</a>][<a href=http://whiley.org/2011/02/15/a-problem-structural-subtyping-an-recusive-types/>3</a>][<a href=http://whiley.org/2011/02/16/minimising-recursive-data-types/>4</a>]).  Over the weekend, I finally found time to work through all my thoughts and turn them into code!</p><p>So, after making it all work with my existing system, I finally realised it would <em>really really help</em> to redesign the way types are represented in the compiler&mldr;</p><h2 id=recap>Recap</h2><p>The main <a href=http://whiley.org/guide/data-types/>data types</a> in Whiley are the <em>primitives</em> (e.g. <code>null</code>, <code>int</code>, <code>real</code>, etc), <em>collections</em> (e.g. <code>[int]</code> or <code>{real}</code>), <em>records</em> (e.g. <code>{int data, Link next}</code>) and <em>unions</em> (e.g. <code>int|[int]</code>).  A good illustration is the following:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl><span class=n>define</span> <span class=n>LinkedList</span> <span class=n>as</span> <span class=kc>null</span> <span class=o>|</span> <span class=p>{</span><span class=kt>int</span> <span class=n>data</span><span class=p>,</span> <span class=n>LinkedList</span> <span class=n>next</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>define</span> <span class=n>NonEmptyList</span> <span class=n>as</span> <span class=p>{</span><span class=kt>int</span> <span class=n>data</span><span class=p>,</span> <span class=n>LinkedList</span> <span class=n>next</span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>sum</span><span class=p>(</span><span class=n>NonEmptyList</span> <span class=n>ls</span><span class=p>)</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>ls</span><span class=p>.</span><span class=n>next</span> <span class=o>==</span> <span class=kc>null</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>ls</span><span class=p>.</span><span class=n>data</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>ls</span><span class=p>.</span><span class=n>data</span> <span class=o>+</span> <span class=n>sum</span><span class=p>(</span><span class=n>ls</span><span class=p>.</span><span class=n>next</span><span class=p>)</span>
</span></span></code></pre></div><p>What&rsquo;s interesting is that we can explicitly prohibit summing an empty list (of course, we could just return 0 for an empty list, but that wouldn&rsquo;t make such an interesting example).</p><p>To type check this example, the compiler must show that <code>NonEmptyList</code> is a subtype of <code>LinkedList</code>. This turns out to be a significant challenge! Another big challenge is that of <em>type minimisation</em>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl><span class=n>define</span> <span class=n>LinkedList</span> <span class=n>as</span> <span class=kc>null</span> <span class=o>|</span> <span class=p>{</span><span class=kt>int</span> <span class=n>data</span><span class=p>,</span> <span class=n>LinkedList</span> <span class=n>next</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>define</span> <span class=n>InnerList</span> <span class=n>as</span> <span class=kc>null</span> <span class=o>|</span> <span class=p>{</span><span class=kt>int</span> <span class=n>data</span><span class=p>,</span> <span class=n>OuterList</span> <span class=n>next</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>define</span> <span class=n>OuterList</span> <span class=n>as</span> <span class=kc>null</span> <span class=o>|</span> <span class=p>{</span><span class=kt>int</span> <span class=n>data</span><span class=p>,</span> <span class=n>InnerList</span> <span class=n>next</span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>LinkedList</span> <span class=n>f</span><span class=p>(</span><span class=n>OuterList</span> <span class=n>ls</span><span class=p>)</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>ls</span>
</span></span></code></pre></div><p>To type check this example, the compiler must show that <code>LinkedList</code> is structurally equivalent to <code>OuterList</code>. The following diagram illustrates this nicely:</p><figure class=text-center><img width=600px src=/images/2011/MinimisingRecursiveTypes1.png></figure><p>Here, circles represent unions (e.g. <code>T1 | T2</code>), whilst squares represent records (e.g. <code>{ int data, ... }</code>). The type on the left corresponds with <code>LinkedList</code>, whilst that on the right corresponds with <code>OuterList</code> (<strong>note:</strong> I’ve left off the data field from the diagrams as it’s not important here).</p><p>From the diagram we can see that, whilst the two types aren&rsquo;t identical, they encode the same &ldquo;structure&rdquo; &mdash; <em>but how can the compiler prove this?</em>## Bad Idea
My initial approach to implementing these types in the Whiley compiler was the most obvious one: encode them as <em>trees</em> using recursively defined data types.  In Java this might go something like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>class</span> <span class=nc>Int</span> <span class=kd>implements</span> <span class=n>Type</span> <span class=o>{</span> <span class=o>...</span> <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>class</span> <span class=nc>Real</span> <span class=kd>implements</span> <span class=n>Type</span> <span class=o>{</span> <span class=o>...</span> <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>class</span> <span class=nc>Set</span> <span class=kd>implements</span> <span class=n>Type</span> <span class=o>{</span> <span class=n>Type</span> <span class=n>element</span><span class=o>;</span> <span class=o>...</span> <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>class</span> <span class=nc>List</span> <span class=kd>implements</span> <span class=n>Type</span> <span class=o>{</span> <span class=n>Type</span> <span class=n>element</span><span class=o>;</span> <span class=o>...</span> <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>class</span> <span class=nc>Record</span> <span class=kd>implements</span> <span class=n>Type</span> <span class=o>{</span> <span class=n>Map</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span><span class=n>Type</span><span class=o>&gt;</span> <span class=n>fields</span><span class=o>;</span> <span class=o>...</span> <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>class</span> <span class=nc>Union</span> <span class=kd>implements</span> <span class=n>Type</span> <span class=o>{</span> <span class=n>Set</span><span class=o>&lt;</span><span class=n>Type</span><span class=o>&gt;</span> <span class=n>fields</span><span class=o>;</span> <span class=o>...</span> <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>class</span> <span class=nc>Recursive</span> <span class=kd>implements</span> <span class=n>Type</span> <span class=o>{</span> <span class=n>String</span> <span class=n>name</span><span class=o>,</span> <span class=n>Type</span> <span class=n>body</span><span class=o>;</span> <span class=o>...</span> <span class=o>}</span>
</span></span></code></pre></div><p>This is mostly straightforward except for the way recursive types are defined. In this case, an instance of <code>Recursive</code> indicates the start of a recursive type and this is terminating by a matching instance where <code>body == null</code>. For example, we create our <code>LinkedList</code> type as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// first, create internal record
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>HashMap</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span><span class=n>Type</span><span class=o>&gt;</span> <span class=n>fields</span> <span class=o>=</span> <span class=k>new</span> <span class=n>HashMap</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span><span class=n>Type</span><span class=o>&gt;();</span>
</span></span><span class=line><span class=cl><span class=n>fields</span><span class=o>.</span><span class=na>put</span><span class=o>(</span><span class=s>&#34;data&#34;</span><span class=o>,</span><span class=k>new</span> <span class=n>Int</span><span class=o>());</span>
</span></span><span class=line><span class=cl><span class=n>fields</span><span class=o>.</span><span class=na>put</span><span class=o>(</span><span class=s>&#34;next&#34;</span><span class=o>,</span><span class=k>new</span> <span class=n>Recursive</span><span class=o>(</span><span class=s>&#34;X&#34;</span><span class=o>,</span><span class=kc>null</span><span class=o>));</span>
</span></span><span class=line><span class=cl><span class=n>Type</span> <span class=n>record</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Record</span><span class=o>(</span><span class=n>fields</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=c1>// finally, put it altogether
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Type</span> <span class=n>LinkedList</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Recursive</span><span class=o>(</span><span class=s>&#34;X&#34;</span><span class=o>,</span><span class=k>new</span> <span class=n>Union</span><span class=o>(</span><span class=k>new</span> <span class=n>Null</span><span class=o>(),</span><span class=n>record</span><span class=o>));</span>
</span></span></code></pre></div><p>This seems reasonably straightforward, and the type can be easily turned into a string such as <code>"X&lt;null|{int data, X next}>"</code>. We&rsquo;d also probably want to use the <a href=http://wikipedia.org/wiki/flyweight_pattern>flyweight pattern</a> to avoid creating lots of identical types.</p><p><em>So, what&rsquo;s the problem then?</em> well, there are a number of issues.  Firstly, we need to ensure that instances of <code>Recursive</code> don&rsquo;t have name clashes which causes unexpected variable captures (admittedly, this isn&rsquo;t too hard to do). Secondly, we need to ensure that <code>Recursive</code> variable names are <em>not significant</em> (i.e. that <code>X&lt;null|{int data, X next}></code> is identical to <code>Y&lt;null|{int data, Y next}></code>). Again, this is doable &mldr; but it starts to get complicated.</p><p>The final (and most significant) issue with this approach is that, in order to perform type minimisation, we need to view the type as a graph (see e.g. the diagrams above). Implementing types using the natural recursive tree decomposition makes it difficult (but, again, not completely impossible) to do this.</p><p>The bottom line is that, in my experience, implementing structural types like this <em>just makes things harder than they need to be</em>.</p><h2 id=better-idea>Better Idea</h2><p>The main problem with the above approach is that we end up with these ugly instances of <code>Recursive</code> all over the place. The tree decomposition is trying to hide the fact that our types are graphs, not trees.</p><p>In my new system, things look quite different:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>class</span> <span class=nc>Compound</span> <span class=o>{</span> <span class=n>Node</span><span class=o>[]</span> <span class=n>nodes</span><span class=o>;</span> <span class=o>...</span> <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>...</span>
</span></span><span class=line><span class=cl><span class=kd>private</span> <span class=kd>static</span> <span class=kd>final</span> <span class=kt>byte</span> <span class=n>K_NULL</span> <span class=o>=</span> <span class=n>2</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kd>private</span> <span class=kd>static</span> <span class=kd>final</span> <span class=kt>byte</span> <span class=n>K_BOOL</span> <span class=o>=</span> <span class=n>3</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kd>private</span> <span class=kd>static</span> <span class=kd>final</span> <span class=kt>byte</span> <span class=n>K_INT</span> <span class=o>=</span> <span class=n>4</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kd>private</span> <span class=kd>static</span> <span class=kd>final</span> <span class=kt>byte</span> <span class=n>K_RATIONAL</span> <span class=o>=</span> <span class=n>5</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kd>private</span> <span class=kd>static</span> <span class=kd>final</span> <span class=kt>byte</span> <span class=n>K_SET</span> <span class=o>=</span> <span class=n>6</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kd>private</span> <span class=kd>static</span> <span class=kd>final</span> <span class=kt>byte</span> <span class=n>K_LIST</span> <span class=o>=</span> <span class=n>7</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>...</span>
</span></span><span class=line><span class=cl><span class=kd>private</span> <span class=kd>static</span> <span class=kd>final</span> <span class=kt>byte</span> <span class=n>K_RECORD</span> <span class=o>=</span> <span class=n>10</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kd>private</span> <span class=kd>static</span> <span class=kd>final</span> <span class=kt>byte</span> <span class=n>K_UNION</span> <span class=o>=</span> <span class=n>11</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>...</span>
</span></span><span class=line><span class=cl><span class=kd>private</span> <span class=kd>static</span> <span class=kd>final</span> <span class=kt>byte</span> <span class=n>K_LABEL</span> <span class=o>=</span> <span class=n>13</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>class</span> <span class=nc>Node</span> <span class=o>{</span> <span class=kt>int</span> <span class=n>kind</span><span class=o>;</span> <span class=n>Object</span> <span class=n>data</span><span class=o>;</span> <span class=o>}</span>
</span></span></code></pre></div><p>In this representation, a type is made up of one or more <code>Node</code>s. Each node stores its <code>kind</code>, and also provides a <code>data</code> field for identifying its children. For primitive types, the <code>data</code> field is <code>null</code>, whilst for sets and lists it is an <code>Integer</code> (which identifies the child node). For records, it&rsquo;s a <code>Map&lt;String,Integer></code> which identifies the child node for each field. Finally, for unions, the data field is a <code>Set&lt;Integer></code>.</p><p>The following illustrates how this looks for our <code>LinkedList</code> example:</p><figure class=text-center><img width=600px src=/images/2011/RepresentingRecursiveTypes.png></figure><p>The nice thing about this is that we no longer need explicit <code>Recursive</code> instances. Thus, variable renaming and variable capture are impossible by construction. Futhermore, the graph representation is explicit and, hence, the type minimisation algorithm (see below) is easy to implement.</p><h2 id=nice-interfaces>Nice Interfaces</h2><p>The downside with the graph-based representation of types is that it is quite &ldquo;low-level&rdquo;.  To simplify things from the users perspective, we can also provide special classes to make manipulating <code>Compound</code> types easy. For example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>class</span> <span class=nc>Int</span> <span class=kd>extends</span> <span class=n>Compound</span> <span class=o>{</span> <span class=o>...</span> <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>class</span> <span class=nc>List</span> <span class=kd>extends</span> <span class=n>Compound</span> <span class=o>{</span> <span class=n>Type</span> <span class=nf>element</span><span class=o>()</span> <span class=o>{</span> <span class=o>...}</span> <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>class</span> <span class=nc>Record</span> <span class=kd>extends</span> <span class=n>Compound</span> <span class=o>{</span> <span class=n>Map</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span><span class=n>Type</span><span class=o>&gt;</span> <span class=nf>fields</span><span class=o>()</span> <span class=o>{</span> <span class=o>...</span> <span class=o>}</span> <span class=o>}</span>
</span></span></code></pre></div><p>These classes provide methods which return newly created instances of <code>Type</code> by extracting them from their underlying structure using a depth-first search. In this way, the user never has to interact with <code>Compound</code> structures directly &mldr; which will be a relief for them!  (<strong>note:</strong> of course, we need to carefully ensure the root node&rsquo;s kind matches the actual subclass of <code>Compound</code>).</p><h2 id=type-minimisation>Type Minimisation</h2><p>Having covered the representation of types, it&rsquo;s interesting to see how the type minimisation algorithm proceeds. Essentially, there are two stages:</p><ul><li><p>Constructing the <em>subtype matrix</em>.</p></li><li><p>Merging <em>equivalent nodes</em>, and eliminating <em>subsumed nodes</em>.</p></li></ul><p>The following example illustrates the subtype matrix:</p><figure class=text-center><img width=300px src=/images/2011/MinimisingRecursiveTypes2.png></figure><p>In the matrix, entries in dark gray are <code>true</code> and those in light gray are <code>false</code>.  We can determine whether node <code>X</code> is a subtype of node <code>Y</code> by checking column <code>Y</code> in row <code>X</code>.  For example, node <code>2</code> is a subtype of node <code>4</code>.  Once we have the subtype matrix, it is fairly easy to identify nodes which are <em>equivalent</em> &mdash; namely, those which are mutual subtypes (e.g. <code>0</code>≡<code>4</code> and <code>2</code>≡<code>6</code>).</p><p>To construct the subtype matrix, we initially set every cell to <code>true</code>. Then, we cross-off all subtype relationships which are obviously incorrect (e.g. node <code>5</code> cannot be a subtype of node <code>3</code>, since <code>null</code> isn&rsquo;t a subtype of <code>int</code>). This may, in turn, invalidate other subtype relationships &mdash; and we keep crossing them off until there aren&rsquo;t any left (i.e. until we&rsquo;ve reached a <em>fixed point</em>).</p><p>With the subtype matrix constructed, we can identify and merge equivalent nodes (which, for example, reduces <code>OuterList</code> to be identical to<code> LinkedList</code>). Similarly, we can eliminate subsumed nodes &mdash; e.g. in the type <code>int|real</code>, the <code>int</code> node is subsumed by the <code>real</code> node, letting us reduce <code>int|real</code> to <code>real</code>.</p><p><strong>Completeness.</strong> An interesting question is whether or not the algorithm for minimising types described above is <em>complete</em>.  That is, whether or not there are types which could be minimised, but are not by the algorithm.  It occurred to me, whilst I was implementing this, that the code was very similar to that for checking <a href=http://wikipedia.org/wiki/graph_isomorphism>graph isomorphism</a>.  In fact, it&rsquo;s easy to see that we can encode any graph using my type representation &mdash; which makes me think what we&rsquo;re doing here is similar, or identical, to the <a href=http://wikipedia.org/wiki/subgraph_isomorphism_problem>subgraph isomorphism problem</a>.  In turn, this makes we believe there are examples which it will not minimise (e.g. those equivalent to <a href=http://wikipedia.org/wiki/cubic_graph>cubic graph</a>s are a particular problem for partition-based graph isomorphism algorithms).</p><p><strong>Canonical Forms.</strong> Another interesting question is whether or not we can determine a <a href=http://wikipedia.org/wiki/canonical_form>canonical form</a> for a given type.  Again, this reminds me of the graph isomorphism problem, where the most successful solutions (e.g.<a href=http://cs.anu.edu.au/people/bdm/nauty/> Nauty</a>) operate by computing the canonical forms for their input graphs &mdash; and, once they have this, testing whether they are isomorphic is easy!</p><h2 id=java-code>Java Code</h2><p>My Java implementation of this structural type system can be found <a href=/files/2011/types.zip>here</a>.  It&rsquo;s a little bit more optimised than my description above, but it&rsquo;s otherwise pretty much identical.  Let me know if you find any bugs &mldr;</p><hr></div></div><script async src="https://www.googletagmanager.com/gtag/js?id=G-9MRLB1FVZX"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-9MRLB1FVZX",{anonymize_ip:!1})}</script></body></html>