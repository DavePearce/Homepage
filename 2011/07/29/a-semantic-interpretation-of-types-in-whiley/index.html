<!doctype html><html lang=en><head><script async src="https://www.googletagmanager.com/gtag/js?id=G-9MRLB1FVZX"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-9MRLB1FVZX",{anonymize_ip:!1})}</script><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta property="og:title" content="A Semantic Interpretation of Types in Whiley"><meta name=twitter:title content="A Semantic Interpretation of Types in Whiley"><meta property="og:url" content="https://whileydave.com/2011/07/29/a-semantic-interpretation-of-types-in-whiley/"><title>David J. Pearce
(A Semantic Interpretation of Types in Whiley)</title><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css><link rel=stylesheet href=https://whileydave.com/css/page.css><link rel=stylesheet href=https://whileydave.com/css/menu.css><link rel=stylesheet href=https://whileydave.com/css/style.css><link rel=stylesheet href=https://whileydave.com/css/syntax.css></head><body><script>"use strict";function clearMenu(){var e,t,n=window.matchMedia("(max-width: 992px)");n.matches&&(e=document.getElementById("menu-content"),t=document.getElementById("menu"),e.style.display="none",t.style.filter="")}function toggleMenu(){var e,t,n=window.matchMedia("(max-width: 992px)");n.matches&&(e=document.getElementById("menu-content"),t=document.getElementById("menu"),e.style.display==="block"?(e.style.display="none",t.style.filter=""):(e.style.display="block",t.style.filter="brightness(0.8)"))}function toggleList(e){e.style.display="none";for(var t,o=e.parentNode,s=o.childNodes,n=0;n<s.length;++n)t=s[n],t.classList&&t.classList.contains("hidden")&&(t.style.display==="block"?t.style.display="none":t.style.display="block")}</script><header class=topbar><div class=topbar-header onclick=clearMenu()><div class=topbar-title>Dr. David J. Pearce</div><div class=topbar-subtitle></div></div><div class=topbar-social onclick=clearMenu()><a href=https://github.com/DavePearce><i class="fa fa-github" aria-hidden=true></i></a>
<a href=https://twitter.com/WhileyDave><i class="fa fa-twitter" aria-hidden=true></i></a>
<a href=https://www.youtube.com/user/redjamjar/><i class="fa fa-youtube-play" aria-hidden=true></i></a>
<a href=https://www.linkedin.com/in/david-pearce-8592647/><i class="fa fa-linkedin-square" aria-hidden=true></i></a></div><div class=topbar-menu><div id=menu onclick=toggleMenu()><div id=menu-icon><img src=https://whileydave.com/images/menu.png alt=Menu></div><div id=menu-content><a href=https://whileydave.com/blog/>Blog</a>
<a href=https://whileydave.com/projects/>Projects</a>
<a href=https://whileydave.com/publications/>Publications</a>
<a href=https://whileydave.com/talks/>Talks</a>
<a href=https://whileydave.com/>Home</a></div></div></div></header><div class=container onclick=clearMenu()><div class=content><h1 class=post-title>A Semantic Interpretation of Types in Whiley</h1><div class=post-date>Friday, July
29th,
2011</div><hr><p>An interesting and intuitive way of thinking about a type system is using a <em>semantic interpretation</em>.  Typically, a set-theoretic model is used where a type <code>T</code> is a subtype of <code>S</code> iff every element in the set described by <code>T</code> is in the set described by <code>S</code>.</p><h2 id=the-semantic-model>The Semantic Model</h2><p>The starting point is to define our notion of types <code>T</code> and values <code>V</code>:</p><ul><li><p><code>T</code> ::= <code>null</code> | <code>int</code> | <code>any</code> | <code>[T]</code> | <code>{T1 f1, ... Tn fn}</code> | <code>T1 ∨ T2</code></p></li><li><p><code>V</code> ::= <code>null</code> | <code>i</code> | <code>[V1,...,Vn]</code> | <code>{f1: V1, ... f2: V2}</code></p></li></ul><p>This is a simplified notion of the types and values found in Whiley.  For example, I&rsquo;ve left out sets and function references and ignored recursive types altogether.</p><p>We can define our semantic model as follows using an acceptance relation <code>T</code> |= <code>V</code>, which holds if value <code>V</code> is in the set described by type <code>T</code>.</p><ol><li><p><code>null</code> |= <code>null</code></p></li><li><p><code>any</code> |= <code>V</code></p></li><li><p><code>int</code> |= <code>i</code>, <strong>if</strong> i ∈ <em>I</em> (the set of all integers)</p></li><li><p><code>[T]</code> |= <code>[V1,...Vn]</code>, <strong>if</strong> ∀1≤i≤n.[<code>T</code> |= <code>Vi</code>]</p></li><li><p><code>{T1 f1, ..., Tn fn}</code> |= <code>{f1: V1, ... fn: Vn}</code>, <strong>if</strong> <code>T1</code> |= <code>V1</code>, &mldr; <code>Tn</code> |= <code>Vn</code></p></li><li><p><code>T1 ∨ T2</code> |= <code>V</code>, <strong>if</strong> <code>T1</code> |= <code>V</code> <strong>or</strong> <code>T2</code> |= <code>V</code></p></li></ol><p><strong>Note:</strong> this model could be made more advanced by supporting <a href=https://en.wikipedia.org/wiki/Subtype_polymorphism#Record_types>width subtyping</a> &mdash; but its enough for now.</p><p>Finally, we can give a semantic notion of subtyping where <code>T1</code> |= <code>T2</code> holds if ∀<code>V</code>.[<code>T1</code> |= <code>V</code> <strong>implies</strong> <code>T2</code> |= <code>V</code>]. In otherwords, <code>T1</code> |= <code>T2</code> if <code>T1</code> is a subtype of <code>T2</code>.</p><h2 id=the-subtyping-algorithm>The Subtyping Algorithm</h2><p>Now that we have an &ldquo;intuitive&rdquo; model of what types should mean, we want to compare that against an actual algorithm for subtype testing. The following pseudo-code outlines the basic algorithm used in Whiley:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl><span class=c1>// Check whether t1 is a subtype of t2
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>bool</span> <span class=n>isSubtype</span><span class=p>(</span><span class=n>Type</span> <span class=n>t1</span><span class=p>,</span> <span class=n>Type</span> <span class=n>t2</span><span class=p>)</span><span class=o>:</span>
</span></span><span class=line><span class=cl>   <span class=c1>// rule 1
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=k>if</span> <span class=n>t2</span> <span class=k>is</span> <span class=n>any</span><span class=o>:</span>
</span></span><span class=line><span class=cl>       <span class=k>return</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>   <span class=c1>// rule 2
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=k>else</span> <span class=k>if</span> <span class=n>t1</span> <span class=o>==</span> <span class=n>t2</span><span class=o>:</span>
</span></span><span class=line><span class=cl>       <span class=k>return</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>   <span class=c1>// rule 3
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=k>else</span> <span class=k>if</span> <span class=n>t1</span> <span class=k>is</span> <span class=p>[</span><span class=n>t3</span><span class=p>]</span> <span class=o>&amp;&amp;</span> <span class=n>t2</span> <span class=k>is</span> <span class=p>[</span><span class=n>t4</span><span class=p>]</span><span class=o>:</span>
</span></span><span class=line><span class=cl>       <span class=k>return</span> <span class=n>isSubtype</span><span class=p>(</span><span class=n>t3</span><span class=p>,</span><span class=n>t4</span><span class=p>)</span>
</span></span><span class=line><span class=cl>   <span class=c1>// rule 4
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=k>else</span> <span class=k>if</span> <span class=n>t1</span> <span class=k>is</span> <span class=p>{</span><span class=n>t3</span> <span class=n>f3</span><span class=p>,</span> <span class=p>...,</span> <span class=n>Tn</span> <span class=n>fn</span><span class=p>}</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>            <span class=n>t2</span> <span class=k>is</span> <span class=p>{</span><span class=n>s3</span> <span class=n>f3</span><span class=p>,</span> <span class=p>...,</span> <span class=n>Sn</span> <span class=n>fn</span><span class=p>}</span><span class=o>:</span>
</span></span><span class=line><span class=cl>       <span class=k>for</span> <span class=n>i</span> <span class=k>in</span> <span class=mi>3</span><span class=p>..</span><span class=n>n</span><span class=o>:</span>
</span></span><span class=line><span class=cl>           <span class=k>if</span> <span class=o>!</span><span class=n>isSubtype</span><span class=p>(</span><span class=n>ti</span><span class=p>,</span><span class=n>si</span><span class=p>)</span><span class=o>:</span>
</span></span><span class=line><span class=cl>               <span class=k>return</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>       <span class=k>return</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>   <span class=c1>// rule 5
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=k>else</span> <span class=k>if</span> <span class=n>t1</span> <span class=k>is</span> <span class=p>(</span><span class=n>t3</span> <span class=err>∨</span> <span class=n>t4</span><span class=p>)</span><span class=o>:</span>
</span></span><span class=line><span class=cl>       <span class=k>return</span> <span class=n>isSubtype</span><span class=p>(</span><span class=n>t3</span><span class=p>,</span><span class=n>t2</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=n>isSubtype</span><span class=p>(</span><span class=n>t4</span><span class=p>,</span><span class=n>t2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>   <span class=c1>// rule 6
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=k>else</span> <span class=k>if</span> <span class=n>t2</span> <span class=k>is</span> <span class=p>(</span><span class=n>t3</span> <span class=err>∨</span> <span class=n>t4</span><span class=p>)</span><span class=o>:</span>
</span></span><span class=line><span class=cl>       <span class=k>return</span> <span class=n>isSubtype</span><span class=p>(</span><span class=n>t1</span><span class=p>,</span><span class=n>t3</span><span class=p>)</span> <span class=o>||</span> <span class=n>isSubtype</span><span class=p>(</span><span class=n>t1</span><span class=p>,</span><span class=n>t4</span><span class=p>)</span>
</span></span><span class=line><span class=cl>   <span class=c1>// rule 7
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=k>else</span><span class=o>:</span>
</span></span><span class=line><span class=cl>       <span class=k>return</span> <span class=kc>false</span>
</span></span></code></pre></div><p>Thus, for example, <code>isSubtype(int,any)</code> holds under rule 1, whilst <code>isSubtype(int,int ∨ null)</code> holds by rules 6+2.</p><h2 id=the-question>The Question</h2><blockquote><p><em>Is the subtyping algorithm sound and complete with respect to our semantic model?</em></p></blockquote><p>In some sense, the whole point of the semantic model is to let us ask this question.  We can break this down into two separate questions of <em>soundness</em> and <em>completeness</em>:</p><blockquote><p><strong>Soundness.</strong> If <code>isSubtype(T1,T2)</code> then <code>T1</code> |= <code>T2</code>.</p></blockquote><blockquote><p><strong>Completeness.</strong> If <code>T1</code> |= <code>T2</code> then <code>isSubtype(T1,T2)</code>.</p></blockquote><p>Considering these questions separately simplifies the problem.  I&rsquo;m not going to provide any proofs, but it&rsquo;s relatively easy to see that <code>isSubtype()</code> is sound.  The more interesting question is whether or not it is complete.</p><p>In fact, it turns out that the <code>isSubtype()</code> algorithm as given is <em>not complete</em>.  A simple counter-example is sufficient to show this.  Let <code>T1</code> = <code>{int ∨ null x}</code> and <code>T2</code> = <code>{int x} ∨ {null x}</code> .  Then, <code>T1</code> |= <code>T2</code>, but <code>isSubtype(T1,T2)</code> does not hold. This is because rule 6 requires <code>isSubtype(T1,{int x})</code> and <code>isSubtype(T1,{null x})</code> (neither of which hold).</p><p>The problem is that <code>isSubtype()</code> is not <em>distributive</em> over records. An interesting question is how we can fix it, but that&rsquo;s a story for another day!</p><p>If you&rsquo;re interested in learning more about this, I&rsquo;ve worked through the full system in <a href=/publications/ECSTR10-23.pdf>this paper</a>.  Also, the following reference provides a good introduction to semantic subtyping:</p><ul><li>&ldquo;<strong>A Gentle Introduction to Semantic Subtyping&rdquo;</strong>, Giuseppe Castagna and Alain Frisch. In <em>Proceedings of the ACM Conference on Principles and practice of declarative programming (PPDP)</em>, 2005. [<a href="http://portal.acm.org/citation.cfm?id=1069793">ACM Link</a>][<a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.65.8026&rep=rep1&type=pdf">PDF</a>]</li></ul><hr></div></div></body></html>