<!doctype html><html lang=en><head><script async src="https://www.googletagmanager.com/gtag/js?id=G-9MRLB1FVZX"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-9MRLB1FVZX",{anonymize_ip:!1})}</script><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta property="og:title" content="Bits, Bytes and More Ambiguous Syntax"><meta name=twitter:title content="Bits, Bytes and More Ambiguous Syntax"><meta property="og:url" content="https://whileydave.com/2011/07/04/bits-bytes-and-more-ambiguous-syntax/"><title>David J. Pearce
(Bits, Bytes and More Ambiguous Syntax)</title><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css><link rel=stylesheet href=https://whileydave.com/css/page.css><link rel=stylesheet href=https://whileydave.com/css/menu.css><link rel=stylesheet href=https://whileydave.com/css/style.css><link rel=stylesheet href=https://whileydave.com/css/syntax.css></head><body><script>"use strict";function clearMenu(){var e,t,n=window.matchMedia("(max-width: 992px)");n.matches&&(e=document.getElementById("menu-content"),t=document.getElementById("menu"),e.style.display="none",t.style.filter="")}function toggleMenu(){var e,t,n=window.matchMedia("(max-width: 992px)");n.matches&&(e=document.getElementById("menu-content"),t=document.getElementById("menu"),e.style.display==="block"?(e.style.display="none",t.style.filter=""):(e.style.display="block",t.style.filter="brightness(0.8)"))}function toggleList(e){e.style.display="none";for(var t,o=e.parentNode,s=o.childNodes,n=0;n<s.length;++n)t=s[n],t.classList&&t.classList.contains("hidden")&&(t.style.display==="block"?t.style.display="none":t.style.display="block")}</script><header class=topbar><div class=topbar-header onclick=clearMenu()><div class=topbar-title>Dr. David J. Pearce</div><div class=topbar-subtitle></div></div><div class=topbar-social onclick=clearMenu()><a href=https://github.com/DavePearce><i class="fa fa-github" aria-hidden=true></i></a>
<a href=https://twitter.com/WhileyDave><i class="fa fa-twitter" aria-hidden=true></i></a>
<a href=https://www.youtube.com/user/redjamjar/><i class="fa fa-youtube-play" aria-hidden=true></i></a>
<a href=https://www.linkedin.com/in/david-pearce-8592647/><i class="fa fa-linkedin-square" aria-hidden=true></i></a></div><div class=topbar-menu><div id=menu onclick=toggleMenu()><div id=menu-icon><img src=https://whileydave.com/images/menu.png alt=Menu></div><div id=menu-content><a href=https://whileydave.com/blog/>Blog</a>
<a href=https://whileydave.com/projects/>Projects</a>
<a href=https://whileydave.com/publications/>Publications</a>
<a href=https://whileydave.com/talks/>Talks</a>
<a href=https://whileydave.com/>Home</a></div></div></div></header><div class=container onclick=clearMenu()><div class=content><h1 class=post-title>Bits, Bytes and More Ambiguous Syntax</h1><div class=post-date>Monday, July
4th,
2011</div><hr><p>Recently, I added a first-class <code>byte</code> type to Whiley.Â  Unlike Java, this is not interpreted as some kind of signed or unsigned <code>int</code>. That&rsquo;s because I find that very confusing since a <code>byte</code> is really just a sequence of bits without any interpretation.</p><p>Therefore, in Whiley, a <code>byte</code> is just that: a bit sequence on which you can perform the usual operations, such as bitwise AND/OR/XOR operations, as well as left and right shifts. Here&rsquo;s a snipper which accepts a <code>byte</code> and converts it into an unsigned <code>int</code> assuming a little endian representation:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl><span class=kt>int</span> <span class=n>le2uint</span><span class=p>(</span><span class=kt>byte</span> <span class=n>b</span><span class=p>)</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>r</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=n>base</span> <span class=o>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>b</span> <span class=o>!=</span> <span class=mi>0</span><span class=n>b</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>b</span> <span class=o>&amp;</span> <span class=mi>00000001</span><span class=n>b</span><span class=p>)</span> <span class=o>==</span> <span class=mi>00000001</span><span class=n>b</span><span class=o>:</span>
</span></span><span class=line><span class=cl>            <span class=n>r</span> <span class=o>=</span> <span class=n>r</span> <span class=o>+</span> <span class=n>base</span>
</span></span><span class=line><span class=cl>        <span class=n>b</span> <span class=o>=</span> <span class=n>b</span> <span class=o>&gt;&gt;</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=n>base</span> <span class=o>=</span> <span class=n>base</span> <span class=o>*</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>r</span>
</span></span></code></pre></div><p>As usual, updating the compiler to support the <code>byte</code> type did not go according to plan. That&rsquo;s because I ran into yet another ambiguity of syntax. This time the ambiguity is surrounding the <code>|</code> operator, which represents bitwise OR and is also a delineator for set comprehensions. Consider these three examples:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl><span class=n>x</span> <span class=o>=</span> <span class=n>b1</span> <span class=o>|</span> <span class=n>b2</span>    <span class=c1>// bitwise OR
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>y</span> <span class=o>=</span> <span class=p>{</span> <span class=n>a</span> <span class=o>|</span> <span class=n>a</span> <span class=k>in</span> <span class=n>as</span><span class=p>,</span>  <span class=n>a</span> <span class=o>&gt;</span> <span class=mi>0</span> <span class=p>}</span>    <span class=c1>// comprehension
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>z</span> <span class=o>=</span> <span class=p>{</span> <span class=n>a</span> <span class=o>|</span> <span class=n>a</span> <span class=k>in</span> <span class=n>ys</span> <span class=p>}</span>    <span class=c1>// hmmmm, set generator or comprehension?
</span></span></span></code></pre></div><p>In fact, it&rsquo;s fairly easy to disambiguate the last statement &mdash; it must be a set comprehension. That&rsquo;s because <code>a in ys</code> has <code>bool</code> type, and this cannot be part of a bitwise OR operation. However, at the point it needs to make this decision, the compiler doesn&rsquo;t have access to type information. This is because type propagation occurs after the source has been translated into the intermediate language (wyil). But, there is no bytecode in the Wyil for a comprehension and, instead, it is constructed using <code>for</code> loops).</p><p>I believe it is possible to disambiguate bitwise OR from a set comprehension in the parser &mdash; however, for the moment, I just resolve it by preferring set comprehensions over bitwise OR. The impact of this is that the expression <code>{ a|b }</code> won&rsquo;t parse because it&rsquo;s not a valid set comprehension (but is a valid set generator). Instead, you have to help the parser using braces. So, <code>{ a|b }</code> becomes <code>{ (a|b) }</code>.</p><hr></div></div></body></html>