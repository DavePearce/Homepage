<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Blog on Dave's Homepage</title><link>https://whileydave.com/blog/</link><description>Recent content in Blog on Dave's Homepage</description><generator>Hugo -- gohugo.io</generator><language>en-nz</language><lastBuildDate>Fri, 13 Oct 2017 20:31:39 -0500</lastBuildDate><atom:link href="https://whileydave.com/blog/index.xml" rel="self" type="application/rss+xml"/><item><title>Fooling the Borrow Checker</title><link>https://whileydave.com/2021/09/01/fooling-the-borrow-checker/</link><pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate><guid>https://whileydave.com/2021/09/01/fooling-the-borrow-checker/</guid><description>An interesting question is how the Rust borrow checker decides when a borrow could still be live. This illustrates a simple example:
letmutx=1234;letz=f(&amp;amp;x);...The question here is whether or not the borrow &amp;amp;x is still live after the method call.</description></item><item><title>Sizing Up Types in Rust</title><link>https://whileydave.com/2021/07/15/sizing-up-types-in-rust/</link><pubDate>Thu, 15 Jul 2021 00:00:00 +0000</pubDate><guid>https://whileydave.com/2021/07/15/sizing-up-types-in-rust/</guid><description>When learning Rust, understanding the difference between statically and dynamically sized types seems critical. There are some good discussions out there already (e.g. here and here). Whilst these explain the mechanics, they didn&amp;rsquo;t tell me why its done like this in Rust.</description></item><item><title>Understanding Generic Type Variance (in Whiley)</title><link>https://whileydave.com/2021/03/14/understanding-generic-type-variance-in-whiley/</link><pubDate>Sun, 14 Mar 2021 00:00:00 +0000</pubDate><guid>https://whileydave.com/2021/03/14/understanding-generic-type-variance-in-whiley/</guid><description>For languages which support generic types, an important question is deciding whether or not a type C&amp;lt;T&amp;gt; is a subtype of another related type C&amp;lt;S&amp;gt;. Since Whiley was recently extended to support generic types, its interesting to think about how this was handled.</description></item><item><title>Dynamic Cycle Detection for Lock Ordering</title><link>https://whileydave.com/2020/12/19/dynamic-cycle-detection-for-lock-ordering/</link><pubDate>Sat, 19 Dec 2020 00:00:00 +0000</pubDate><guid>https://whileydave.com/2020/12/19/dynamic-cycle-detection-for-lock-ordering/</guid><description>Recently, I discovered that an algorithm of mine from a few years back is being used in both TensorFlow and the Abseil C++ library (see here and here). That is of course pretty exciting since they are both widely used libraries!</description></item><item><title>Automated Testing for Whiley</title><link>https://whileydave.com/2020/12/02/automated-testing-for-whiley/</link><pubDate>Wed, 02 Dec 2020 00:00:00 +0000</pubDate><guid>https://whileydave.com/2020/12/02/automated-testing-for-whiley/</guid><description>Recently, the online editor for Whiley was updated with some new features. Actually, the update represents a complete rewrite of the front-end in Whiley. Obviously, I am very excited about that!</description></item><item><title>Understanding Partial Moves in Rust</title><link>https://whileydave.com/2020/11/30/understanding-partial-moves-in-rust/</link><pubDate>Mon, 30 Nov 2020 00:00:00 +0000</pubDate><guid>https://whileydave.com/2020/11/30/understanding-partial-moves-in-rust/</guid><description>Recently I&amp;rsquo;ve been digging into Rust and, whilst it&amp;rsquo;s a great language on many fronts, I do find lots of hidden complexity. One example which doesn&amp;rsquo;t get much attention is partial moves.</description></item><item><title>The Semantics of Semantic Versioning?</title><link>https://whileydave.com/2020/09/24/the-semantics-of-semantic-versioning/</link><pubDate>Thu, 24 Sep 2020 00:00:00 +0000</pubDate><guid>https://whileydave.com/2020/09/24/the-semantics-of-semantic-versioning/</guid><description>Semantic versioning is a surprisingly interesting topic when you get into it. Recently, myself and a few colleagues (Patrick &amp;amp; Jens) have been giving it some thought (and we even wrote an essay on it)!</description></item><item><title>Whiley is Ten Years Old!</title><link>https://whileydave.com/2020/09/01/whiley-is-ten-years-old/</link><pubDate>Tue, 01 Sep 2020 00:00:00 +0000</pubDate><guid>https://whileydave.com/2020/09/01/whiley-is-ten-years-old/</guid><description>The first commit recorded in the WhileyCompiler repository on Github is dated June 25th, 2010. That means Whiley has been going for just over ten years already! Wow, time sure does fly.</description></item></channel></rss>