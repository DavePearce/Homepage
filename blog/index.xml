<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Blog on Dave's Homepage</title><link>https://whileydave.com/blog/</link><description>Recent content in Blog on Dave's Homepage</description><generator>Hugo -- gohugo.io</generator><language>en-nz</language><lastBuildDate>Fri, 13 Oct 2017 20:31:39 -0500</lastBuildDate><atom:link href="https://whileydave.com/blog/index.xml" rel="self" type="application/rss+xml"/><item><title>Efficient Functions in Dafny</title><link>https://whileydave.com/2023/09/16/efficient-functions-in-dafny/</link><pubDate>Sat, 16 Sep 2023 00:00:00 +0000</pubDate><guid>https://whileydave.com/2023/09/16/efficient-functions-in-dafny/</guid><description>In developing an EVM in Dafny, a key requirement is to test it against the official EVM test suite. This means it needs to be at least reasonably efficient, otherwise completing a test run becomes impractical.</description></item><item><title>Proving a Beautiful Identity in Dafny</title><link>https://whileydave.com/2023/07/17/proving-a-beautiful-identity-in-dafny/</link><pubDate>Mon, 17 Jul 2023 00:00:00 +0000</pubDate><guid>https://whileydave.com/2023/07/17/proving-a-beautiful-identity-in-dafny/</guid><description>Recently, I came across a tweet about the following identity:
This seemed quite surprising to me, though the tweet&amp;rsquo;s thread included a number of proofs. We can check the first few values easily for ourself:</description></item><item><title>Programming Languages Going Above and Beyond</title><link>https://whileydave.com/2023/06/27/programming-languages-going-above-and-beyond/</link><pubDate>Tue, 27 Jun 2023 00:00:00 +0000</pubDate><guid>https://whileydave.com/2023/06/27/programming-languages-going-above-and-beyond/</guid><description>Having been a programmer for a long time now, I have experienced my fair share of programming languages. What strikes me the most is that programming languages have not improved much over the years.</description></item><item><title>Pattern Matching in Rust's Neverland</title><link>https://whileydave.com/2023/04/16/pattern-matching-in-rusts-neverland/</link><pubDate>Sun, 16 Apr 2023 00:00:00 +0000</pubDate><guid>https://whileydave.com/2023/04/16/pattern-matching-in-rusts-neverland/</guid><description>Recently, I&amp;rsquo;ve been working on a tool for manipulating EVM bytecode and assembly language. I wanted to describe low level bytecode and assembly language using the same datatype. At the same time, I wanted some instructions to be allowed only in assembly language but not bytecode (e.</description></item><item><title>Formalising the Ethereum Virtual Machine in Dafny</title><link>https://whileydave.com/2023/02/06/formalising-the-ethereum-virtual-machine-in-dafny/</link><pubDate>Mon, 06 Feb 2023 00:00:00 +0000</pubDate><guid>https://whileydave.com/2023/02/06/formalising-the-ethereum-virtual-machine-in-dafny/</guid><description>Since starting at ConsenSys, the main project I have been involved with is a formalisation of the Ethereum Virtual Machine in Dafny called the &amp;ldquo;DafnyEVM&amp;rdquo;. Our goals share some similarity with Runtime Verification&amp;rsquo;s KEVM project.</description></item><item><title>Disassembling EVM Bytecode (the Basics)</title><link>https://whileydave.com/2023/01/04/disassembling-evm-bytecode-the-basics/</link><pubDate>Wed, 04 Jan 2023 00:00:00 +0000</pubDate><guid>https://whileydave.com/2023/01/04/disassembling-evm-bytecode-the-basics/</guid><description>Recently, I&amp;rsquo;ve been looking at how to disassemble (and eventually decompile) bytecode for the Ethereum Virtual Machine (EVM). This is an interesting computer science problem which I&amp;rsquo;ve been thinking about lately.</description></item><item><title>Formal Verification of a Token Contract</title><link>https://whileydave.com/2022/09/15/formal-verification-of-a-token-contract/</link><pubDate>Thu, 15 Sep 2022 00:00:00 +0000</pubDate><guid>https://whileydave.com/2022/09/15/formal-verification-of-a-token-contract/</guid><description>Following on from my previous post on verifying an auction contract in Whiley, I thought it might be useful to look at a more challenging example. A token contract is a very common form of smart contract which allows someone to create and manage their own currency.</description></item><item><title>Formalising a Simple Virtual Machine</title><link>https://whileydave.com/2022/06/28/formalising-a-simple-virtual-machine/</link><pubDate>Tue, 28 Jun 2022 00:00:00 +0000</pubDate><guid>https://whileydave.com/2022/06/28/formalising-a-simple-virtual-machine/</guid><description>Since starting my new role at ConsenSys, I have become interested in formalising virtual machines. For example, there are already some formalisations of the Ethereum Virtual Machine (e.g. in K, Lem, Coq).</description></item><item><title>Type Checking in Whiley goes Both Ways!</title><link>https://whileydave.com/2022/06/15/type-checking-in-whiley-goes-both-ways/</link><pubDate>Wed, 15 Jun 2022 00:00:00 +0000</pubDate><guid>https://whileydave.com/2022/06/15/type-checking-in-whiley-goes-both-ways/</guid><description>Type checking in Whiley is a curious thing as it goes both forwards and backwards. This is sometimes referred to as bidirectional type checking (see e.g. here and here). This is surprisingly useful in Whiley (perhaps because the language has a reasonably unusual feature set).</description></item><item><title>Whiley gets Rusty!</title><link>https://whileydave.com/2022/05/31/whiley-gets-rusty/</link><pubDate>Tue, 31 May 2022 00:00:00 +0000</pubDate><guid>https://whileydave.com/2022/05/31/whiley-gets-rusty/</guid><description>I&amp;rsquo;ve been learning Rust for a while now but, at the same time, trying to continue developing Whiley. Since Whiley was written entirely in Java, these activities were mutually exclusive and it was frustrating trying to balance things!</description></item><item><title>Verifying an Auction Contract in Whiley</title><link>https://whileydave.com/2022/05/17/verifying-an-auction-contract-in-whiley/</link><pubDate>Tue, 17 May 2022 00:00:00 +0000</pubDate><guid>https://whileydave.com/2022/05/17/verifying-an-auction-contract-in-whiley/</guid><description>Since Whiley is a general purpose verification system, I thought it might be interesting to try and verify a smart contract. Smart contracts are well suited to formal verification tools (like Whiley), as they are small and typically self-contained.</description></item><item><title>Puzzling Strong Updates in Rust</title><link>https://whileydave.com/2022/04/27/puzzling-strong-updates-in-rust/</link><pubDate>Wed, 27 Apr 2022 00:00:00 +0000</pubDate><guid>https://whileydave.com/2022/04/27/puzzling-strong-updates-in-rust/</guid><description>The idea of a strong update comes from earlier work on static analysis and, in particular, pointer analysis. To understand this, let&amp;rsquo;s imagine a hypothetical non-null analysis for C:
int* r = (int*) malloc(sizeof(int)); int** p = &amp;amp;r; At this point, our non-null analysis would conclude that p was nonnull and that r was nullable.</description></item><item><title>Modelling Borrow Checking in Rust</title><link>https://whileydave.com/2021/12/06/modelling-borrow-checking-in-rust/</link><pubDate>Mon, 06 Dec 2021 00:00:00 +0000</pubDate><guid>https://whileydave.com/2021/12/06/modelling-borrow-checking-in-rust/</guid><description>Recently, I&amp;rsquo;ve been working on a formalisation of borrow checking in Rust. The idea is to help people think clearly about how borrow checking works (in someways perhaps similar to the Stacked Borrows work but with a different perspective).</description></item><item><title>Verifying the Whiley Standard Library</title><link>https://whileydave.com/2021/10/27/verifying-the-whiley-standard-library/</link><pubDate>Wed, 27 Oct 2021 00:00:00 +0000</pubDate><guid>https://whileydave.com/2021/10/27/verifying-the-whiley-standard-library/</guid><description>For sometime now, its been possible to use Boogie / Z3 as a backend for verifying Whiley programs. Initially that was pretty sketchy, but it&amp;rsquo;s really starting to ramp up now.</description></item><item><title>Test-Driving the Rust Model Checker (RMC)</title><link>https://whileydave.com/2021/10/26/test-driving-the-rust-model-checker-rmc/</link><pubDate>Tue, 26 Oct 2021 00:00:00 +0000</pubDate><guid>https://whileydave.com/2021/10/26/test-driving-the-rust-model-checker-rmc/</guid><description>The Rust Model Checker (RMC) allows Rust programs to be model checked using the C Bounded Model Checker (CBMC). In essence, RMC is an extension to the Rust compiler which converts Rust&amp;rsquo;s MIR into the input language of CBMC (GOTO).</description></item><item><title>Fooling the Borrow Checker</title><link>https://whileydave.com/2021/09/01/fooling-the-borrow-checker/</link><pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate><guid>https://whileydave.com/2021/09/01/fooling-the-borrow-checker/</guid><description>An interesting question is how the Rust borrow checker decides when a borrow could still be live. This illustrates a simple example:
let mut x = 1234; let z = f(&amp;amp;x); .</description></item><item><title>Sizing Up Types in Rust</title><link>https://whileydave.com/2021/07/15/sizing-up-types-in-rust/</link><pubDate>Thu, 15 Jul 2021 00:00:00 +0000</pubDate><guid>https://whileydave.com/2021/07/15/sizing-up-types-in-rust/</guid><description>When learning Rust, understanding the difference between statically and dynamically sized types seems critical. There are some good discussions out there already (e.g. here and here). Whilst these explain the mechanics, they didn&amp;rsquo;t tell me why its done like this in Rust.</description></item><item><title>Understanding Generic Type Variance (in Whiley)</title><link>https://whileydave.com/2021/03/14/understanding-generic-type-variance-in-whiley/</link><pubDate>Sun, 14 Mar 2021 00:00:00 +0000</pubDate><guid>https://whileydave.com/2021/03/14/understanding-generic-type-variance-in-whiley/</guid><description>For languages which support generic types, an important question is deciding whether or not a type C&amp;lt;T&amp;gt; is a subtype of another related type C&amp;lt;S&amp;gt;. Since Whiley was recently extended to support generic types, its interesting to think about how this was handled.</description></item><item><title>Dynamic Cycle Detection for Lock Ordering</title><link>https://whileydave.com/2020/12/19/dynamic-cycle-detection-for-lock-ordering/</link><pubDate>Sat, 19 Dec 2020 00:00:00 +0000</pubDate><guid>https://whileydave.com/2020/12/19/dynamic-cycle-detection-for-lock-ordering/</guid><description>Recently, I discovered that an algorithm of mine from a few years back is being used in both TensorFlow and the Abseil C++ library (see here and here). That is of course pretty exciting since they are both widely used libraries!</description></item><item><title>Automated Testing for Whiley</title><link>https://whileydave.com/2020/12/02/automated-testing-for-whiley/</link><pubDate>Wed, 02 Dec 2020 00:00:00 +0000</pubDate><guid>https://whileydave.com/2020/12/02/automated-testing-for-whiley/</guid><description>Recently, the online editor for Whiley was updated with some new features. Actually, the update represents a complete rewrite of the front-end in Whiley. Obviously, I am very excited about that!</description></item><item><title>Understanding Partial Moves in Rust</title><link>https://whileydave.com/2020/11/30/understanding-partial-moves-in-rust/</link><pubDate>Mon, 30 Nov 2020 00:00:00 +0000</pubDate><guid>https://whileydave.com/2020/11/30/understanding-partial-moves-in-rust/</guid><description>Recently I&amp;rsquo;ve been digging into Rust and, whilst it&amp;rsquo;s a great language on many fronts, I do find lots of hidden complexity. One example which doesn&amp;rsquo;t get much attention is partial moves.</description></item><item><title>The Semantics of Semantic Versioning?</title><link>https://whileydave.com/2020/09/24/the-semantics-of-semantic-versioning/</link><pubDate>Thu, 24 Sep 2020 00:00:00 +0000</pubDate><guid>https://whileydave.com/2020/09/24/the-semantics-of-semantic-versioning/</guid><description>Semantic versioning is a surprisingly interesting topic when you get into it. Recently, myself and a few colleagues (Patrick &amp;amp; Jens) have been giving it some thought (and we even wrote an essay on it)!</description></item><item><title>Whiley is Ten Years Old!</title><link>https://whileydave.com/2020/09/01/whiley-is-ten-years-old/</link><pubDate>Tue, 01 Sep 2020 00:00:00 +0000</pubDate><guid>https://whileydave.com/2020/09/01/whiley-is-ten-years-old/</guid><description>The first commit recorded in the WhileyCompiler repository on Github is dated June 25th, 2010. That means Whiley has been going for just over ten years already! Wow, time sure does fly.</description></item><item><title>Verifying leftPad() in Whiley</title><link>https://whileydave.com/2018/04/23/verifying-leftpad-in-whiley/</link><pubDate>Mon, 23 Apr 2018 00:00:00 +0000</pubDate><guid>https://whileydave.com/2018/04/23/verifying-leftpad-in-whiley/</guid><description>The leftPad(string,int) function simply pads a string up to a given size by inserted spaces at the beginning. For example, leftPad(&amp;quot;hello&amp;quot;,8) produces &amp;quot; hello&amp;quot;. This little function shot to fame in 2016 when a developer pulled all his modules from NPM, of which one provided the leftPad() functionality.</description></item><item><title>Verifying Bubble Sort in Whiley</title><link>https://whileydave.com/2017/12/19/verifying-bubble-sort-in-whiley/</link><pubDate>Tue, 19 Dec 2017 00:00:00 +0000</pubDate><guid>https://whileydave.com/2017/12/19/verifying-bubble-sort-in-whiley/</guid><description>Bubble sort is a classic sorting algorithm with lots of well-known issues. It&amp;rsquo;s been a long time since I thought much about this algorithm. But, it turns out to be an interesting verification example for Whiley, as it has some interesting loop invariants.</description></item><item><title>Whiley Demo @ Oracle Labs!!</title><link>https://whileydave.com/2017/08/24/whiley-demo-oracle-labs/</link><pubDate>Thu, 24 Aug 2017 00:00:00 +0000</pubDate><guid>https://whileydave.com/2017/08/24/whiley-demo-oracle-labs/</guid><description>Recently, I gave a demo of Whiley at Oracle Labs in Brisbane which they have kindly put up on YouTube:
The actual demo itself starts around 11:30s, so you might want to skip on to that.</description></item><item><title>On the Internet and Object-Oriented Programming</title><link>https://whileydave.com/2017/06/21/on-the-internet-and-object-oriented-programming/</link><pubDate>Wed, 21 Jun 2017 00:00:00 +0000</pubDate><guid>https://whileydave.com/2017/06/21/on-the-internet-and-object-oriented-programming/</guid><description>The rise of the internet over the last, say, two decades has been pretty unstoppable (we all know that). But, is it now affecting the prominence of object-oriented programming? I&amp;rsquo;m going to try and argue in this post that: yes, it is.</description></item><item><title>Property Syntax in Whiley</title><link>https://whileydave.com/2017/03/28/property-syntax-in-whiley/</link><pubDate>Tue, 28 Mar 2017 00:00:00 +0000</pubDate><guid>https://whileydave.com/2017/03/28/property-syntax-in-whiley/</guid><description>Recently, I gave a demo which showed off thew new &amp;ldquo;Property Syntax&amp;rdquo; in Whiley. Whilst this is still in the devel branch it will make its way, soon enough, into the next release.</description></item><item><title>On Memory Management and Rust</title><link>https://whileydave.com/2017/02/15/on-memory-management-and-rust/</link><pubDate>Wed, 15 Feb 2017 00:00:00 +0000</pubDate><guid>https://whileydave.com/2017/02/15/on-memory-management-and-rust/</guid><description>Rust is definitely one of the more interesting new programming language I&amp;rsquo;ve come across recently. Memory management is definitely Rust&amp;rsquo;s &amp;ldquo;thing&amp;rdquo;, and the language wants to have its cake and eat it (so to speak).</description></item><item><title>Understanding Effective Unions in Whiley</title><link>https://whileydave.com/2016/12/09/understanding-effective-unions-in-whiley/</link><pubDate>Fri, 09 Dec 2016 00:00:00 +0000</pubDate><guid>https://whileydave.com/2016/12/09/understanding-effective-unions-in-whiley/</guid><description>The concept of effective union types in Whiley exposes some interesting features worth considering. In particular, they result in a separation between the readable and writeable view of a type. But, we&amp;rsquo;re getting ahead of ourselves!</description></item><item><title>Mixfix Function Syntax for Whiley</title><link>https://whileydave.com/2016/11/15/mixfix-function-syntax-for-whiley/</link><pubDate>Tue, 15 Nov 2016 00:00:00 +0000</pubDate><guid>https://whileydave.com/2016/11/15/mixfix-function-syntax-for-whiley/</guid><description>Today I saw an interesting talk about mix-fix function syntax. The idea is to allow a more complex syntax for declaring and calling functions, rather than the very common &amp;ldquo;uniform&amp;rdquo; style.</description></item><item><title>Program Specification in Practice?</title><link>https://whileydave.com/2016/09/01/program-specification-in-practice/</link><pubDate>Thu, 01 Sep 2016 00:00:00 +0000</pubDate><guid>https://whileydave.com/2016/09/01/program-specification-in-practice/</guid><description>Recently, as part of our Programming Languages Reading group, we looked at the paper &amp;ldquo;Contracts in Practice&amp;rdquo; by Estler et al., (see here for a copy). This is quite an interesting paper and the authors perform an empirical investigation as to how contracts are used by programmers in practice.</description></item><item><title>Flow Typing with Constrained Types</title><link>https://whileydave.com/2016/08/03/flow-typing-with-constrained-types/</link><pubDate>Wed, 03 Aug 2016 00:00:00 +0000</pubDate><guid>https://whileydave.com/2016/08/03/flow-typing-with-constrained-types/</guid><description>Flow-sensitive typing (a.k.a. &amp;ldquo;Flow Typing&amp;rdquo;) is definitely getting more popular these days. Ceylon, Kotlin, TypeScript, Racket, Whiley all support flow typing in some form. Then, of course, there&amp;rsquo;s Facebook Flow and the list goes on!</description></item><item><title>Reference Lifetimes in Whiley</title><link>https://whileydave.com/2016/05/28/reference-lifetimes-in-whiley/</link><pubDate>Sat, 28 May 2016 00:00:00 +0000</pubDate><guid>https://whileydave.com/2016/05/28/reference-lifetimes-in-whiley/</guid><description>The concept of lifetimes was pioneered in the Rust programming language, and builds on earlier notions of regions and ownership types. Lifetimes are considered one of Rust&amp;rsquo;s &amp;ldquo;most unique and compelling features&amp;rdquo;.</description></item><item><title>Contractive and Uninhabited Types in Whiley</title><link>https://whileydave.com/2016/04/21/contractive-and-uninhabited-types-in-whiley/</link><pubDate>Thu, 21 Apr 2016 00:00:00 +0000</pubDate><guid>https://whileydave.com/2016/04/21/contractive-and-uninhabited-types-in-whiley/</guid><description>An interesting feature of Whiley is that it supports true recursive types. These are surprisingly tricky to get right, and recently we came across some interesting examples that the Whiley compiler should (but doesn&amp;rsquo;t) check for.</description></item><item><title>Encoding C Strings in Whiley</title><link>https://whileydave.com/2015/11/12/encoding-c-strings-in-whiley/</link><pubDate>Thu, 12 Nov 2015 00:00:00 +0000</pubDate><guid>https://whileydave.com/2015/11/12/encoding-c-strings-in-whiley/</guid><description>In this post, we&amp;rsquo;re going to consider representing the classic C string in Whiley. This turns out to be useful as we can then try to verify properties about functions which operate on C strings (e.</description></item><item><title>Verifying Software with Whiley</title><link>https://whileydave.com/2015/10/06/verifying-software-with-whiley/</link><pubDate>Tue, 06 Oct 2015 00:00:00 +0000</pubDate><guid>https://whileydave.com/2015/10/06/verifying-software-with-whiley/</guid><description>A couple of weeks back, I gave a presentation to the Wellington Java User Group. The talk provides a useful introduction to verifying software in Whiley, and shows a bunch of interesting examples.</description></item><item><title>Introductory Lecture on Verification in Whiley</title><link>https://whileydave.com/2015/09/22/introductory-lecture-on-verification-in-whiley/</link><pubDate>Tue, 22 Sep 2015 00:00:00 +0000</pubDate><guid>https://whileydave.com/2015/09/22/introductory-lecture-on-verification-in-whiley/</guid><description>We&amp;rsquo;ve started using Whiley again in my second year course Formal Foundations of Programming. The aim of this course is to introduce students into a range of techniques related to software correctness.</description></item><item><title>My ATtiny85 Games Console</title><link>https://whileydave.com/2015/01/27/my-attiny85-games-console/</link><pubDate>Tue, 27 Jan 2015 00:00:00 +0000</pubDate><guid>https://whileydave.com/2015/01/27/my-attiny85-games-console/</guid><description>One my goals for Whiley in 2015 is to focus more on embedded systems (see here for more). A recent project of ours was compiling Whiley code to run on a QuadCopter and this identified several challenges here.</description></item><item><title>Verification with Data from Untrusted Sources</title><link>https://whileydave.com/2014/12/09/verification-with-data-from-untrusted-sources/</link><pubDate>Tue, 09 Dec 2014 00:00:00 +0000</pubDate><guid>https://whileydave.com/2014/12/09/verification-with-data-from-untrusted-sources/</guid><description>Recently, I was listening to the latest edition of the Illegal Argument podcast, and it turns out they were discussing Whiley! (about 103:16 minutes in). The discussion was about how verification interacts with data from an untrusted source (e.</description></item><item><title>A Story of Cast Expressions</title><link>https://whileydave.com/2014/09/05/a-story-of-cast-expressions/</link><pubDate>Fri, 05 Sep 2014 00:00:00 +0000</pubDate><guid>https://whileydave.com/2014/09/05/a-story-of-cast-expressions/</guid><description>Issue #427 &amp;ldquo;Bug with Dereferencing Array Types&amp;rdquo; seemed like just another bug. Submitted by a user last week (@Matt&amp;ndash;), I didn&amp;rsquo;t think too much of it. But, as sometimes happens, appearances can be deceiving.</description></item><item><title>Loop Variant Relations</title><link>https://whileydave.com/2014/07/10/loop-variant-relations/</link><pubDate>Thu, 10 Jul 2014 00:00:00 +0000</pubDate><guid>https://whileydave.com/2014/07/10/loop-variant-relations/</guid><description>Proving that a loop always terminates is a common requirement when verifying software. The usual approach to doing this is to provide a loop variant function. This is typically an integer expression which decreases on every iteration of the loop.</description></item><item><title>Understanding Ghost Variables in Software Verification</title><link>https://whileydave.com/2014/06/20/understanding-ghost-variables-in-software-verification/</link><pubDate>Fri, 20 Jun 2014 00:00:00 +0000</pubDate><guid>https://whileydave.com/2014/06/20/understanding-ghost-variables-in-software-verification/</guid><description>Verification tools often support the use of ghost variables to help in the verification process. A ghost variable is not needed for the program to execute, and will not be compiled into object code.</description></item><item><title>Loop Invariants and Do/While Statements</title><link>https://whileydave.com/2014/05/15/loop-invariants-and-do/while-statements/</link><pubDate>Thu, 15 May 2014 00:00:00 +0000</pubDate><guid>https://whileydave.com/2014/05/15/loop-invariants-and-do/while-statements/</guid><description>Recently, I encountered what I thought was a bug in the Whiley Compiler. The issue related to the current treatment of do/while loops and loop invariants. Having now spent a fair bit of time researching the issue, the answer is not so clear.</description></item><item><title>Loop invariants and Break Statements</title><link>https://whileydave.com/2014/05/02/loop-invariants-and-break-statements/</link><pubDate>Fri, 02 May 2014 00:00:00 +0000</pubDate><guid>https://whileydave.com/2014/05/02/loop-invariants-and-break-statements/</guid><description>In this article, I&amp;rsquo;ll look at some interesting issues relating to the use of break statements within loops, and how this affects the idea of a loop invariant. For some general background on writing loop invariants in Whiley, see my previous post.</description></item><item><title>Flying the CrazyFlie Quadcopter!</title><link>https://whileydave.com/2014/03/02/flying-the-crazyflie-quadcopter/</link><pubDate>Sun, 02 Mar 2014 00:00:00 +0000</pubDate><guid>https://whileydave.com/2014/03/02/flying-the-crazyflie-quadcopter/</guid><description>Last week, my CrazyFlie nano-quadcopter finally arrived and, since then, I&amp;rsquo;ve been learning how to fly! The copter is much smaller than I was expecting, and it requires you to solder a few bits together.</description></item><item><title>More Tracked Arduino Fun!</title><link>https://whileydave.com/2014/01/31/more-tracked-arduino-fun/</link><pubDate>Fri, 31 Jan 2014 00:00:00 +0000</pubDate><guid>https://whileydave.com/2014/01/31/more-tracked-arduino-fun/</guid><description>Recently, I&amp;rsquo;ve been upgrading my tracked arduino robot with a few more sensors. Check out the video:
The robot has two medium range IR sensors (front and back), as well as a downward facing short-range IR sensor.</description></item><item><title>Thoughts on Parsing Whiley (and Indentation Syntax)</title><link>https://whileydave.com/2014/01/23/thoughts-on-parsing-whiley-and-indentation-syntax/</link><pubDate>Thu, 23 Jan 2014 00:00:00 +0000</pubDate><guid>https://whileydave.com/2014/01/23/thoughts-on-parsing-whiley-and-indentation-syntax/</guid><description>Recently, I have been reworking the Whiley compiler&amp;rsquo;s parser to make it more robust. Doing this has opened up some interesting issues, which I thought were worth discussing. Whiley uses indentation syntax without explicit end-of-statement terminators (e.</description></item><item><title>Thoughts on Writing Loop Invariants</title><link>https://whileydave.com/2013/11/19/thoughts-on-writing-loop-invariants/</link><pubDate>Tue, 19 Nov 2013 00:00:00 +0000</pubDate><guid>https://whileydave.com/2013/11/19/thoughts-on-writing-loop-invariants/</guid><description>As the Whiley system is taking better shape every day, I&amp;rsquo;m starting to play around more and discover things. In particular, there are some surprising issues surrounding while loops and their loop invariants.</description></item><item><title>The Dafny Tutorial at SPLASH'13</title><link>https://whileydave.com/2013/11/01/the-dafny-tutorial-at-splash13/</link><pubDate>Fri, 01 Nov 2013 00:00:00 +0000</pubDate><guid>https://whileydave.com/2013/11/01/the-dafny-tutorial-at-splash13/</guid><description>Today I was attending the Dafny tutorial given by Rustan Leino at SPLASH'13. I have to say that this was the highlight of the conference for me. In case you haven&amp;rsquo;t come across it before, Dafny is a programming language designed for software verification.</description></item><item><title>Understanding why Union Types are useful</title><link>https://whileydave.com/2013/07/31/understanding-why-union-types-are-useful/</link><pubDate>Wed, 31 Jul 2013 00:00:00 +0000</pubDate><guid>https://whileydave.com/2013/07/31/understanding-why-union-types-are-useful/</guid><description>The Whiley programming language uses union types as a way of combining types together. Here&amp;rsquo;s a simple example to illustrate:
function indexOf(string str, char c) =&amp;gt; null|int: for i in 0.</description></item><item><title>The Architecture of Verification in Whiley</title><link>https://whileydave.com/2013/06/26/the-architecture-of-verification-in-whiley/</link><pubDate>Wed, 26 Jun 2013 00:00:00 +0000</pubDate><guid>https://whileydave.com/2013/06/26/the-architecture-of-verification-in-whiley/</guid><description>As the Whiley compiler continues to evolve, certain aspects of its architecture are really starting to mature. One of the more recent pieces to take shape is the verification pipeline. This is the process by which a Whiley file is converted into a series of verification conditions, which are then checked by the automated theorem prover.</description></item><item><title>Whiley at the Melbourne Java User Group</title><link>https://whileydave.com/2013/06/19/whiley-at-the-melbourne-java-user-group/</link><pubDate>Wed, 19 Jun 2013 00:00:00 +0000</pubDate><guid>https://whileydave.com/2013/06/19/whiley-at-the-melbourne-java-user-group/</guid><description>A few weeks ago, I was in Melbourne attending the Australasian Software Engineering Conference and, whilst I was there, I gave a talk on Whiley at the Melbourne Java Users Group.</description></item><item><title>Input / Output and the Object-Oriented Paradigm</title><link>https://whileydave.com/2013/05/16/input-/-output-and-the-object-oriented-paradigm/</link><pubDate>Thu, 16 May 2013 00:00:00 +0000</pubDate><guid>https://whileydave.com/2013/05/16/input-/-output-and-the-object-oriented-paradigm/</guid><description>Today, more then ever before, I/O dominates what software is about. Of course, it&amp;rsquo;s always been important but, with increasing bandwidths, I/O seems to be what most programs now spend most of their time doing.</description></item><item><title>Iso-Recursive versus Equi-Recursive Types</title><link>https://whileydave.com/2013/04/21/iso-recursive-versus-equi-recursive-types/</link><pubDate>Sun, 21 Apr 2013 00:00:00 +0000</pubDate><guid>https://whileydave.com/2013/04/21/iso-recursive-versus-equi-recursive-types/</guid><description>An important component of the Whiley language is the use of recursive data types. Whilst these are similar to the algebraic data types found in languages like Haskell, they are also more powerful since Whiley employs a structural type system.</description></item><item><title>Compile-Time Verification and I/O</title><link>https://whileydave.com/2013/04/09/compile-time-verification-and-i/o/</link><pubDate>Tue, 09 Apr 2013 00:00:00 +0000</pubDate><guid>https://whileydave.com/2013/04/09/compile-time-verification-and-i/o/</guid><description>A surprisingly common question people ask me when I talk about compile-time checking of pre-/post-conditions and invariants is: how do you deal with I/O?
To understand what the difficulty is, let&amp;rsquo;s consider a simple example in Whiley:</description></item><item><title>Understanding Loop Invariants in Whiley</title><link>https://whileydave.com/2013/01/29/understanding-loop-invariants-in-whiley/</link><pubDate>Tue, 29 Jan 2013 00:00:00 +0000</pubDate><guid>https://whileydave.com/2013/01/29/understanding-loop-invariants-in-whiley/</guid><description>In this article, I&amp;rsquo;ll look at a common problem one encounters when verifying programs: namely, writing loop invariants. In short, a loop invariant is a property of the loop which:</description></item><item><title>Whiley Puzzler</title><link>https://whileydave.com/2013/01/14/whiley-puzzler/</link><pubDate>Mon, 14 Jan 2013 00:00:00 +0000</pubDate><guid>https://whileydave.com/2013/01/14/whiley-puzzler/</guid><description>I was having an interesting discussion with a colleague today about various aspects of Whiley, and we came up with an interesting bit of example code which is something of a puzzler.</description></item><item><title>Whiley Features in the Dominion Post!</title><link>https://whileydave.com/2013/01/10/whiley-features-in-the-dominion-post/</link><pubDate>Thu, 10 Jan 2013 00:00:00 +0000</pubDate><guid>https://whileydave.com/2013/01/10/whiley-features-in-the-dominion-post/</guid><description>Today&amp;rsquo;s edition of the Dominion Post (Wellington&amp;rsquo;s Local Newspaper) features a nice article on Whiley:
Obviously, I&amp;rsquo;m very excited to see Whiley being talked about in our local newspaper, and I think the article does a nice job of it.</description></item><item><title>Testing out my Papilio FPGA!</title><link>https://whileydave.com/2012/12/20/testing-out-my-papilio-fpga/</link><pubDate>Thu, 20 Dec 2012 00:00:00 +0000</pubDate><guid>https://whileydave.com/2012/12/20/testing-out-my-papilio-fpga/</guid><description>Recently, I got hold of a Papilio One (which you can think of as the Arduino of FPGAs). The Papilio board has a Xilinx Spartan 3 on board, which is plenty enough to get started learning about FPGAs.</description></item><item><title>Building an Arduino Robot (for Testing Whiley)</title><link>https://whileydave.com/2012/12/12/building-an-arduino-robot-for-testing-whiley/</link><pubDate>Wed, 12 Dec 2012 00:00:00 +0000</pubDate><guid>https://whileydave.com/2012/12/12/building-an-arduino-robot-for-testing-whiley/</guid><description>The Whiley programming language is about developing more reliable software and, of course, embedded systems is one of the biggest areas that could benefit. Obviously, then, we need an &amp;ldquo;embedded system&amp;rdquo; to test Whiley with, right?</description></item><item><title>A Source File with 72KLOC!?</title><link>https://whileydave.com/2012/12/11/a-source-file-with-72kloc/</link><pubDate>Tue, 11 Dec 2012 00:00:00 +0000</pubDate><guid>https://whileydave.com/2012/12/11/a-source-file-with-72kloc/</guid><description>Yesterday, I was looking at the stats on Ohloh for the Whiley project and noticed that my total line count for the project had increased from around 65KLOCto 143KLOC over a very short amount of time:</description></item><item><title>Generating Verification Conditions for Whiley</title><link>https://whileydave.com/2012/12/04/generating-verification-conditions-for-whiley/</link><pubDate>Tue, 04 Dec 2012 00:00:00 +0000</pubDate><guid>https://whileydave.com/2012/12/04/generating-verification-conditions-for-whiley/</guid><description>Probably the most interesting aspect of the Whiley language is that it supports compile-time verification of preconditions, postconditions and other invariants. There are two main aspects of how this works:</description></item><item><title>Comparing I/O in C with Java</title><link>https://whileydave.com/2012/11/28/comparing-i/o-in-c-with-java/</link><pubDate>Wed, 28 Nov 2012 00:00:00 +0000</pubDate><guid>https://whileydave.com/2012/11/28/comparing-i/o-in-c-with-java/</guid><description>Recently, I was having a somewhat heated discussion with a friend about the Java I/O library (specificially java.io.*). His position was that the library is unnecessarily cluttered and verbose, and that I/O in C is much simpler and more productive.</description></item><item><title>Rustan on Automatic Program Verification</title><link>https://whileydave.com/2012/11/06/rustan-on-automatic-program-verification/</link><pubDate>Tue, 06 Nov 2012 00:00:00 +0000</pubDate><guid>https://whileydave.com/2012/11/06/rustan-on-automatic-program-verification/</guid><description>Yesterday I came across an interesting talk given by Rustan Leino at the University of Edinburgh in 2011. Rustan takes an interesting look overview over the subject&amp;rsquo;s history, and then shows several tools in action (including Code Contracts and Dafny):</description></item><item><title>Formalising Flow Typing with Union, Intersection and Negation Types</title><link>https://whileydave.com/2012/10/31/formalising-flow-typing-with-union-intersection-and-negation-types/</link><pubDate>Wed, 31 Oct 2012 00:00:00 +0000</pubDate><guid>https://whileydave.com/2012/10/31/formalising-flow-typing-with-union-intersection-and-negation-types/</guid><description>The Whiley language takes an unusual approaching to static typing called flow typing. This helps to give Whiley the look-and-feel of a dynamically typed language. The key idea behind flow typing is to allow variables to have different types at different points in a program.</description></item><item><title>Profiling Field Initialisation in Java</title><link>https://whileydave.com/2012/09/30/profiling-field-initialisation-in-java/</link><pubDate>Sun, 30 Sep 2012 00:00:00 +0000</pubDate><guid>https://whileydave.com/2012/09/30/profiling-field-initialisation-in-java/</guid><description>Recently, I attended the annual Conference on Runtime Verification (RV2012) and gave a talk entitled &amp;ldquo;Profiling Field Initialisation in Java&amp;rdquo; (the paper itself is here). This is the work of my PhD student, Stephen Nelson, and he should take all the credit for the gory details.</description></item><item><title>A Misconception of Functional Programming?</title><link>https://whileydave.com/2012/09/06/a-misconception-of-functional-programming/</link><pubDate>Thu, 06 Sep 2012 00:00:00 +0000</pubDate><guid>https://whileydave.com/2012/09/06/a-misconception-of-functional-programming/</guid><description>Recently, I came across an article entitled &amp;ldquo;Useful Pure Functional Programming&amp;rdquo; which talks about the advantages of functional programming. However, something struck me about the way the author thinks about functional programming:</description></item><item><title>Autonomous Robotic Drone which Flies Indoors!?</title><link>https://whileydave.com/2012/08/15/autonomous-robotic-drone-which-flies-indoors/</link><pubDate>Wed, 15 Aug 2012 00:00:00 +0000</pubDate><guid>https://whileydave.com/2012/08/15/autonomous-robotic-drone-which-flies-indoors/</guid><description>Very recently, I came across this article from MIT News about an autonomous robotic drone developed at MIT. It&amp;rsquo;s incredibly neat stuff &amp;hellip; and I would love to get Whiley running on something like this!</description></item><item><title>Java versus C++ Performance</title><link>https://whileydave.com/2012/08/13/java-versus-c-performance/</link><pubDate>Mon, 13 Aug 2012 00:00:00 +0000</pubDate><guid>https://whileydave.com/2012/08/13/java-versus-c-performance/</guid><description>Recently, I came across an interesting discussion of C++ versus Java performance over on Stack Exchange. There was also some good discussion of the article on Reddit which included a link to an interesting article from Google.</description></item><item><title>Whiley Interview on VBC 88.3FM</title><link>https://whileydave.com/2012/07/30/whiley-interview-on-vbc-88.3fm/</link><pubDate>Mon, 30 Jul 2012 00:00:00 +0000</pubDate><guid>https://whileydave.com/2012/07/30/whiley-interview-on-vbc-88.3fm/</guid><description>Recently, I was on VBC 88.3FM (Victoria University&amp;rsquo;s Student Radio) giving a 60s &amp;ldquo;speed summary&amp;rdquo; of my research, and generally chatting about some tech stuff. The station has been interviewing a whole range of people at the university to raise awareness of what research is going on.</description></item><item><title>The Liquid Metal Project</title><link>https://whileydave.com/2012/07/04/the-liquid-metal-project/</link><pubDate>Wed, 04 Jul 2012 00:00:00 +0000</pubDate><guid>https://whileydave.com/2012/07/04/the-liquid-metal-project/</guid><description>One of the most interesting projects I came across at PLDI/ECOOP in Beijing was the Liquid Metal project being developed at IBM&amp;rsquo;s TJ Watson Research Center. From the Liquid Metal homepage:</description></item><item><title>Groovy 2.0 uses Flow Typing!</title><link>https://whileydave.com/2012/07/01/groovy-2.0-uses-flow-typing/</link><pubDate>Sun, 01 Jul 2012 00:00:00 +0000</pubDate><guid>https://whileydave.com/2012/07/01/groovy-2.0-uses-flow-typing/</guid><description>Groovy 2.0 has just been released, and it contains something rather interesting &amp;hellip; optional flow typing! For those who don&amp;rsquo;t know much about the language, Groovy is a JVM-based dynamically typed language which is similar to Java, but more compact.</description></item><item><title>Flow Typing for References in Whiley</title><link>https://whileydave.com/2012/06/11/flow-typing-for-references-in-whiley/</link><pubDate>Mon, 11 Jun 2012 00:00:00 +0000</pubDate><guid>https://whileydave.com/2012/06/11/flow-typing-for-references-in-whiley/</guid><description>The Whiley language splits into a fully functional &amp;ldquo;core&amp;rdquo; and an imperative &amp;ldquo;outer layer&amp;rdquo;. References and objects do not exist within the functional core. However, they can exist within the imperative outer layer and are necessary for supporting state and other side-effecting computation.</description></item><item><title>Exploring The Verification Corner</title><link>https://whileydave.com/2012/06/06/exploring-the-verification-corner/</link><pubDate>Wed, 06 Jun 2012 00:00:00 +0000</pubDate><guid>https://whileydave.com/2012/06/06/exploring-the-verification-corner/</guid><description>Recently, I was lucky enough to meet Rustan Leino whilst at a conference in Tallin, Estonia. The Whiley project owes a lot to Rustan, as much of his work has been the inspiration behind Whiley.</description></item><item><title>Variable Scoping for Try-Catch Blocks in Whiley</title><link>https://whileydave.com/2012/05/22/variable-scoping-for-try-catch-blocks-in-whiley/</link><pubDate>Tue, 22 May 2012 00:00:00 +0000</pubDate><guid>https://whileydave.com/2012/05/22/variable-scoping-for-try-catch-blocks-in-whiley/</guid><description>A friend of mine was talking about how variable scoping for try-catch blocks in Java really frustrated him sometimes. Specifically, the problem was related to variables declared inside try blocks not being visible in their catch handlers.</description></item><item><title>Termination of Flow Typing in Whiley</title><link>https://whileydave.com/2012/04/17/termination-of-flow-typing-in-whiley/</link><pubDate>Tue, 17 Apr 2012 00:00:00 +0000</pubDate><guid>https://whileydave.com/2012/04/17/termination-of-flow-typing-in-whiley/</guid><description>Whiley uses flow typing to give it the look-and-feel of a dynamically typed language (see this page for more on flow typing). In short, flow typing means that variables can have different types at different program points.</description></item><item><title>Are Checked Exceptions Always Caused by I/O?</title><link>https://whileydave.com/2012/04/10/are-checked-exceptions-always-caused-by-i/o/</link><pubDate>Tue, 10 Apr 2012 00:00:00 +0000</pubDate><guid>https://whileydave.com/2012/04/10/are-checked-exceptions-always-caused-by-i/o/</guid><description>Recently, I&amp;rsquo;ve had the pleasure of working with Eclipse and trying to build a plugin. On the whole, I have to confess,* I find that Eclipse is an extremely well-designed and considered piece of software*.</description></item><item><title>Test to Code Ratio</title><link>https://whileydave.com/2012/03/08/test-to-code-ratio/</link><pubDate>Thu, 08 Mar 2012 00:00:00 +0000</pubDate><guid>https://whileydave.com/2012/03/08/test-to-code-ratio/</guid><description>I&amp;rsquo;ve just been watching the following talk over on InfoQ: Software Quality &amp;mdash; You know it when you see it. Thanks to Craig over at SoftViz for pointing me to it.</description></item><item><title>Commonwealth Bank of Australia (CBA) denies problem with Leap Year?</title><link>https://whileydave.com/2012/03/05/commonwealth-bank-of-australia-cba-denies-problem-with-leap-year/</link><pubDate>Mon, 05 Mar 2012 00:00:00 +0000</pubDate><guid>https://whileydave.com/2012/03/05/commonwealth-bank-of-australia-cba-denies-problem-with-leap-year/</guid><description>It&amp;rsquo;s 8:30am on the 29th Februrary, 2012. After a large number of complaints, ATM and Eftpos services are finally restored for the Commonwealth Bank of Australia (CBA). See this, this and this for more details.</description></item><item><title>Jobs versus Allen</title><link>https://whileydave.com/2012/03/05/jobs-versus-allen/</link><pubDate>Mon, 05 Mar 2012 00:00:00 +0000</pubDate><guid>https://whileydave.com/2012/03/05/jobs-versus-allen/</guid><description>I&amp;rsquo;ve recently finished Paul Allen&amp;rsquo;s excellent memoir entitled &amp;ldquo;Idea Man&amp;rdquo; and the recent biography of Steve Jobs by Walter Isaacson. Obviously, I didn&amp;rsquo;t read them at the same time &amp;hellip; but one after there other!</description></item><item><title>Type Aliasing in Java?</title><link>https://whileydave.com/2012/03/02/type-aliasing-in-java/</link><pubDate>Fri, 02 Mar 2012 00:00:00 +0000</pubDate><guid>https://whileydave.com/2012/03/02/type-aliasing-in-java/</guid><description>A problem I often encounter in Java is that I want to say &amp;ldquo;these two things are the same&amp;rdquo;, but Java won&amp;rsquo;t let me. Suppose I want to maintain an int[] array which is always sorted in my program.</description></item><item><title>A Problem of Decoupling?</title><link>https://whileydave.com/2012/02/29/a-problem-of-decoupling/</link><pubDate>Wed, 29 Feb 2012 00:00:00 +0000</pubDate><guid>https://whileydave.com/2012/02/29/a-problem-of-decoupling/</guid><description>Recently, I&amp;rsquo;ve been working on improving the core framework that underpins the Whiley compiler. This provides a platform for reading/writing files of specified content in a structured fashion. Like Java, Whiley provides a hierarchical namespace in which names live and can be imported by others.</description></item><item><title>Writing a PNG Decoder in Whiley!</title><link>https://whileydave.com/2012/02/18/writing-a-png-decoder-in-whiley/</link><pubDate>Sat, 18 Feb 2012 00:00:00 +0000</pubDate><guid>https://whileydave.com/2012/02/18/writing-a-png-decoder-in-whiley/</guid><description>Over the last few days, I have been writing GIF and PNG decoders in Whiley. These form part of an image manipulation benchmark which I&amp;rsquo;m planning to use for experimenting with the compiler.</description></item><item><title>Connecting the Dots on the Future of Programming Languages</title><link>https://whileydave.com/2012/01/18/connecting-the-dots-on-the-future-of-programming-languages/</link><pubDate>Wed, 18 Jan 2012 00:00:00 +0000</pubDate><guid>https://whileydave.com/2012/01/18/connecting-the-dots-on-the-future-of-programming-languages/</guid><description>Yesterday, I serendipitously came across two things which got me thinking about the future of programming languages:
The first was an excellent article entitled &amp;ldquo;Welcome to the Hardware Jungle&amp;rdquo; by Herb Sutter.</description></item><item><title>Three Rules for Programming Language Syntax?</title><link>https://whileydave.com/2012/01/11/three-rules-for-programming-language-syntax/</link><pubDate>Wed, 11 Jan 2012 00:00:00 +0000</pubDate><guid>https://whileydave.com/2012/01/11/three-rules-for-programming-language-syntax/</guid><description>I&amp;rsquo;m always pondering the question: what makes good programming language syntax? One thing occuring to me is that many languages often ignore the HCI aspect. For me, it&amp;rsquo;s a given that the purpose of a programming language is to simplify the programmer&amp;rsquo;s life, not the other way around.</description></item><item><title>Merchants of Doubt</title><link>https://whileydave.com/2011/12/27/merchants-of-doubt/</link><pubDate>Tue, 27 Dec 2011 00:00:00 +0000</pubDate><guid>https://whileydave.com/2011/12/27/merchants-of-doubt/</guid><description>I&amp;rsquo;ve just finished reading this book, which I have to say was really good. The book is about how a handful of rogue scientists deliberately spread disinformation on a range of key issues, including tobacco, acid rain, the ozone hole and climate change.</description></item><item><title>Efficient Value Semantics for Whiley</title><link>https://whileydave.com/2011/12/13/efficient-value-semantics-for-whiley/</link><pubDate>Tue, 13 Dec 2011 00:00:00 +0000</pubDate><guid>https://whileydave.com/2011/12/13/efficient-value-semantics-for-whiley/</guid><description>The latest release of the Whiley compiler (v0.3.12) includes an optimisation for passing compound structures (e.g. lists, sets and records) by value. This is really important because all compound structures in Whiley have value semantics, meaning they are always passed by value.</description></item><item><title>Final should be Default for Classes in Java</title><link>https://whileydave.com/2011/12/06/final-should-be-default-for-classes-in-java/</link><pubDate>Tue, 06 Dec 2011 00:00:00 +0000</pubDate><guid>https://whileydave.com/2011/12/06/final-should-be-default-for-classes-in-java/</guid><description>We were having an interesting discussion the other day, and the issue of final classes came up. For some reason, it suddenly occurred to me that all classes should be final by default.</description></item><item><title>Fall-Through by Default for Switch Statements?</title><link>https://whileydave.com/2011/10/26/fall-through-by-default-for-switch-statements/</link><pubDate>Wed, 26 Oct 2011 00:00:00 +0000</pubDate><guid>https://whileydave.com/2011/10/26/fall-through-by-default-for-switch-statements/</guid><description>The switch statement has a long history, and most languages support it or something similar. In my experience, I found it to be very useful &amp;mdash; both for conciseness, and also improving performance.</description></item><item><title>What Kind of Revert are You?</title><link>https://whileydave.com/2011/10/19/what-kind-of-revert-are-you/</link><pubDate>Wed, 19 Oct 2011 00:00:00 +0000</pubDate><guid>https://whileydave.com/2011/10/19/what-kind-of-revert-are-you/</guid><description>Reverting is tough. There&amp;rsquo;s no doubt about it! I don&amp;rsquo;t mean tough as in technically challenging &amp;mdash; no, version control systems make this easy! I mean tough as in mentally challenging.</description></item><item><title>Namespaces in Whiley</title><link>https://whileydave.com/2011/09/03/namespaces-in-whiley/</link><pubDate>Sat, 03 Sep 2011 00:00:00 +0000</pubDate><guid>https://whileydave.com/2011/09/03/namespaces-in-whiley/</guid><description>With the upcoming v0.3.10 release of Whiley, the way import statements are interpreted has changed in a fairly significant manner. The primary purpose of this is to give better support for namespaces.</description></item><item><title>Simplification vs Minimisation of Types in Whiley</title><link>https://whileydave.com/2011/08/30/simplification-vs-minimisation-of-types-in-whiley/</link><pubDate>Tue, 30 Aug 2011 00:00:00 +0000</pubDate><guid>https://whileydave.com/2011/08/30/simplification-vs-minimisation-of-types-in-whiley/</guid><description>Recently, I&amp;rsquo;ve been trying to harden up the implementation of Whiley&amp;rsquo;s type system. The reason for this is fairly straightforward: bugs in the code often prevent me from compiling correct programs!</description></item><item><title>A Subtyping Gotcha</title><link>https://whileydave.com/2011/08/29/a-subtyping-gotcha/</link><pubDate>Mon, 29 Aug 2011 00:00:00 +0000</pubDate><guid>https://whileydave.com/2011/08/29/a-subtyping-gotcha/</guid><description>An interesting issue with the following piece of code has recently come to my attention:
define Queue as process { [int] items } int Queue::get(): item = this.items[0] this.items = this.</description></item><item><title>Parallel Sum in Whiley</title><link>https://whileydave.com/2011/08/03/parallel-sum-in-whiley/</link><pubDate>Wed, 03 Aug 2011 00:00:00 +0000</pubDate><guid>https://whileydave.com/2011/08/03/parallel-sum-in-whiley/</guid><description>Recently, I&amp;rsquo;ve been working on a variety of sequential and concurrent micro benchmarks for testing Whiley&amp;rsquo;s performance. An interesting and relatively simple example, is the parallel sum. The idea is to sum a large list of integers whilst performing as much work as possible in parallel.</description></item><item><title>A Semantic Interpretation of Types in Whiley</title><link>https://whileydave.com/2011/07/29/a-semantic-interpretation-of-types-in-whiley/</link><pubDate>Fri, 29 Jul 2011 00:00:00 +0000</pubDate><guid>https://whileydave.com/2011/07/29/a-semantic-interpretation-of-types-in-whiley/</guid><description>An interesting and intuitive way of thinking about a type system is using a semantic interpretation. Typically, a set-theoretic model is used where a type T is a subtype of S iff every element in the set described by T is in the set described by S.</description></item><item><title>Implicit Coercions in Whiley</title><link>https://whileydave.com/2011/07/21/implicit-coercions-in-whiley/</link><pubDate>Thu, 21 Jul 2011 00:00:00 +0000</pubDate><guid>https://whileydave.com/2011/07/21/implicit-coercions-in-whiley/</guid><description>The issue of implicit coercions in Whiley is proving to be a particularly thorny issue. The following motivates why (I think) coercions make sense:
real f(int x, real y): return x + y real g(int x, int y): return f(x,y) I believe the above should compile without error.</description></item><item><title>Compile-time Verification, It's Not Just for Type Safety Any More</title><link>https://whileydave.com/2011/07/12/compile-time-verification-its-not-just-for-type-safety-any-more/</link><pubDate>Tue, 12 Jul 2011 00:00:00 +0000</pubDate><guid>https://whileydave.com/2011/07/12/compile-time-verification-its-not-just-for-type-safety-any-more/</guid><description>I just came across an interesting presentation over at InfoQ called &amp;ldquo;Compile-time Verification, It&amp;rsquo;s Not Just for Type Safety Any More&amp;rdquo;:
The talk is by Greg Young and focuses on .</description></item><item><title>Regular Tree Automata</title><link>https://whileydave.com/2011/07/06/regular-tree-automata/</link><pubDate>Wed, 06 Jul 2011 00:00:00 +0000</pubDate><guid>https://whileydave.com/2011/07/06/regular-tree-automata/</guid><description>In my quest to understand the theory of recursive types in more detail, the notion of regular tree languages and Tree Automata has cropped up. These have been used, amongst other things, for describing XML schemas.</description></item><item><title>Bits, Bytes and More Ambiguous Syntax</title><link>https://whileydave.com/2011/07/04/bits-bytes-and-more-ambiguous-syntax/</link><pubDate>Mon, 04 Jul 2011 00:00:00 +0000</pubDate><guid>https://whileydave.com/2011/07/04/bits-bytes-and-more-ambiguous-syntax/</guid><description>Recently, I added a first-class byte type to Whiley. Unlike Java, this is not interpreted as some kind of signed or unsigned int. That&amp;rsquo;s because I find that very confusing since a byte is really just a sequence of bits without any interpretation.</description></item><item><title>Disambiguating Ambiguous Syntax?</title><link>https://whileydave.com/2011/06/28/disambiguating-ambiguous-syntax/</link><pubDate>Tue, 28 Jun 2011 00:00:00 +0000</pubDate><guid>https://whileydave.com/2011/06/28/disambiguating-ambiguous-syntax/</guid><description>When designing a programming language, being on the lookout for ambiguous syntax is important. You don&amp;rsquo;t want to realise down the track that your syntax is ambiguous in some subtle way.</description></item><item><title>On the Duality of Types: the Ideals versus the Reals</title><link>https://whileydave.com/2011/06/20/on-the-duality-of-types-the-ideals-versus-the-reals/</link><pubDate>Mon, 20 Jun 2011 00:00:00 +0000</pubDate><guid>https://whileydave.com/2011/06/20/on-the-duality-of-types-the-ideals-versus-the-reals/</guid><description>I&amp;rsquo;ve been working hard over the last few weeks on the next release of Whiley, which should be out soon. However, I&amp;rsquo;ve got myself into a little bit of a pickle over the type system (again).</description></item><item><title>Design by Contract is Most Requested Feature?</title><link>https://whileydave.com/2011/06/17/design-by-contract-is-most-requested-feature/</link><pubDate>Fri, 17 Jun 2011 00:00:00 +0000</pubDate><guid>https://whileydave.com/2011/06/17/design-by-contract-is-most-requested-feature/</guid><description>Thanks to Alex Potanin for pointing this out to me &amp;hellip; it seems that Design by Contract is the most requested enhancement to the Java language. You can find the list of the top 25 RFEs here.</description></item><item><title>Language Complexity?</title><link>https://whileydave.com/2011/06/13/language-complexity/</link><pubDate>Mon, 13 Jun 2011 00:00:00 +0000</pubDate><guid>https://whileydave.com/2011/06/13/language-complexity/</guid><description>Some languages are complex, others are simple &amp;hellip; right? C++ versus just about anything else is a good example here. But, it begs the question: what makes a language complex?</description></item><item><title>What a Racket!</title><link>https://whileydave.com/2011/06/03/what-a-racket/</link><pubDate>Fri, 03 Jun 2011 00:00:00 +0000</pubDate><guid>https://whileydave.com/2011/06/03/what-a-racket/</guid><description>The other day I was listening to this podcast over at FLOSS weekly. It was an interview was with Matthew Flatt about the Racket language (formerly PLT Scheme). The language is a Lisp dialect which was primarily designed for teaching, and subsequently used as a research platform.</description></item><item><title>JavaScript Playground</title><link>https://whileydave.com/2011/05/26/javascript-playground/</link><pubDate>Thu, 26 May 2011 00:00:00 +0000</pubDate><guid>https://whileydave.com/2011/05/26/javascript-playground/</guid><description>I&amp;rsquo;ve been doing a bit of JavaScript programming recently, and I came up with the &amp;ldquo;Creature Playground&amp;rdquo; (which is primarily aimed at teaching). Here&amp;rsquo;s a little taster (click on &amp;ldquo;Create&amp;rdquo; a few times):</description></item><item><title>Actor Syntax in Whiley</title><link>https://whileydave.com/2011/05/16/actor-syntax-in-whiley/</link><pubDate>Mon, 16 May 2011 00:00:00 +0000</pubDate><guid>https://whileydave.com/2011/05/16/actor-syntax-in-whiley/</guid><description>Recently, I&amp;rsquo;ve been doing some work on the syntax for Actors in Whiley. After some deliberation, I&amp;rsquo;ve decided to go with explicit syntax for both synchronous and asynchronous message sends. This means any message can be sent either synchronously or asynchronously.</description></item><item><title>Got Any Quotes from Coders At Work?</title><link>https://whileydave.com/2011/04/25/got-any-quotes-from-coders-at-work/</link><pubDate>Mon, 25 Apr 2011 00:00:00 +0000</pubDate><guid>https://whileydave.com/2011/04/25/got-any-quotes-from-coders-at-work/</guid><description>Recently, I finished reading Coders at Work by Peter Seibel. The book consists of a series of interviews with the following (impressive) list of programmers and computer scientists: Jamie Zawinski, Brad Fitzpatrick, Douglas Crockford, Brendan Eich, Josh Bloch, Joe Armstrong, Simon Peyton-Jones, Peter Norvig, Guy Steele, Dan Ingalls, Peter Deutsch, Ken Thompson, Fran Allen, Bernie Cosell and Don Knuth.</description></item><item><title>One Thing I Really Hate About the JVM</title><link>https://whileydave.com/2011/04/15/one-thing-i-really-hate-about-the-jvm/</link><pubDate>Fri, 15 Apr 2011 00:00:00 +0000</pubDate><guid>https://whileydave.com/2011/04/15/one-thing-i-really-hate-about-the-jvm/</guid><description>Whilst I think the Java Virtual Machine is generally speaking a fantastic piece of kit, there is one thing that I really hate about it: I can&amp;rsquo;t stop threads!!!
Sure, there&amp;rsquo;s a method called Thread.</description></item><item><title>Actors on the JVM</title><link>https://whileydave.com/2011/03/22/actors-on-the-jvm/</link><pubDate>Tue, 22 Mar 2011 00:00:00 +0000</pubDate><guid>https://whileydave.com/2011/03/22/actors-on-the-jvm/</guid><description>The Actor Model is an interesting alternative to the standard threading model used in languages like Java. Its been around for a while, but Erlang has recently brought it into the mainstream.</description></item><item><title>Implementing Structural Types</title><link>https://whileydave.com/2011/03/07/implementing-structural-types/</link><pubDate>Mon, 07 Mar 2011 00:00:00 +0000</pubDate><guid>https://whileydave.com/2011/03/07/implementing-structural-types/</guid><description>Introduction Over the last few months, I&amp;rsquo;ve been working on the type system underpinning Whiley. A key feature is the use of structural typing, rather than nominal typing, and I&amp;rsquo;ve blogged about this quite a bit already (see [1][2][3][4]).</description></item><item><title>Freakonomics</title><link>https://whileydave.com/2011/02/23/freakonomics/</link><pubDate>Wed, 23 Feb 2011 00:00:00 +0000</pubDate><guid>https://whileydave.com/2011/02/23/freakonomics/</guid><description>Recently, I finished reading Freakonomics, by Steven Levitt and Stephen Dubner. and I have to say that I really liked it!!
The book is focuses on the study of everyday aspects of life using the tools of economics and statistics.</description></item><item><title>Minimising Recursive Data Types</title><link>https://whileydave.com/2011/02/16/minimising-recursive-data-types/</link><pubDate>Wed, 16 Feb 2011 00:00:00 +0000</pubDate><guid>https://whileydave.com/2011/02/16/minimising-recursive-data-types/</guid><description>Following on from my previous post about structural subtyping with recursive types, a related problem is that of minimising recursive types. Consider this (somewhat artificial) example:
define InnerList as null | { int data, OuterList next } define OuterList as null | { int data, InnerList next } int sum(OuterList list): if list ~= null: return 0 else: return 1 + sum(list.</description></item><item><title>A Problem with Structural Subtyping and Recusive Types</title><link>https://whileydave.com/2011/02/15/a-problem-with-structural-subtyping-and-recusive-types/</link><pubDate>Tue, 15 Feb 2011 00:00:00 +0000</pubDate><guid>https://whileydave.com/2011/02/15/a-problem-with-structural-subtyping-and-recusive-types/</guid><description>One problem causing me a headache is how to implement structural subtyping for recursive types (which I first blogged about here). The following example illustrates the basic idea:
define Link as { int data, LinkedList next } define LinkedList as null | Link LinkedList f(Link list): return list This is a fairly straightforward definition of a linked list, along with a dumb function f() that just returns its parameter.</description></item><item><title>What Motivates Us?</title><link>https://whileydave.com/2011/02/07/what-motivates-us/</link><pubDate>Mon, 07 Feb 2011 00:00:00 +0000</pubDate><guid>https://whileydave.com/2011/02/07/what-motivates-us/</guid><description>Here&amp;rsquo;s an interesting video that I just came across (adapted from Dan Pink&amp;rsquo;s talk at the RSA, which is currently doing the rounds:
The video is about what motivates people to do things and, in particular, whether or not giving people more money means they do a better job.</description></item><item><title>The Case Against Structural Subtyping ... ?</title><link>https://whileydave.com/2011/01/26/the-case-against-structural-subtyping-.../</link><pubDate>Wed, 26 Jan 2011 00:00:00 +0000</pubDate><guid>https://whileydave.com/2011/01/26/the-case-against-structural-subtyping-.../</guid><description>My previous post on structural subtyping generated quite a few comments over on reddit. There were a lot of mixed opinions as to the pros and cons of having a structural type system instead of a nominal type system.</description></item><item><title>One Approach to Efficient Structural Subtyping</title><link>https://whileydave.com/2011/01/14/one-approach-to-efficient-structural-subtyping/</link><pubDate>Fri, 14 Jan 2011 00:00:00 +0000</pubDate><guid>https://whileydave.com/2011/01/14/one-approach-to-efficient-structural-subtyping/</guid><description>An interesting challenge with structural subtyping is that of efficient implementation. In particular, without care, it may be impossible to determine a static offset for each field in a structure at runtime, meaning every field access will require a dictionary lookup.</description></item><item><title>Modular Purity Analysis for Java</title><link>https://whileydave.com/2010/12/14/modular-purity-analysis-for-java/</link><pubDate>Tue, 14 Dec 2010 00:00:00 +0000</pubDate><guid>https://whileydave.com/2010/12/14/modular-purity-analysis-for-java/</guid><description>Well, after an agonizing wait I finally heard the news that my paper on purity analysis was accepted to the Conference on Compiler Construction, 2011. Obviously, I&amp;rsquo;m stoked! The paper is:</description></item><item><title>Why not use Structural Subtyping?</title><link>https://whileydave.com/2010/12/13/why-not-use-structural-subtyping/</link><pubDate>Mon, 13 Dec 2010 00:00:00 +0000</pubDate><guid>https://whileydave.com/2010/12/13/why-not-use-structural-subtyping/</guid><description>Modern programming languages generally use what is known as a Nominal type system. This means types are associated with explicit names and subtyping relationships are explicit in the code (e.g. via extends or implements).</description></item><item><title>The Future of Programming Languages</title><link>https://whileydave.com/2010/12/06/the-future-of-programming-languages/</link><pubDate>Mon, 06 Dec 2010 00:00:00 +0000</pubDate><guid>https://whileydave.com/2010/12/06/the-future-of-programming-languages/</guid><description>There&amp;rsquo;s an interesting panel discussion from the StrangeLoop2010 conference over on InfoQ:
http://www.infoq.com/presentations/Future-of-Programming-Languages
There panel covers quite a range of different topics, but there was one in particular that caught my eye:</description></item><item><title>Where Good Ideas Come From</title><link>https://whileydave.com/2010/11/30/where-good-ideas-come-from/</link><pubDate>Tue, 30 Nov 2010 00:00:00 +0000</pubDate><guid>https://whileydave.com/2010/11/30/where-good-ideas-come-from/</guid><description>I recently finished reading Steven Johnson&amp;rsquo;s &amp;ldquo;Where Good Ideas Come From&amp;rdquo;. This is a rather interesting book which takes a walk through history looking at how good ideas come to be.</description></item><item><title>A Problem on Typing vs Verification</title><link>https://whileydave.com/2010/11/14/a-problem-on-typing-vs-verification/</link><pubDate>Sun, 14 Nov 2010 00:00:00 +0000</pubDate><guid>https://whileydave.com/2010/11/14/a-problem-on-typing-vs-verification/</guid><description>Whiley uses a flow-sensitive type system, and a verification engine to enable Extended static checking. My desire in designing these two subsystems is to keep them completely isolated. In particular, such that we can always compile and run a Whiley program with verification turned off.</description></item><item><title>More on Flow-Sensitive Typing</title><link>https://whileydave.com/2010/11/09/more-on-flow-sensitive-typing/</link><pubDate>Tue, 09 Nov 2010 00:00:00 +0000</pubDate><guid>https://whileydave.com/2010/11/09/more-on-flow-sensitive-typing/</guid><description>The idea behind flow-sensitive typing in Whiley is to give a statically typed language the look-and-feel of a dynamically typed language (as much as possible). The following illustrates:
int average([int] items): v = 0 for i in items: v = v + items[i] return v / |items| Here, we see that there are only two type declarations: one for the parameter, and one for the return.</description></item><item><title>The Design of Design</title><link>https://whileydave.com/2010/10/28/the-design-of-design/</link><pubDate>Thu, 28 Oct 2010 00:00:00 +0000</pubDate><guid>https://whileydave.com/2010/10/28/the-design-of-design/</guid><description>I just finished up reading &amp;ldquo;The Design of Design&amp;rdquo; by Fred Brookes JR (author of the Mythical Man Month). This book is a reflection on the design process itself and, in particular, what good designers are made of.</description></item><item><title>Implementing Actors on the JVM</title><link>https://whileydave.com/2010/10/25/implementing-actors-on-the-jvm/</link><pubDate>Mon, 25 Oct 2010 00:00:00 +0000</pubDate><guid>https://whileydave.com/2010/10/25/implementing-actors-on-the-jvm/</guid><description>Whiley adopts the Actor model of concurrency, instead of the traditional multi-threading approach used in e.g. Java. The actor model is simple and easy to use, and is less likely to result in complex race conditions or deadlocks.</description></item><item><title>Indentation Syntax in Whiley</title><link>https://whileydave.com/2010/10/18/indentation-syntax-in-whiley/</link><pubDate>Mon, 18 Oct 2010 00:00:00 +0000</pubDate><guid>https://whileydave.com/2010/10/18/indentation-syntax-in-whiley/</guid><description>Like Python, Whiley uses indentation syntax instead of curly braces for delimiting blocks. When I started using indentation syntax with Python, I was pretty skeptical, but it grew on me fast and now I really like it.</description></item><item><title>Function Pointer Syntax for Whiley</title><link>https://whileydave.com/2010/10/11/function-pointer-syntax-for-whiley/</link><pubDate>Mon, 11 Oct 2010 00:00:00 +0000</pubDate><guid>https://whileydave.com/2010/10/11/function-pointer-syntax-for-whiley/</guid><description>One of the next big issues needing to be addressed is the syntax for function and method pointers. The syntax I&amp;rsquo;m thinking of is close to that used in C and C++ (see e.</description></item><item><title>Field Resolution in Whiley</title><link>https://whileydave.com/2010/10/05/field-resolution-in-whiley/</link><pubDate>Tue, 05 Oct 2010 00:00:00 +0000</pubDate><guid>https://whileydave.com/2010/10/05/field-resolution-in-whiley/</guid><description>An interesting issue has arisen as a result of my recent decision to move away from a declared-type model. The issue is essentially about scope resolution of fields and local variables.</description></item><item><title>Better Namespaces</title><link>https://whileydave.com/2010/10/04/better-namespaces/</link><pubDate>Mon, 04 Oct 2010 00:00:00 +0000</pubDate><guid>https://whileydave.com/2010/10/04/better-namespaces/</guid><description>An interesting problem I&amp;rsquo;ve encountered many times in Java is that of conflicting names. For example, suppose I have the following code:
import wyil.lang.*; import wyil.lang.Type.*; ... public static Type T_Bool = new Type.</description></item><item><title>Thoughts on Loop Invariants</title><link>https://whileydave.com/2010/09/30/thoughts-on-loop-invariants/</link><pubDate>Thu, 30 Sep 2010 00:00:00 +0000</pubDate><guid>https://whileydave.com/2010/09/30/thoughts-on-loop-invariants/</guid><description>With the recent addition of for and while loops to Whiley, I&amp;rsquo;ve been able to fiddle around with loop invariants and already I noticed a few things. Consider this little program:</description></item><item><title>On Flow-Sensitive Types in Whiley</title><link>https://whileydave.com/2010/09/22/on-flow-sensitive-types-in-whiley/</link><pubDate>Wed, 22 Sep 2010 00:00:00 +0000</pubDate><guid>https://whileydave.com/2010/09/22/on-flow-sensitive-types-in-whiley/</guid><description>In the ensuing months since the previous release of Whiley, I have been working away on a major rewrite of the compiler. This is now almost ready, at last! One of the &amp;ldquo;executive decisions&amp;rdquo; I made recently, was to move away from a declared variable model to a completely flow-sensitive typing model.</description></item><item><title>Java Pathfinder</title><link>https://whileydave.com/2010/09/20/java-pathfinder/</link><pubDate>Mon, 20 Sep 2010 00:00:00 +0000</pubDate><guid>https://whileydave.com/2010/09/20/java-pathfinder/</guid><description>Recently, Simon Doherty gave a short talk on using Java Pathfinder to find bugs in Java programs. Java Pathfinder is a model checker for Java code, particularly suited to reasoning about multi-threaded code and finding concurrency bugs.</description></item><item><title>Normalising Recursive Data Types</title><link>https://whileydave.com/2010/09/19/normalising-recursive-data-types/</link><pubDate>Sun, 19 Sep 2010 00:00:00 +0000</pubDate><guid>https://whileydave.com/2010/09/19/normalising-recursive-data-types/</guid><description>Recently, I came across an interesting problem with the type system I&amp;rsquo;m using in Whiley. Specifically, the problem relates to recursive types which are equivalent but not identical. Consider, for example, the following Whiley code:</description></item><item><title>James Bach on Software Testing</title><link>https://whileydave.com/2010/09/08/james-bach-on-software-testing/</link><pubDate>Wed, 08 Sep 2010 00:00:00 +0000</pubDate><guid>https://whileydave.com/2010/09/08/james-bach-on-software-testing/</guid><description>I&amp;rsquo;ve just been watching this YouTube presentation by James Bach:
James has a very tongue-in-cheek style, which I rather like, and he&amp;rsquo;s obviously not a great fan of the academic establishment:</description></item><item><title>Beautiful Code ... ?</title><link>https://whileydave.com/2010/08/19/beautiful-code-.../</link><pubDate>Thu, 19 Aug 2010 00:00:00 +0000</pubDate><guid>https://whileydave.com/2010/08/19/beautiful-code-.../</guid><description>Recently, I&amp;rsquo;ve been reading &amp;ldquo;Beautiful Code&amp;rdquo; (edited by Andy Oram &amp;amp; Greg Wilson). This is a collection of short papers by academics and professional software developers which explores the idea of beauty in software.</description></item><item><title>The X10 Programming Language</title><link>https://whileydave.com/2010/08/05/the-x10-programming-language/</link><pubDate>Thu, 05 Aug 2010 00:00:00 +0000</pubDate><guid>https://whileydave.com/2010/08/05/the-x10-programming-language/</guid><description>X10 is an interesting and relatively new language from IBM being developed as part of DARPA&amp;rsquo;s High Productivity Computing Systems program. X10 is designed for high-performance parallel programming using a partitioned global address space model.</description></item><item><title>Infamous Software Failures in New Zealand</title><link>https://whileydave.com/2010/08/02/infamous-software-failures-in-new-zealand/</link><pubDate>Mon, 02 Aug 2010 00:00:00 +0000</pubDate><guid>https://whileydave.com/2010/08/02/infamous-software-failures-in-new-zealand/</guid><description>I&amp;rsquo;ve been writing a grant application recently, and wanted to list some example software failures that occurred in New Zealand. Here&amp;rsquo;s what I found:
In 2012, the role out of the new Novopay system for handling the teachers salary payrole caused numerous and ongoing problems.</description></item><item><title>Thinking about Recursive Constrained Types in Whiley</title><link>https://whileydave.com/2010/07/25/thinking-about-recursive-constrained-types-in-whiley/</link><pubDate>Sun, 25 Jul 2010 00:00:00 +0000</pubDate><guid>https://whileydave.com/2010/07/25/thinking-about-recursive-constrained-types-in-whiley/</guid><description>Whiley supports so-called Algebraic Data Types for constructing tree-like data structures. For example, an expression tree might be defined like so:
define ADD as 1 define SUB as 2 define MUL as 3 define DIV as 4 define binop as {ADD,SUB,MUL,DIV} define expr as int | (binop op, expr lhs, expr rhs) Using this definition for expr, we can create a variety of trees representing compound arithmetic expressions.</description></item><item><title>Thinking about Pre- and Post-Conditions in Whiley</title><link>https://whileydave.com/2010/07/23/thinking-about-pre-and-post-conditions-in-whiley/</link><pubDate>Fri, 23 Jul 2010 00:00:00 +0000</pubDate><guid>https://whileydave.com/2010/07/23/thinking-about-pre-and-post-conditions-in-whiley/</guid><description>The notion of pre- and post-conditions is well understood in the context of software verification. However, Whiley deviates from the norm by combining them into a single condition. The following illustrates a simple Whiley function:</description></item><item><title>Language Designers ... who wait?</title><link>https://whileydave.com/2010/07/22/language-designers-...-who-wait/</link><pubDate>Thu, 22 Jul 2010 00:00:00 +0000</pubDate><guid>https://whileydave.com/2010/07/22/language-designers-...-who-wait/</guid><description>Someone recently pointed me to the Rust programming language which has some very nice features, although it&amp;rsquo;s still in early stage development. In particular, the system statically prevents null pointer errors, and does not permit dangling pointers.</description></item><item><title>On Object-Oriented Programming</title><link>https://whileydave.com/2010/07/15/on-object-oriented-programming/</link><pubDate>Thu, 15 Jul 2010 00:00:00 +0000</pubDate><guid>https://whileydave.com/2010/07/15/on-object-oriented-programming/</guid><description>There&amp;rsquo;s an interesting interview with Ralph Johnson and Joe Armstrong over at QCon. They&amp;rsquo;re talking generally about whether OOP has been successful, and reflecting on the last few decades.
A few things from the interview caught my eye.</description></item><item><title>Finding Bugs in the Real World</title><link>https://whileydave.com/2010/07/08/finding-bugs-in-the-real-world/</link><pubDate>Thu, 08 Jul 2010 00:00:00 +0000</pubDate><guid>https://whileydave.com/2010/07/08/finding-bugs-in-the-real-world/</guid><description>There&amp;rsquo;s a really interesting article over on CACM about static analysis in the real world. Here&amp;rsquo;s the Link.
The article is a report from experiences gained in the commercialisation of a tool by Coverity which uses static code analysis to find bugs.</description></item><item><title>Kiwi Language Creator Acknowledged!</title><link>https://whileydave.com/2010/07/05/kiwi-language-creator-acknowledged/</link><pubDate>Mon, 05 Jul 2010 00:00:00 +0000</pubDate><guid>https://whileydave.com/2010/07/05/kiwi-language-creator-acknowledged/</guid><description>The Dom Post ran a short article over the weekend on kiwi Ross Ihaka, about the R programming language which he created along with Robert Gentleman at the University of Auckland.</description></item><item><title>Example: Sum Over a Positive List</title><link>https://whileydave.com/2010/06/30/example-sum-over-a-positive-list/</link><pubDate>Wed, 30 Jun 2010 00:00:00 +0000</pubDate><guid>https://whileydave.com/2010/06/30/example-sum-over-a-positive-list/</guid><description>So, here&amp;rsquo;s the first Whiley programming example. Obviously, it&amp;rsquo;s pretty simple as Whiley is not quite ready for big code just yet. The idea is to compute the sum of a positive list which, of course, will give you a positive number.</description></item><item><title>What is Extended Static Checking?</title><link>https://whileydave.com/2010/06/26/what-is-extended-static-checking/</link><pubDate>Sat, 26 Jun 2010 00:00:00 +0000</pubDate><guid>https://whileydave.com/2010/06/26/what-is-extended-static-checking/</guid><description>Extended Static Checking (ESC) is the main technique used in Whiley. *But, what is it? *Since there isn&amp;rsquo;t a huge amount of information available on the web, I thought some discussion about this would be useful.</description></item><item><title>Rich Hickey on Clojure (SE Radio)</title><link>https://whileydave.com/2010/06/23/rich-hickey-on-clojure-se-radio/</link><pubDate>Wed, 23 Jun 2010 00:00:00 +0000</pubDate><guid>https://whileydave.com/2010/06/23/rich-hickey-on-clojure-se-radio/</guid><description>I&amp;rsquo;ve just been listening to an interesting interview with Rich Hickery on Clojure over at SE Radio. I&amp;rsquo;m a big fan of Clojure, since it shares a lot of similar ideas with Whiley (really, it does &amp;hellip; trust me :).</description></item><item><title>The Trouble with Quantifier Instantiation in an SMT Solver? Triggers.</title><link>https://whileydave.com/2010/06/22/the-trouble-with-quantifier-instantiation-in-an-smt-solver-triggers./</link><pubDate>Tue, 22 Jun 2010 00:00:00 +0000</pubDate><guid>https://whileydave.com/2010/06/22/the-trouble-with-quantifier-instantiation-in-an-smt-solver-triggers./</guid><description>So, i&amp;rsquo;ve been recently working through the quantifier instantiation mechanism in wyone. This is a tricky, yet important topic. There&amp;rsquo;s been a lot of interesting research in this area as well (see further reading below for some examples), although I found the papers often hard work at times.</description></item><item><title>Experimental Security Analysis of a Modern Automobile</title><link>https://whileydave.com/2010/06/15/experimental-security-analysis-of-a-modern-automobile/</link><pubDate>Tue, 15 Jun 2010 00:00:00 +0000</pubDate><guid>https://whileydave.com/2010/06/15/experimental-security-analysis-of-a-modern-automobile/</guid><description>Another good paper I found recently was the following:
&amp;ldquo;Experimental Security Analysis of a Modern Automobile&amp;rdquo;, Hoscher, Czeskis, et al. In Proceedings of IEEE Symposium on Security and Privacy, 2010. [PDF]</description></item><item><title>Formal Methods: To the Moon and Back!</title><link>https://whileydave.com/2010/06/10/formal-methods-to-the-moon-and-back/</link><pubDate>Thu, 10 Jun 2010 00:00:00 +0000</pubDate><guid>https://whileydave.com/2010/06/10/formal-methods-to-the-moon-and-back/</guid><description>I recently came across a rather interesting presentation by Gerard Holzmann (author of the SPIN model checker) who&amp;rsquo;s currently working for NASA&amp;rsquo;s Jet Propulsion Lab, and previously worked at Bell Labs:</description></item><item><title>Dafny: An Automatic Program Verifier for Functional Correctness</title><link>https://whileydave.com/2010/06/07/dafny-an-automatic-program-verifier-for-functional-correctness/</link><pubDate>Mon, 07 Jun 2010 00:00:00 +0000</pubDate><guid>https://whileydave.com/2010/06/07/dafny-an-automatic-program-verifier-for-functional-correctness/</guid><description>So, last week the pl reading group chose to read this paper by Rustan Leino. Ignoring the fact that a number of people in our group are interested in this area, Rustan had recently given a presentation on Dafny here (his slides are here) and this was reason we chose this paper.</description></item></channel></rss>