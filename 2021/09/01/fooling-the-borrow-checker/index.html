<!doctype html><html lang=en><head><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta property="og:title" content="Fooling the Borrow Checker"><meta name=twitter:title content="Fooling the Borrow Checker"><meta property="og:description" content="Pondering how the Rust borrow checker decides when a borrow could still be live"><meta name=twitter:description content="Pondering how the Rust borrow checker decides when a borrow could still be live"><meta property="og:image" content="https://whileydave.com/images/2021/Fooling_Borrow_Checker_Preview.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://whileydave.com/images/2021/Fooling_Borrow_Checker_Preview.png"><meta property="og:url" content="https://whileydave.com/2021/09/01/fooling-the-borrow-checker/"><title>David J. Pearce
(Fooling the Borrow Checker)</title><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css><link rel=stylesheet href=https://whileydave.com/css/page.css><link rel=stylesheet href=https://whileydave.com/css/menu.css><link rel=stylesheet href=https://whileydave.com/css/style.css></head><body><script>"use strict";function clearMenu(){var q=window.matchMedia("(max-width: 992px)");if(q.matches){var c=document.getElementById("menu-content");var m=document.getElementById("menu");c.style.display='none';m.style.filter='';}}
function toggleMenu(){var q=window.matchMedia("(max-width: 992px)");if(q.matches){var c=document.getElementById("menu-content");var m=document.getElementById("menu");if(c.style.display==='block'){c.style.display='none';m.style.filter='';}else{c.style.display='block';m.style.filter="brightness(0.8)";}}}
function toggleList(element){element.style.display="none";var parent=element.parentNode;var items=parent.childNodes;for(var i=0;i<items.length;++i){var item=items[i];if(item.classList&&item.classList.contains("hidden")){if(item.style.display==='block'){item.style.display="none";}else{item.style.display="block";}}}}</script><header class=topbar><div class=topbar-header onclick=clearMenu()><div class=topbar-title>Dr. David J. Pearce</div><div class=topbar-subtitle></div></div><div class=topbar-social onclick=clearMenu()><a href=https://github.com/DavePearce><i class="fa fa-github" aria-hidden=true></i></a><a href=https://twitter.com/WhileyDave><i class="fa fa-twitter" aria-hidden=true></i></a><a href=https://www.youtube.com/user/redjamjar/><i class="fa fa-youtube-play" aria-hidden=true></i></a><a href=https://www.linkedin.com/in/david-pearce-8592647/><i class="fa fa-linkedin-square" aria-hidden=true></i></a></div><div class=topbar-menu><div id=menu onclick=toggleMenu()><div id=menu-icon><img src=https://whileydave.com/images/menu.png alt=Menu></div><div id=menu-content><a href=https://whileydave.com/blog/>Blog</a>
<a href=https://whileydave.com/projects/>Projects</a>
<a href=https://whileydave.com/publications/>Publications</a>
<a href=https://whileydave.com/talks/>Talks</a>
<a href=https://whileydave.com/>Home</a></div></div></div></header><div class=container onclick=clearMenu()><div class=content><h1 class=post-title>Fooling the Borrow Checker</h1><div class=post-date>Wednesday, September
1st,
2021</div><hr><p>An interesting question is how the Rust borrow checker decides when a
borrow could still be live. This illustrates a simple example:</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Rust data-lang=Rust><span style=color:#069;font-weight:700>let</span><span style=color:#bbb> </span><span style=color:#069;font-weight:700>mut</span><span style=color:#bbb> </span>x<span style=color:#bbb> </span><span style=color:#555>=</span><span style=color:#bbb> </span><span style=color:#f60>1234</span>;<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#069;font-weight:700>let</span><span style=color:#bbb> </span>z<span style=color:#bbb> </span><span style=color:#555>=</span><span style=color:#bbb> </span>f(<span style=color:#555>&amp;</span>x);<span style=color:#bbb>
</span><span style=color:#bbb></span>...<span style=color:#bbb>
</span></code></pre></div><p>The question here is whether or not the borrow <code>&x</code> is still live
after the method call. This matters as it impacts how <code>x</code> can be used
in following statements. In fact, we don&rsquo;t have enough information
above to answer this definitively. There are two cases:</p><ul><li><p><strong>(Can Return)</strong>. If <code>f()</code> could potentially return the borrow,
then Rust must assume it is live afterwards.</p></li><li><p><strong>(Cannot Return)</strong>. If <code>f()</code> cannot return the borrow, the Rust
can assume the borrow is dead and allow <code>x</code> to be mutated
again.</p></li></ul><p>Answering the question comes down to the return type of <code>f()</code>. For
example, if <code>f()</code> returns <code>i32</code> then it certainly cannot return the
borrow. On the otherhand, if <code>f()</code> has the following type then it can
return the borrow:</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Rust data-lang=Rust><span style=color:#069;font-weight:700>fn</span> <span style=color:#c0f>f</span><span style=color:#555>&lt;</span><span style=color:#309>&#39;a</span><span style=color:#555>&gt;</span>(p<span style=color:#bbb> </span>: <span style=color:#069>&amp;</span><span style=color:#309>&#39;a</span><span style=color:#bbb> </span><span style=color:#078;font-weight:700>i32</span>)<span style=color:#bbb> </span>-&gt; <span style=color:#069>&amp;</span><span style=color:#309>&#39;a</span><span style=color:#bbb> </span><span style=color:#078;font-weight:700>i32</span><span style=color:#bbb> </span>{<span style=color:#bbb> 
</span><span style=color:#bbb>   </span>...<span style=color:#bbb> 
</span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></code></pre></div><p>In this case, it <em>must</em> return the borrow as there is nothing else it
could return to satisfy the return type (well, assuming its not doing something <code>unsafe</code>).</p><h2 id=warm-up>Warm Up</h2><p>The above is pretty straightforward, but we can make it a bit more
interesting as follows:</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Rust data-lang=Rust><span style=color:#069;font-weight:700>fn</span> <span style=color:#c0f>f</span><span style=color:#555>&lt;</span><span style=color:#309>&#39;a</span><span style=color:#555>&gt;</span>(p<span style=color:#bbb> </span>: <span style=color:#069>&amp;</span><span style=color:#309>&#39;a</span><span style=color:#bbb> </span><span style=color:#078;font-weight:700>i32</span>,<span style=color:#bbb> </span>q<span style=color:#bbb> </span>: <span style=color:#069>&amp;</span><span style=color:#309>&#39;a</span><span style=color:#bbb> </span><span style=color:#078;font-weight:700>i32</span>)<span style=color:#bbb> </span>-&gt; <span style=color:#069>&amp;</span><span style=color:#309>&#39;a</span><span style=color:#bbb> </span><span style=color:#078;font-weight:700>i32</span><span style=color:#bbb> </span>{<span style=color:#bbb> </span>...<span style=color:#bbb> </span>}<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>   </span>...<span style=color:#bbb>
</span><span style=color:#bbb>   </span><span style=color:#069;font-weight:700>let</span><span style=color:#bbb> </span><span style=color:#069;font-weight:700>mut</span><span style=color:#bbb> </span>x<span style=color:#bbb> </span><span style=color:#555>=</span><span style=color:#bbb> </span><span style=color:#f60>1234</span>;<span style=color:#bbb>
</span><span style=color:#bbb>   </span><span style=color:#069;font-weight:700>let</span><span style=color:#bbb> </span><span style=color:#069;font-weight:700>mut</span><span style=color:#bbb> </span>y<span style=color:#bbb> </span><span style=color:#555>=</span><span style=color:#bbb> </span><span style=color:#f60>678</span>;<span style=color:#bbb>
</span><span style=color:#bbb>   </span><span style=color:#069;font-weight:700>let</span><span style=color:#bbb> </span>z<span style=color:#bbb> </span><span style=color:#555>=</span><span style=color:#bbb> </span>f(<span style=color:#555>&amp;</span>x,<span style=color:#555>&amp;</span>y);<span style=color:#bbb>
</span><span style=color:#bbb>   </span>...<span style=color:#bbb>
</span></code></pre></div><p>Now, there are two borrows going in and only one coming out. To be
safe, Rust must assume that either borrow could be returned. Hence,
neither <code>x</code> nor <code>y</code> can be mutated after the call (at least while <code>z</code>
is still live).</p><p>The above is interesting because Rust makes assumptions about what our
code is doing, and those assumptions might not hold true. For
example, maybe we always return <code>p</code> above but only ever read <code>q</code> (for
whatever reason). If we know this, its annoying that Rust doesn&rsquo;t.
In fact, we can resolve this using a simple pattern by rewriting <code>f</code>
as follows:</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Rust data-lang=Rust><span style=color:#069;font-weight:700>fn</span> <span style=color:#c0f>f</span><span style=color:#555>&lt;</span><span style=color:#309>&#39;a</span>,<span style=color:#309>&#39;b</span><span style=color:#555>&gt;</span>(p<span style=color:#bbb> </span>: <span style=color:#069>&amp;</span><span style=color:#309>&#39;a</span><span style=color:#bbb> </span><span style=color:#078;font-weight:700>i32</span>,<span style=color:#bbb> </span>q<span style=color:#bbb> </span>: <span style=color:#069>&amp;</span><span style=color:#309>&#39;b</span><span style=color:#bbb> </span><span style=color:#078;font-weight:700>i32</span>)<span style=color:#bbb> </span>-&gt; <span style=color:#069>&amp;</span><span style=color:#309>&#39;a</span><span style=color:#bbb> </span><span style=color:#078;font-weight:700>i32</span><span style=color:#bbb> </span>{<span style=color:#bbb> 
</span><span style=color:#bbb>   </span>p<span style=color:#bbb> 
</span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></code></pre></div><p>This might seem cumbersome, but it does the job as Rust now knows <code>q</code>
could never be returned (i.e. since there is no relationship between
the lifetimes <code>a</code> and <code>b</code>).</p><h2 id=stretching-out>Stretching Out</h2><p>In the above examples, its fairly obvious from the method signature
that it could return the borrow. We can obfuscate this a little by
trying to hide it in something else. For example:</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Rust data-lang=Rust><span style=color:#069;font-weight:700>struct</span> <span style=color:#0a8;font-weight:700>Wrap</span><span style=color:#555>&lt;</span><span style=color:#309>&#39;a</span><span style=color:#555>&gt;</span><span style=color:#bbb> </span>{<span style=color:#bbb> 
</span><span style=color:#bbb>   </span>field: <span style=color:#069>&amp;</span><span style=color:#309>&#39;a</span><span style=color:#bbb> </span><span style=color:#078;font-weight:700>i32</span><span style=color:#bbb> 
</span><span style=color:#bbb></span>}<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#069;font-weight:700>fn</span> <span style=color:#c0f>f</span><span style=color:#555>&lt;</span><span style=color:#309>&#39;a</span><span style=color:#555>&gt;</span>(p<span style=color:#bbb> </span>: <span style=color:#069>&amp;</span><span style=color:#309>&#39;a</span><span style=color:#bbb> </span><span style=color:#078;font-weight:700>i32</span>)<span style=color:#bbb> </span>-&gt; <span style=color:#0a8;font-weight:700>Wrap</span><span style=color:#555>&lt;</span><span style=color:#309>&#39;a</span><span style=color:#555>&gt;</span><span style=color:#bbb> </span>{<span style=color:#bbb> 
</span><span style=color:#bbb>   </span>...<span style=color:#bbb> 
</span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></code></pre></div><p>This is still not enough to fool the borrow checker though. The
presence of lifetime <code>a</code> in the return type is a giveaway that our
borrow could be hiding in there. The same applies for arrays, such
as:</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Rust data-lang=Rust><span style=color:#069;font-weight:700>fn</span> <span style=color:#c0f>f</span><span style=color:#555>&lt;</span><span style=color:#309>&#39;a</span><span style=color:#555>&gt;</span>(p<span style=color:#bbb> </span>: <span style=color:#069>&amp;</span><span style=color:#309>&#39;a</span><span style=color:#bbb> </span><span style=color:#078;font-weight:700>i32</span>)<span style=color:#bbb> </span>-&gt; <span style=color:#366>Box</span><span style=color:#555>&lt;</span>[Wrap<span style=color:#555>&lt;</span><span style=color:#309>&#39;a</span><span style=color:#555>&gt;</span>]<span style=color:#555>&gt;</span><span style=color:#bbb> </span>{<span style=color:#bbb> 
</span><span style=color:#bbb>   </span>...<span style=color:#bbb> 
</span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></code></pre></div><p>(<strong>NOTE:</strong> to make this compile add <code>#[derive(Copy,Clone)]</code> before
<code>struct Wrap</code>)</p><p>Again, the presence of <code>a</code> is enough to trigger the borrow checker
that our borrow might be returned. Still, in this case, we don&rsquo;t
actually <em>have</em> to return the borrow &mdash; we could just return an empty
array.</p><h2 id=the-puzzle>The Puzzle</h2><p>An interesting (though largely pointless) question arising from all
this, is the following puzzle:</p><blockquote><p><em>Can a method signature fool the borrow checker into thinking a
borrow can be returned when, in fact, it cannot?</em></p></blockquote><p>That is, where the return type is something we know could never hold
the borrow, but where Rust must still assume it could. In fact, it&rsquo;s
not so hard. But, my first attempt failed:</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Rust data-lang=Rust><span style=color:#069;font-weight:700>struct</span> <span style=color:#0a8;font-weight:700>Empty</span><span style=color:#555>&lt;</span><span style=color:#309>&#39;a</span><span style=color:#555>&gt;</span><span style=color:#bbb> </span>{<span style=color:#bbb> </span>}<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#069;font-weight:700>fn</span> <span style=color:#c0f>f</span><span style=color:#555>&lt;</span><span style=color:#309>&#39;a</span><span style=color:#555>&gt;</span>(v<span style=color:#bbb> </span>: <span style=color:#069>&amp;</span><span style=color:#309>&#39;a</span><span style=color:#bbb> </span><span style=color:#078;font-weight:700>i32</span>)<span style=color:#bbb> </span>-&gt; <span style=color:#0a8;font-weight:700>Empty</span><span style=color:#555>&lt;</span><span style=color:#309>&#39;a</span><span style=color:#555>&gt;</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>    </span>Empty{}<span style=color:#bbb>
</span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></code></pre></div><p>The intuition here is that the mere presence of lifetime <code>a</code> in the
return type triggers the borrow checker to think <code>&x</code> might be live
afterwards. However, this doesn&rsquo;t compile as Rust is not happy with
lifetimes that aren&rsquo;t used. So, we just need to use it without using
it:</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Rust data-lang=Rust><span style=color:#069;font-weight:700>struct</span> <span style=color:#0a8;font-weight:700>Empty</span><span style=color:#555>&lt;</span><span style=color:#309>&#39;a</span><span style=color:#555>&gt;</span><span style=color:#bbb> </span>{<span style=color:#bbb> 
</span><span style=color:#bbb>   </span>phantom: <span style=color:#0a8;font-weight:700>PhantomData</span><span style=color:#555>&lt;&amp;</span><span style=color:#309>&#39;a</span><span style=color:#bbb> </span><span style=color:#078;font-weight:700>i32</span><span style=color:#555>&gt;</span><span style=color:#bbb> 
</span><span style=color:#bbb></span>}<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#069;font-weight:700>fn</span> <span style=color:#c0f>f</span><span style=color:#555>&lt;</span><span style=color:#309>&#39;a</span><span style=color:#555>&gt;</span>(v<span style=color:#bbb> </span>: <span style=color:#069>&amp;</span><span style=color:#309>&#39;a</span><span style=color:#bbb> </span><span style=color:#078;font-weight:700>i32</span>)<span style=color:#bbb> </span>-&gt; <span style=color:#0a8;font-weight:700>Empty</span><span style=color:#555>&lt;</span><span style=color:#309>&#39;a</span><span style=color:#555>&gt;</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>   </span>Empty{phantom:<span style=color:#0a8;font-weight:700>PhantomData</span>}<span style=color:#bbb>
</span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></code></pre></div><p>And now Rust will always think the borrow could be live after the
call, <em>even though this is no valid implementation of <code>f()</code> where this
is true</em> (again, assuming it doesn&rsquo;t do something <code>unsafe</code>).</p><h2 id=another-puzzle>Another Puzzle</h2><p>Now, there are other ways to fool the borrow checker, but these
somehow don&rsquo;t seem as interesting to me. For example, we can exploit
knowledge of control-flow like so:</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Rust data-lang=Rust><span style=color:#069;font-weight:700>fn</span> <span style=color:#c0f>f</span>(n:<span style=color:#078;font-weight:700>i32</span>)<span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>   </span><span style=color:#069;font-weight:700>let</span><span style=color:#bbb> </span><span style=color:#069;font-weight:700>mut</span><span style=color:#bbb> </span>x<span style=color:#bbb> </span><span style=color:#555>=</span><span style=color:#bbb> </span><span style=color:#f60>123</span>;<span style=color:#bbb>
</span><span style=color:#bbb>   </span><span style=color:#069;font-weight:700>let</span><span style=color:#bbb> </span><span style=color:#069;font-weight:700>mut</span><span style=color:#bbb> </span>y<span style=color:#bbb> </span><span style=color:#555>=</span><span style=color:#bbb> </span><span style=color:#f60>234</span>;<span style=color:#bbb>
</span><span style=color:#bbb>   </span><span style=color:#069;font-weight:700>let</span><span style=color:#bbb> </span><span style=color:#069;font-weight:700>mut</span><span style=color:#bbb> </span>z<span style=color:#bbb> </span><span style=color:#555>=</span><span style=color:#bbb> </span><span style=color:#f60>456</span>;<span style=color:#bbb>
</span><span style=color:#bbb>   </span><span style=color:#069;font-weight:700>let</span><span style=color:#bbb> </span><span style=color:#069;font-weight:700>mut</span><span style=color:#bbb> </span>p<span style=color:#bbb> </span><span style=color:#555>=</span><span style=color:#bbb> </span><span style=color:#555>&amp;</span><span style=color:#069;font-weight:700>mut</span><span style=color:#bbb> </span>x;<span style=color:#bbb>
</span><span style=color:#bbb>   </span><span style=color:#09f;font-style:italic>//
</span><span style=color:#09f;font-style:italic></span><span style=color:#bbb>   </span><span style=color:#069;font-weight:700>if</span><span style=color:#bbb> </span>n<span style=color:#bbb> </span><span style=color:#555>&gt;=</span><span style=color:#bbb> </span><span style=color:#f60>0</span><span style=color:#bbb> </span>{<span style=color:#bbb> </span>p<span style=color:#bbb> </span><span style=color:#555>=</span><span style=color:#bbb> </span><span style=color:#555>&amp;</span><span style=color:#069;font-weight:700>mut</span><span style=color:#bbb> </span>y;<span style=color:#bbb> </span>}<span style=color:#bbb> 
</span><span style=color:#bbb>   </span><span style=color:#069;font-weight:700>if</span><span style=color:#bbb> </span>n<span style=color:#bbb> </span><span style=color:#555>&lt;=</span><span style=color:#bbb> </span><span style=color:#f60>0</span><span style=color:#bbb> </span>{<span style=color:#bbb> </span>p<span style=color:#bbb> </span><span style=color:#555>=</span><span style=color:#bbb> </span><span style=color:#555>&amp;</span><span style=color:#069;font-weight:700>mut</span><span style=color:#bbb> </span>z;<span style=color:#bbb> </span>}<span style=color:#bbb> 
</span><span style=color:#bbb>   </span><span style=color:#09f;font-style:italic>//
</span><span style=color:#09f;font-style:italic></span><span style=color:#bbb>   </span>println<span style=color:#555>!</span>(<span style=color:#c30>&#34;x={},p={}&#34;</span>,x,p);<span style=color:#bbb>
</span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></code></pre></div><p>Here, we know the borrow <code>&mut x</code> has expired by the time we reach
<code>println!()</code>, but the borrow checker is not this smart (it is just a
fancy <a href=https://en.wikipedia.org/wiki/Data-flow_analysis>data-flow
analysis</a> after
all). We can also fix this program by just using an <code>else</code> block:</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Rust data-lang=Rust><span style=color:#069;font-weight:700>fn</span> <span style=color:#c0f>f</span>(n:<span style=color:#078;font-weight:700>i32</span>)<span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>   </span><span style=color:#069;font-weight:700>let</span><span style=color:#bbb> </span><span style=color:#069;font-weight:700>mut</span><span style=color:#bbb> </span>x<span style=color:#bbb> </span><span style=color:#555>=</span><span style=color:#bbb> </span><span style=color:#f60>123</span>;<span style=color:#bbb>
</span><span style=color:#bbb>   </span><span style=color:#069;font-weight:700>let</span><span style=color:#bbb> </span><span style=color:#069;font-weight:700>mut</span><span style=color:#bbb> </span>y<span style=color:#bbb> </span><span style=color:#555>=</span><span style=color:#bbb> </span><span style=color:#f60>234</span>;<span style=color:#bbb>
</span><span style=color:#bbb>   </span><span style=color:#069;font-weight:700>let</span><span style=color:#bbb> </span><span style=color:#069;font-weight:700>mut</span><span style=color:#bbb> </span>z<span style=color:#bbb> </span><span style=color:#555>=</span><span style=color:#bbb> </span><span style=color:#f60>456</span>;<span style=color:#bbb>
</span><span style=color:#bbb>   </span><span style=color:#069;font-weight:700>let</span><span style=color:#bbb> </span><span style=color:#069;font-weight:700>mut</span><span style=color:#bbb> </span>p<span style=color:#bbb> </span><span style=color:#555>=</span><span style=color:#bbb> </span><span style=color:#555>&amp;</span><span style=color:#069;font-weight:700>mut</span><span style=color:#bbb> </span>x;<span style=color:#bbb>
</span><span style=color:#bbb>   </span><span style=color:#09f;font-style:italic>//
</span><span style=color:#09f;font-style:italic></span><span style=color:#bbb>   </span><span style=color:#069;font-weight:700>if</span><span style=color:#bbb> </span>n<span style=color:#bbb> </span><span style=color:#555>&gt;=</span><span style=color:#bbb> </span><span style=color:#f60>0</span><span style=color:#bbb> </span>{<span style=color:#bbb> </span>p<span style=color:#bbb> </span><span style=color:#555>=</span><span style=color:#bbb> </span><span style=color:#555>&amp;</span><span style=color:#069;font-weight:700>mut</span><span style=color:#bbb> </span>y;<span style=color:#bbb> </span>}<span style=color:#bbb> 
</span><span style=color:#bbb>   </span><span style=color:#069;font-weight:700>else</span><span style=color:#bbb> </span>{<span style=color:#bbb> </span>p<span style=color:#bbb> </span><span style=color:#555>=</span><span style=color:#bbb> </span><span style=color:#555>&amp;</span><span style=color:#069;font-weight:700>mut</span><span style=color:#bbb> </span>z;<span style=color:#bbb> </span>}<span style=color:#bbb> 
</span><span style=color:#bbb>   </span><span style=color:#09f;font-style:italic>//
</span><span style=color:#09f;font-style:italic></span><span style=color:#bbb>   </span>println<span style=color:#555>!</span>(<span style=color:#c30>&#34;x={},p={}&#34;</span>,x,p);<span style=color:#bbb>
</span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></code></pre></div><p>This now compiles because the borrow checker can easily determine that
the borrow has expired on all paths through the function.</p><h2 id=conclusion>Conclusion</h2><p>Well, hopefully that was an interesting take on a few subtle points of
Rust! There is no real conclusion, but if you like studying the
borrow checker you might find my <a href=https://whileydave.com/publications/pea21_toplas/>recent paper on the
subject</a> provides
interesting reading.</p><hr></div></div><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-5582165-7','auto');ga('send','pageview');}</script></body></html>