<!doctype html><html lang=en><head><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta property="og:title" content="Testing out the Rust Model Checker (RMC)"><meta name=twitter:title content="Testing out the Rust Model Checker (RMC)"><meta property="og:url" content="https://whileydave.com/2021/10/15/testing-out-the-rust-model-checker-rmc/"><title>David J. Pearce
(Testing out the Rust Model Checker (RMC))</title><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css><link rel=stylesheet href=https://whileydave.com/css/page.css><link rel=stylesheet href=https://whileydave.com/css/menu.css><link rel=stylesheet href=https://whileydave.com/css/style.css></head><body><script>"use strict";function clearMenu(){var q=window.matchMedia("(max-width: 992px)");if(q.matches){var c=document.getElementById("menu-content");var m=document.getElementById("menu");c.style.display='none';m.style.filter='';}}
function toggleMenu(){var q=window.matchMedia("(max-width: 992px)");if(q.matches){var c=document.getElementById("menu-content");var m=document.getElementById("menu");if(c.style.display==='block'){c.style.display='none';m.style.filter='';}else{c.style.display='block';m.style.filter="brightness(0.8)";}}}
function toggleList(element){element.style.display="none";var parent=element.parentNode;var items=parent.childNodes;for(var i=0;i<items.length;++i){var item=items[i];if(item.classList&&item.classList.contains("hidden")){if(item.style.display==='block'){item.style.display="none";}else{item.style.display="block";}}}}</script><header class=topbar><div class=topbar-header onclick=clearMenu()><div class=topbar-title>Dr. David J. Pearce</div><div class=topbar-subtitle></div></div><div class=topbar-social onclick=clearMenu()><a href=https://github.com/DavePearce><i class="fa fa-github" aria-hidden=true></i></a><a href=https://twitter.com/WhileyDave><i class="fa fa-twitter" aria-hidden=true></i></a><a href=https://www.youtube.com/user/redjamjar/><i class="fa fa-youtube-play" aria-hidden=true></i></a><a href=https://www.linkedin.com/in/david-pearce-8592647/><i class="fa fa-linkedin-square" aria-hidden=true></i></a></div><div class=topbar-menu><div id=menu onclick=toggleMenu()><div id=menu-icon><img src=https://whileydave.com/images/menu.png alt=Menu></div><div id=menu-content><a href=https://whileydave.com/blog/>Blog</a>
<a href=https://whileydave.com/projects/>Projects</a>
<a href=https://whileydave.com/publications/>Publications</a>
<a href=https://whileydave.com/talks/>Talks</a>
<a href=https://whileydave.com/>Home</a></div></div></div></header><div class=container onclick=clearMenu()><div class=content><h1 class=post-title>Testing out the Rust Model Checker (RMC)</h1><div class=post-date>Friday, October
15th,
2021</div><hr><p>The <a href=https://github.com/model-checking/rmc>Rust Model Checker (RMC)</a>
allows Rust programs to be model checked using the <a href=https://www.cprover.org/cbmc/>C Bounded Model
Checker (CBMC)</a>. In essence, RMC is an
extension to the Rust compiler which converts Rust&rsquo;s
<a href=https://rustc-dev-guide.rust-lang.org/mir/index.html>MIR</a> into the
input language of CBMC (<a href=http://www.cprover.org/goto-cc/>GOTO</a>).</p><p>Using RMC provide can provide much stronger guarantees than, for
example, testing with <code>cargo-fuzz</code> or <code>proptest</code>. To understand how
it works, I&rsquo;m going to walk through the process of checking the
following simple function:</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Rust data-lang=Rust><span style=color:#069;font-weight:700>fn</span> <span style=color:#c0f>index_of</span>(items: <span style=color:#069>&amp;</span>[<span style=color:#078;font-weight:700>u32</span>],<span style=color:#bbb> </span>item: <span style=color:#078;font-weight:700>u32</span>)<span style=color:#bbb> </span>-&gt; <span style=color:#078;font-weight:700>usize</span> {<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#069;font-weight:700>for</span><span style=color:#bbb> </span>i<span style=color:#bbb> </span><span style=color:#069;font-weight:700>in</span><span style=color:#bbb> </span><span style=color:#f60>0</span>..items.len()<span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#069;font-weight:700>if</span><span style=color:#bbb> </span>items[i]<span style=color:#bbb> </span><span style=color:#555>==</span><span style=color:#bbb> </span>item<span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:#069;font-weight:700>return</span><span style=color:#bbb> </span>i;<span style=color:#bbb>
</span><span style=color:#bbb>        </span>}<span style=color:#bbb>
</span><span style=color:#bbb>    </span>}<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#09f;font-style:italic>//
</span><span style=color:#09f;font-style:italic></span><span style=color:#bbb>    </span><span style=color:#069;font-weight:700>return</span><span style=color:#bbb> </span><span style=color:#078;font-weight:700>usize</span>::MAX;<span style=color:#bbb>
</span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></code></pre></div><p>This is a good function for testing verification systems, since it has
some nice post-conditions. To get started we need to add some helper
methods, the first of which is:</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Rust data-lang=Rust><span style=color:#069;font-weight:700>fn</span> <span style=color:#c0f>__nondet</span><span style=color:#555>&lt;</span>T<span style=color:#555>&gt;</span>()<span style=color:#bbb> </span>-&gt; <span style=color:#0a8;font-weight:700>T</span><span style=color:#bbb> </span>{<span style=color:#bbb> </span>unimplemented<span style=color:#555>!</span>()<span style=color:#bbb> </span>}<span style=color:#bbb>
</span></code></pre></div><p>This function is known to RMC and has special significance. Here,
<code>__nondet&lt;T>()</code> returns a <em>non-deterministic value</em>. We can think of
this as an arbitrary value of the type <code>T</code> in question. This is where
the power of RMC comes from as, instead of testing individual values
of <code>T</code>, we&rsquo;re testing <em>all possible values</em> of <code>T</code>! The second helper
method we need is this:</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Rust data-lang=Rust><span style=color:#069;font-weight:700>fn</span> <span style=color:#c0f>__VERIFIER_assume</span>(cond: <span style=color:#078;font-weight:700>bool</span>)<span style=color:#bbb> </span>{<span style=color:#bbb> </span>unimplemented<span style=color:#555>!</span>()<span style=color:#bbb> </span>}<span style=color:#bbb>
</span></code></pre></div><p>Again this has specifical significance to RMC and, as we&rsquo;ll see, it is
used for <em>constraining</em> non-determinstic values. For example, we
might do something like this:</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Rust data-lang=Rust><span style=color:#069;font-weight:700>let</span><span style=color:#bbb> </span>x<span style=color:#bbb> </span>: <span style=color:#078;font-weight:700>u32</span> <span style=color:#555>=</span><span style=color:#bbb> </span>__nondet();<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#069;font-weight:700>let</span><span style=color:#bbb> </span>y<span style=color:#bbb> </span>: <span style=color:#078;font-weight:700>u32</span> <span style=color:#555>=</span><span style=color:#bbb> </span>__nondet();<span style=color:#bbb>
</span><span style=color:#bbb></span>__VERIFIER_assume(x<span style=color:#bbb> </span><span style=color:#555>&lt;</span><span style=color:#bbb> </span>y);<span style=color:#bbb>
</span></code></pre></div><p>Here, we assigned arbitrary values to <code>x</code> and <code>y</code> and then constrained
<code>x</code> so that its always below <code>y</code>. Perhaps we had to do this to meet
some requirement of the API we&rsquo;re testing. This means RMC will never
consider the values e.g. <code>x=10, y=10</code> or <code>x=0, y=255</code>. But, it will
still consider <em>all</em> values where <code>x &lt; y</code>, such as <code>x=0,y=1</code>,
<code>x=255,y=256</code>, etc. We can visualise this as follows:</p><figure class=text-center><img width=25% alt="Illustrating a 2D plane showing which values of x and y meet the condition x < y." src=/images/2021/Fooling_Borrow_Checker_Plane.png></figure><h2 id=our-first-proof>Our First Proof</h2><p>We&rsquo;re now going to write our first &ldquo;test&rdquo; using RMC. Except that its
not a test in the conventional sense, since we&rsquo;re using arbitrary
values. To try and make this distinction clear, RMC instead refers to
them as <em>proofs</em>.</p><p>So, let&rsquo;s write our first proof:</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Rust data-lang=Rust><span style=color:#099>#[cfg(rmc)]</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#099>#[no_mangle]</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#069;font-weight:700>pub</span><span style=color:#bbb> </span><span style=color:#069;font-weight:700>fn</span> <span style=color:#c0f>test_01</span>()<span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#069;font-weight:700>let</span><span style=color:#bbb> </span>xs<span style=color:#bbb> </span>: [<span style=color:#078;font-weight:700>u32</span>;<span style=color:#bbb> </span><span style=color:#f60>2</span>]<span style=color:#bbb> </span><span style=color:#555>=</span><span style=color:#bbb> </span>__nondet();<span style=color:#bbb>
</span><span style=color:#bbb>  </span>assert<span style=color:#555>!</span>(index_of(<span style=color:#555>&amp;</span>xs,<span style=color:#f60>0</span>)<span style=color:#bbb> </span><span style=color:#555>==</span><span style=color:#bbb> </span><span style=color:#078;font-weight:700>usize</span>::MAX);<span style=color:#bbb>
</span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></code></pre></div><p>This tells RMC to test <code>index_of()</code> for all possible arrays of size <code>2</code>
and, in doing so, RMC finds the <code>assert</code> can fail. This makes sense
as some arrays may contain <code>0</code> so <code>index_of()</code> will not always return
<code>usize::MAX</code>. This is the key difference between using RMC and an
automated testing tool: <em>upto certain bounds, RMC checks all possible
values</em>.</p><p><strong>NOTE:</strong> At the moment, RMC requires <code>#[cfg(rmc)]</code> to identify
proofs. However, <a href=https://github.com/model-checking/rmc/issues/464>the
plan</a> is eventually
to use <code>#[proof]</code> in the same way <code>#[test]</code> is used.</p><p>Anyway, something isn&rsquo;t quite right yet. The <code>index_of()</code> method is
correct, but our proof is failing. We need to refine our proof so
that it reflects the true contract of <code>index_of()</code>. Specifically,
when given an array <code>xs</code> which doesn&rsquo;t contain <code>0</code>, we expect
<code>index_of(xs,0)</code> to return <code>usize::MAX</code>. The question is how to set
this up with RMC. In fact, it&rsquo;s pretty easy since we know the size of
<code>xs</code>:</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Rust data-lang=Rust><span style=color:#099>#[cfg(rmc)]</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#099>#[no_mangle]</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#069;font-weight:700>pub</span><span style=color:#bbb> </span><span style=color:#069;font-weight:700>fn</span> <span style=color:#c0f>test_01</span>()<span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#069;font-weight:700>let</span><span style=color:#bbb> </span>xs<span style=color:#bbb> </span>: [<span style=color:#078;font-weight:700>u32</span>;<span style=color:#bbb> </span><span style=color:#f60>2</span>]<span style=color:#bbb> </span><span style=color:#555>=</span><span style=color:#bbb> </span>__nondet();<span style=color:#bbb>
</span><span style=color:#bbb>  </span>__VERIFIER_assume(xs[<span style=color:#f60>0</span>]<span style=color:#bbb> </span><span style=color:#555>!=</span><span style=color:#bbb> </span><span style=color:#f60>0</span>);<span style=color:#bbb>
</span><span style=color:#bbb>  </span>__VERIFIER_assume(xs[<span style=color:#f60>1</span>]<span style=color:#bbb> </span><span style=color:#555>!=</span><span style=color:#bbb> </span><span style=color:#f60>0</span>);<span style=color:#bbb>
</span><span style=color:#bbb>  </span>assert<span style=color:#555>!</span>(index_of(<span style=color:#555>&amp;</span>xs,<span style=color:#f60>0</span>)<span style=color:#bbb> </span><span style=color:#555>==</span><span style=color:#bbb> </span><span style=color:#078;font-weight:700>usize</span>::MAX);<span style=color:#bbb>
</span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></code></pre></div><p>We&rsquo;ve used <code>__VERIFIER_assume()</code> to tell RMC that it should assume the
elements in our array do not hold <code>0</code>. And finally RMC now reports,
as expected, that our proof suceeds!</p><h2 id=going-forward>Going Forward</h2><p>So, we&rsquo;ve written our first proof. <em>Now what?</em> Well, since our proof
only applies for arrays of size <code>2</code>, it would be nice to <em>generalise</em>
it. Unfortunately, testing arrays of arbitrary size is beyond the
limit of RMC but, for example, we can prove all arrays <em>upto</em> size
<code>3</code>. Furthermore our proof only checked for <code>item=0</code> but it would be
better to check for arbitrary values. So, let&rsquo;s put that altogether:</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Rust data-lang=Rust><span style=color:#099>#[cfg(rmc)]</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#099>#[no_mangle]</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#069;font-weight:700>pub</span><span style=color:#bbb> </span><span style=color:#069;font-weight:700>fn</span> <span style=color:#c0f>test_01</span>()<span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#069;font-weight:700>let</span><span style=color:#bbb> </span>x<span style=color:#bbb> </span>: <span style=color:#078;font-weight:700>u32</span> <span style=color:#555>=</span><span style=color:#bbb> </span>__nondet();<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#069;font-weight:700>let</span><span style=color:#bbb> </span>len<span style=color:#bbb> </span>: <span style=color:#078;font-weight:700>usize</span> <span style=color:#555>=</span><span style=color:#bbb> </span>__nondet();<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#069;font-weight:700>let</span><span style=color:#bbb> </span>xs<span style=color:#bbb> </span>: [<span style=color:#078;font-weight:700>u32</span>;<span style=color:#bbb> </span><span style=color:#f60>3</span>]<span style=color:#bbb> </span><span style=color:#555>=</span><span style=color:#bbb> </span>__nondet();<span style=color:#bbb>  
</span><span style=color:#bbb>  </span><span style=color:#09f;font-style:italic>// Apply Constraints  
</span><span style=color:#09f;font-style:italic></span><span style=color:#bbb>  </span>__VERIFIER_assume(len<span style=color:#bbb> </span><span style=color:#555>&lt;=</span><span style=color:#bbb> </span><span style=color:#f60>3</span>);<span style=color:#bbb>
</span><span style=color:#bbb>  </span>__VERIFIER_assume(xs[<span style=color:#f60>0</span>]<span style=color:#bbb> </span><span style=color:#555>!=</span><span style=color:#bbb> </span>x);<span style=color:#bbb>
</span><span style=color:#bbb>  </span>__VERIFIER_assume(xs[<span style=color:#f60>1</span>]<span style=color:#bbb> </span><span style=color:#555>!=</span><span style=color:#bbb> </span>x);<span style=color:#bbb>
</span><span style=color:#bbb>  </span>__VERIFIER_assume(xs[<span style=color:#f60>2</span>]<span style=color:#bbb> </span><span style=color:#555>!=</span><span style=color:#bbb> </span>x);<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#09f;font-style:italic>// Check
</span><span style=color:#09f;font-style:italic></span><span style=color:#bbb>  </span>assert<span style=color:#555>!</span>(index_of(<span style=color:#555>&amp;</span>xs[..len],x)<span style=color:#bbb> </span><span style=color:#555>==</span><span style=color:#bbb> </span><span style=color:#078;font-weight:700>usize</span>::MAX);<span style=color:#bbb>
</span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></code></pre></div><p><em>This is getting more interesting!</em> Now we&rsquo;re looking for an arbitrary
value <code>x</code> instead of <code>0</code>. Likewise, the final statement takes a
slice of <code>xs</code> upto a given length <code>len</code>. Since <code>len</code> is constrained
to be anything upto and including length <code>3</code>, this means RMC now
checks all arrays upto length <code>3</code>.</p><p>Our updated proof represents a significant improvement over the first.
But, there are still tweaks we can make. For example, it&rsquo;s good to
employ a constant <code>LIMIT</code> which determines the maximum length:</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Rust data-lang=Rust><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#069;font-weight:700>let</span><span style=color:#bbb> </span>xs<span style=color:#bbb> </span>: [<span style=color:#078;font-weight:700>u32</span>;<span style=color:#bbb> </span>LIMIT]<span style=color:#bbb> </span><span style=color:#555>=</span><span style=color:#bbb> </span>__nondet();<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#09f;font-style:italic>// Ensure length at most LIMIT
</span><span style=color:#09f;font-style:italic></span><span style=color:#bbb>  </span>__VERIFIER_assume(len<span style=color:#bbb> </span><span style=color:#555>&lt;=</span><span style=color:#bbb> </span>LIMIT);<span style=color:#bbb> 
</span><span style=color:#bbb>  </span><span style=color:#09f;font-style:italic>// Ensure element not in array below len
</span><span style=color:#09f;font-style:italic></span><span style=color:#bbb>  </span><span style=color:#069;font-weight:700>for</span><span style=color:#bbb> </span>i<span style=color:#bbb> </span><span style=color:#069;font-weight:700>in</span><span style=color:#bbb> </span><span style=color:#f60>0</span>..len<span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>    </span>__VERIFIER_assume(xs[i]<span style=color:#bbb> </span><span style=color:#555>!=</span><span style=color:#bbb> </span>x);<span style=color:#bbb>
</span><span style=color:#bbb>  </span>}<span style=color:#bbb>  
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></code></pre></div><p>Using <code>LIMIT</code> means we can easily try larger maximum lengths to see
how far RMC can go. However, using a <code>for</code> loop does cause some
difficulties for the underlying CBMC tool. To resolve this, we must
provide a command-line argument <code>--unwind X</code> where <code>X</code> is some bound
(e.g. <code>3</code>). This tells CBMC to <em>unroll</em> the loop at most <code>X</code> times.
In this case the maximum length of the array determines (roughly
speaking) how much unrolling CBMC needs to be confident the proof
holds.</p><h2 id=the-flip-side>The Flip Side</h2><p>Now we&rsquo;ve generalised our proof, its looking pretty nice. But, it
only checks the case when <code>item</code> is <em>not</em> in <code>items</code> &mdash; that&rsquo;s only
half the story! So, we should add a second proof for the case where
<code>item</code> <em>is</em> in <code>items</code>. This is my first attempt:</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Rust data-lang=Rust><span style=color:#099>#[cfg(rmc)]</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#099>#[no_mangle]</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#069;font-weight:700>pub</span><span style=color:#bbb> </span><span style=color:#069;font-weight:700>fn</span> <span style=color:#c0f>test_02</span>()<span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#069;font-weight:700>let</span><span style=color:#bbb> </span>x<span style=color:#bbb> </span>: <span style=color:#078;font-weight:700>u32</span> <span style=color:#555>=</span><span style=color:#bbb> </span>__nondet();<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#069;font-weight:700>let</span><span style=color:#bbb> </span>len<span style=color:#bbb> </span>: <span style=color:#078;font-weight:700>usize</span> <span style=color:#555>=</span><span style=color:#bbb> </span>__nondet();<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#069;font-weight:700>let</span><span style=color:#bbb> </span>xs<span style=color:#bbb> </span>: [<span style=color:#078;font-weight:700>u32</span>;<span style=color:#bbb> </span>LIMIT]<span style=color:#bbb> </span><span style=color:#555>=</span><span style=color:#bbb> </span>__nondet();<span style=color:#bbb>    
</span><span style=color:#bbb>    </span><span style=color:#069;font-weight:700>let</span><span style=color:#bbb> </span>i<span style=color:#bbb> </span>: <span style=color:#078;font-weight:700>usize</span> <span style=color:#555>=</span><span style=color:#bbb> </span>__nondet();<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#09f;font-style:italic>// Apply Constraints
</span><span style=color:#09f;font-style:italic></span><span style=color:#bbb>    </span>__VERIFIER_assume(len<span style=color:#bbb> </span><span style=color:#555>&lt;=</span><span style=color:#bbb> </span>LIMIT);<span style=color:#bbb>
</span><span style=color:#bbb>    </span>__VERIFIER_assume(i<span style=color:#bbb> </span><span style=color:#555>&lt;</span><span style=color:#bbb> </span>len);<span style=color:#bbb>
</span><span style=color:#bbb>    </span>__VERIFIER_assume(xs[i]<span style=color:#bbb> </span><span style=color:#555>==</span><span style=color:#bbb> </span>x);<span style=color:#bbb>    
</span><span style=color:#bbb>    </span><span style=color:#09f;font-style:italic>// Compute result
</span><span style=color:#09f;font-style:italic></span><span style=color:#bbb>    </span><span style=color:#069;font-weight:700>let</span><span style=color:#bbb> </span>result<span style=color:#bbb> </span><span style=color:#555>=</span><span style=color:#bbb> </span>index_of(<span style=color:#555>&amp;</span>xs[..len],x);<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#09f;font-style:italic>// Check it matches
</span><span style=color:#09f;font-style:italic></span><span style=color:#bbb>    </span>assert<span style=color:#555>!</span>(xs[result]<span style=color:#bbb> </span><span style=color:#555>==</span><span style=color:#bbb> </span>x);<span style=color:#bbb>
</span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></code></pre></div><p>This is roughly similar to before, except we now require <em>some</em> <code>i</code>
where <code>xs[i] == x</code>. Also, we cannot assume <code>index_of(&xs[..len],x)</code>
returns <code>i</code> <em>since there might be more than one occurence of <code>x</code> in
the array</em>.</p><p>We can observe that <code>index_of()</code> actually returns the <em>first</em> index of
<code>item</code>. So, to make things more interesting, let&rsquo;s assume this is
actually part of its contract. To check this, we must further
constrain <code>xs</code> to ensure <code>x</code> does not occur below <code>i</code> as follows:</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Rust data-lang=Rust><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#09f;font-style:italic>// Ensure nothing below i matches
</span><span style=color:#09f;font-style:italic></span><span style=color:#bbb>  </span><span style=color:#069;font-weight:700>for</span><span style=color:#bbb> </span>j<span style=color:#bbb> </span><span style=color:#069;font-weight:700>in</span><span style=color:#bbb> </span><span style=color:#f60>0</span>..i<span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>    </span>__VERIFIER_assume(xs[j]<span style=color:#bbb> </span><span style=color:#555>!=</span><span style=color:#bbb> </span>x);<span style=color:#bbb>
</span><span style=color:#bbb>  </span>}<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#09f;font-style:italic>// Check found correct one
</span><span style=color:#09f;font-style:italic></span><span style=color:#bbb>  </span>assert<span style=color:#555>!</span>(index_of(<span style=color:#555>&amp;</span>xs[..len],x)<span style=color:#bbb> </span><span style=color:#555>==</span><span style=color:#bbb> </span>i);<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></code></pre></div><p>From this we see that RMC proofs can be made quite sophisticated using
just the <code>__nondet&lt;T>()</code> and <code>__VERIFIER_assume()</code> statements.</p><h2 id=conclusion>Conclusion</h2><p>Hopefully this has given you an insight into how RMC works, and what a
proof is like. We&rsquo;ve only touched the tip of the iceberg here, but
the post was already quite long! You can learn more about using RMC
from the <a href=https://model-checking.github.io/rmc/>Getting Started
Guide</a>. Also, I found <a href=https://www.amazon.science/publications/model-checking-as-a-human-endeavor>this
paper</a>
provides good background on using tools like this in an industrial
setting.</p><p>Also, if you want to play around with RMC, here&rsquo;s a few suggestions of
things you could try:</p><ul><li><p>Implement <code>fill(items: &mut [u32], item: u32)</code> which fills a given
array <code>items</code> with a given value <code>item</code>.</p></li><li><p>Implement <code>reverse(items: &mut [u32])</code> which reverses the
contents of <code>items</code>.</p></li><li><p>Implement <code>index_of()</code> using <code>Vec&lt;T></code> instead of a slice.</p></li></ul><hr></div></div><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-5582165-7','auto');ga('send','pageview');}</script></body></html>