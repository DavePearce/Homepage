<!doctype html><html lang=en><head><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta property="og:title" content="Verifying the Whiley Standard Library"><meta name=twitter:title content="Verifying the Whiley Standard Library"><meta property="og:description" content="Using Boogie / Z3 it is possible verify a large number of Whiley programs."><meta name=twitter:description content="Using Boogie / Z3 it is possible verify a large number of Whiley programs."><meta property="og:image" content="https://whileydave.com/images/2021/Verifying_Whiley_Std.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://whileydave.com/images/2021/Verifying_Whiley_Std.png"><meta property="og:url" content="https://whileydave.com/2021/10/27/verifying-the-whiley-standard-library/"><title>David J. Pearce
(Verifying the Whiley Standard Library)</title><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css><link rel=stylesheet href=https://whileydave.com/css/page.css><link rel=stylesheet href=https://whileydave.com/css/menu.css><link rel=stylesheet href=https://whileydave.com/css/style.css><link rel=stylesheet href=https://whileydave.com/css/syntax.css></head><body><script>"use strict";function clearMenu(){var e,t,n=window.matchMedia("(max-width: 992px)");n.matches&&(e=document.getElementById("menu-content"),t=document.getElementById("menu"),e.style.display="none",t.style.filter="")}function toggleMenu(){var e,t,n=window.matchMedia("(max-width: 992px)");n.matches&&(e=document.getElementById("menu-content"),t=document.getElementById("menu"),e.style.display==="block"?(e.style.display="none",t.style.filter=""):(e.style.display="block",t.style.filter="brightness(0.8)"))}function toggleList(e){e.style.display="none";for(var t,o=e.parentNode,s=o.childNodes,n=0;n<s.length;++n)t=s[n],t.classList&&t.classList.contains("hidden")&&(t.style.display==="block"?t.style.display="none":t.style.display="block")}</script><header class=topbar><div class=topbar-header onclick=clearMenu()><div class=topbar-title>Dr. David J. Pearce</div><div class=topbar-subtitle></div></div><div class=topbar-social onclick=clearMenu()><a href=https://github.com/DavePearce><i class="fa fa-github" aria-hidden=true></i></a>
<a href=https://twitter.com/WhileyDave><i class="fa fa-twitter" aria-hidden=true></i></a>
<a href=https://www.youtube.com/user/redjamjar/><i class="fa fa-youtube-play" aria-hidden=true></i></a>
<a href=https://www.linkedin.com/in/david-pearce-8592647/><i class="fa fa-linkedin-square" aria-hidden=true></i></a></div><div class=topbar-menu><div id=menu onclick=toggleMenu()><div id=menu-icon><img src=https://whileydave.com/images/menu.png alt=Menu></div><div id=menu-content><a href=https://whileydave.com/blog/>Blog</a>
<a href=https://whileydave.com/projects/>Projects</a>
<a href=https://whileydave.com/publications/>Publications</a>
<a href=https://whileydave.com/talks/>Talks</a>
<a href=https://whileydave.com/>Home</a></div></div></div></header><div class=container onclick=clearMenu()><div class=content><h1 class=post-title>Verifying the Whiley Standard Library</h1><div class=post-date>Wednesday, October
27th,
2021</div><hr><p>For sometime now, its been possible to use
<a href=https://github.com/boogie-org/boogie>Boogie</a> /
<a href=https://github.com/Z3Prover/z3>Z3</a> as a backend for verifying Whiley
programs. Initially that was pretty sketchy, but it&rsquo;s really starting
to ramp up now. If you haven&rsquo;t heard of it before, Boogie is an
<em>Intermediate Verification Language (IVL)</em> that provides a
human-readable interface sitting on top of an <a href=https://en.wikipedia.org/wiki/Satisfiability_modulo_theories>SMT
solver</a>.
In this case, we use Z3 as the SMT solver &mdash; but it is possible to
use others, such as <a href=https://cvc4.github.io/>CVC4</a>, etc. Boogie was
initially developed at Microsoft, but is now maintained by a
consortium that appears to include Facebook and Amazon, amongst
others.</p><p>For example, here&rsquo;s a simple Whiley program:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Whiley data-lang=Whiley><span class=line><span class=cl><span class=kd>function</span> <span class=n>abs</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=p>(</span><span class=kt>int</span> <span class=n>r</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>ensures</span> <span class=n>r</span> <span class=o>&gt;=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=k>ensures</span> <span class=p>(</span><span class=n>r</span> <span class=o>==</span> <span class=n>x</span><span class=p>)</span> <span class=o>||</span> <span class=p>(</span><span class=n>r</span> <span class=o>==</span> <span class=o>-</span><span class=n>x</span><span class=p>)</span><span class=o>:</span>
</span></span><span class=line><span class=cl>   <span class=k>if</span> <span class=n>x</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=o>:</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=n>x</span>
</span></span><span class=line><span class=cl>   <span class=k>else</span><span class=o>:</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=o>-</span><span class=n>x</span>
</span></span></code></pre></div><p>The <a href=https://github.com/Whiley/Whiley2Boogie>Whiley2Boogie</a> backend
is responsible for translating the above program into Boogie. Here&rsquo;s
a simplified version of how that looks:</p><pre tabindex=0><code class=language-Boogie data-lang=Boogie>procedure abs(x : int) returns (r : int)
ensures r &gt;= 0;
ensures (r == x) || (r == -x);
{
   if(x &gt;= 0) {
      r := x;
      return;
   } else {
      r := -x;
      return;
   }
}
</code></pre><p>Here we can see there are a few differences from the Whiley code but,
in this example at least, the two look quite similar. In fact, Boogie
implements a form of Dijkstra&rsquo;s <a href=https://en.wikipedia.org/wiki/Guarded_Command_Language>Guarded Command
Language</a>
which has been extended with syntax to bring it closer to a
programming language. However, in some cases, it can end up looking
quite different.</p><h2 id=stdwy>STD.wy</h2><p>The Whiley standard library,
<a href=https://github.com/Whiley/STD.wy>STD.wy</a>, presents an interesting
target for verification, as it is currently the largest single body of
code written in Whiley. My goal is to verify the standard library
and, from thereafter, ensure it is verified on every commit (using a
<a href=https://github.com/Whiley/WhileyBuildAction>GitHub Action</a>). The
library is still pretty small, but contains some of the things you
would expect, such as collections (e.g. <code>std::vector</code>,
<code>std::hash_map</code>), ASCII support (<code>std::ascii</code>), math functions
(<code>std::math</code>) and various array manipulation functions (<code>std::array</code>).
Yes, it is very much a work in progress &mldr; <em>and now is the time to get
verification ingrained as part of the build process</em>.</p><p>As an example, here&rsquo;s a function from <code>std::array</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Whiley data-lang=Whiley><span class=line><span class=cl><span class=c1>// find first index after a given start point in list which matches character.
</span></span></span><span class=line><span class=cl><span class=c1>// If no match, then return null.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>function</span> <span class=n>first_index_of</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>(</span><span class=n>T</span><span class=p>[]</span> <span class=n>items</span><span class=p>,</span> <span class=n>T</span> <span class=n>item</span><span class=p>,</span> <span class=n>uint</span> <span class=n>start</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=p>(</span><span class=n>uint</span><span class=o>|</span><span class=kc>null</span> <span class=n>index</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>// Starting point cannot be beyond array
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>requires</span> <span class=n>start</span> <span class=o>&lt;=</span> <span class=o>|</span><span class=n>items</span><span class=o>|</span>
</span></span><span class=line><span class=cl><span class=c1>// If int returned, element at this position matches item
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>ensures</span> <span class=n>index</span> <span class=k>is</span> <span class=n>uint</span> <span class=o>==&gt;</span> <span class=n>items</span><span class=p>[</span><span class=n>index</span><span class=p>]</span> <span class=o>==</span> <span class=n>item</span>
</span></span><span class=line><span class=cl><span class=c1>// If int returned, element at this position is first match
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>ensures</span> <span class=n>index</span> <span class=k>is</span> <span class=n>uint</span> <span class=o>==&gt;</span> <span class=o>!</span><span class=n>contains</span><span class=p>(</span><span class=n>items</span><span class=p>,</span><span class=n>item</span><span class=p>,</span><span class=n>start</span><span class=p>,</span><span class=n>index</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>// If null returned, no element in items matches item
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>ensures</span> <span class=n>index</span> <span class=k>is</span> <span class=kc>null</span> <span class=o>==&gt;</span> <span class=o>!</span><span class=n>contains</span><span class=p>(</span><span class=n>items</span><span class=p>,</span><span class=n>item</span><span class=p>,</span><span class=n>start</span><span class=p>,</span><span class=o>|</span><span class=n>items</span><span class=o>|</span><span class=p>)</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=n>i</span> <span class=k>in</span> <span class=n>start</span> <span class=p>..</span> <span class=o>|</span><span class=n>items</span><span class=o>|</span>
</span></span><span class=line><span class=cl>    <span class=c1>// No element seen so far matches item
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>where</span> <span class=o>!</span><span class=n>contains</span><span class=p>(</span><span class=n>items</span><span class=p>,</span><span class=n>item</span><span class=p>,</span><span class=n>start</span><span class=p>,</span><span class=n>i</span><span class=p>)</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>items</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>==</span> <span class=n>item</span><span class=o>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=p>(</span><span class=n>uint</span><span class=p>)</span> <span class=n>i</span>
</span></span><span class=line><span class=cl>    <span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=kc>null</span>
</span></span></code></pre></div><p>This searches forward in <code>items</code> from a given <code>start</code> index and
returns either the first index matching <code>item</code> or (if none exists)
returns <code>null</code>. The specification is reasonably involved, but
essentially says this in logical form. To keep things a bit more
intuitive we&rsquo;ve used <code>contains()</code> instead of raw quantifiers. Here,
<code>constrains()</code> is a <code>property</code> defined in <code>std::array</code> as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Whiley data-lang=Whiley><span class=line><span class=cl><span class=kd>property</span> <span class=n>contains</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>(</span><span class=n>T</span><span class=p>[]</span> <span class=n>lhs</span><span class=p>,</span> <span class=n>T</span> <span class=n>item</span><span class=p>,</span> <span class=kt>int</span> <span class=n>start</span><span class=p>,</span> <span class=kt>int</span> <span class=n>end</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>// Some index in given range contains item
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>where</span> <span class=k>some</span> <span class=p>{</span> <span class=n>i</span> <span class=k>in</span> <span class=n>start</span><span class=p>..</span><span class=n>end</span> <span class=o>|</span> <span class=n>lhs</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>==</span> <span class=n>item</span> <span class=p>}</span>
</span></span></code></pre></div><p>The module <code>std::array</code> contains several predefined properties like
this which are helpful in specifying array manipulating functions.
The great thing about <code>first_index_of()</code> above is that we can now
<a href=https://en.wikipedia.org/wiki/Software_verification>statically
verify</a> that its
implementation meets its specification. No need to write lots of
extensive tests checking all the edge cases!! This also means
<code>first_index_of()</code> is guaranteed not to perform an out-of-bounds
access or exhibit other undefined behaviour. That is something really
quite powerful, and <a href=https://github.com/boogie-org/boogie>Boogie</a> /
<a href=https://github.com/Z3Prover/z3>Z3</a> is key to making it work.</p><h2 id=challenges>Challenges</h2><p>At this point, the goal was fairly straightforward: <em>go through all
the library functions adding specifications so they will now
statically verify</em>. This was quite a laborious task since, initially,
large chunks of the library had not been specified. Having largely
completed that now, we can proceed incrementally by requiring that
<em>all new code must be fully specified and pass verification</em>.</p><p>Still, there are some challenges. Most notably, we have at least
one function which currently cannot be verified (due to limitations
with Boogie / Z3). This is the following function:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Whiley data-lang=Whiley><span class=line><span class=cl><span class=k>unsafe</span> <span class=kd>function</span> <span class=n>copy</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>(</span><span class=n>T</span><span class=p>[]</span> <span class=n>src</span><span class=p>,</span> <span class=n>uint</span> <span class=n>srcStart</span><span class=p>,</span> <span class=n>T</span><span class=p>[]</span> <span class=n>dest</span><span class=p>,</span> <span class=n>uint</span> <span class=n>destStart</span><span class=p>,</span> <span class=n>uint</span> <span class=n>length</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=p>(</span><span class=n>T</span><span class=p>[]</span> <span class=n>result</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>// Source array must contain enough elements to be copied
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>requires</span> <span class=p>(</span><span class=n>srcStart</span> <span class=o>+</span> <span class=n>length</span><span class=p>)</span> <span class=o>&lt;=</span> <span class=o>|</span><span class=n>src</span><span class=o>|</span>
</span></span><span class=line><span class=cl><span class=c1>// Destination array must have enough space for copied elements
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>requires</span> <span class=p>(</span><span class=n>destStart</span> <span class=o>+</span> <span class=n>length</span><span class=p>)</span> <span class=o>&lt;=</span> <span class=o>|</span><span class=n>dest</span><span class=o>|</span>
</span></span><span class=line><span class=cl><span class=c1>// Result is same size as dest
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>ensures</span> <span class=o>|</span><span class=n>result</span><span class=o>|</span> <span class=o>==</span> <span class=o>|</span><span class=n>dest</span><span class=o>|</span>
</span></span><span class=line><span class=cl><span class=c1>// All elements before copied region are same
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>ensures</span> <span class=n>equals</span><span class=p>(</span><span class=n>dest</span><span class=p>,</span><span class=mi>0</span><span class=p>,</span><span class=n>result</span><span class=p>,</span><span class=mi>0</span><span class=p>,</span><span class=n>destStart</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>// All elements in copied region match src
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>ensures</span> <span class=n>equals</span><span class=p>(</span><span class=n>src</span><span class=p>,</span><span class=n>srcStart</span><span class=p>,</span><span class=n>result</span><span class=p>,</span><span class=n>destStart</span><span class=p>,</span><span class=n>length</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>// All elements above copied region are same
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>ensures</span> <span class=k>all</span> <span class=p>{</span> <span class=n>i</span> <span class=k>in</span> <span class=p>(</span><span class=n>destStart</span><span class=o>+</span><span class=n>length</span><span class=p>)</span> <span class=p>..</span> <span class=o>|</span><span class=n>dest</span><span class=o>|</span> <span class=o>|</span> <span class=n>dest</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>==</span> <span class=n>result</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=p>}</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>T</span><span class=p>[]</span> <span class=n>_dest</span> <span class=o>=</span> <span class=n>dest</span> <span class=c1>// ghost
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=n>i</span> <span class=k>in</span> <span class=mi>0</span> <span class=p>..</span> <span class=n>length</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Size of dest unchanged
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>where</span> <span class=o>|</span><span class=n>dest</span><span class=o>|</span> <span class=o>==</span> <span class=o>|</span><span class=n>_dest</span><span class=o>|</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Everything below destStart unchanged
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>where</span> <span class=n>equals</span><span class=p>(</span><span class=n>_dest</span><span class=p>,</span><span class=mi>0</span><span class=p>,</span><span class=n>dest</span><span class=p>,</span><span class=mi>0</span><span class=p>,</span><span class=n>destStart</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Everything copied so far is equal
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>where</span> <span class=n>equals</span><span class=p>(</span><span class=n>src</span><span class=p>,</span> <span class=n>srcStart</span><span class=p>,</span> <span class=n>dest</span><span class=p>,</span> <span class=n>destStart</span><span class=p>,</span> <span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Everything above j is unchanged
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>where</span> <span class=n>equals</span><span class=p>(</span><span class=n>_dest</span><span class=p>,</span><span class=n>dest</span><span class=p>,</span><span class=n>i</span><span class=o>+</span><span class=n>destStart</span><span class=p>,</span><span class=o>|</span><span class=n>dest</span><span class=o>|</span><span class=p>)</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=n>dest</span><span class=p>[</span><span class=n>i</span><span class=o>+</span><span class=n>destStart</span><span class=p>]</span> <span class=o>=</span> <span class=n>src</span><span class=p>[</span><span class=n>i</span><span class=o>+</span><span class=n>srcStart</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=n>dest</span>
</span></span></code></pre></div><p>This is roughly equivalent to <code>System.arraycopy()</code> in Java, and its
not very complicated. Unfortunately, Boogie / Z3 cannot verify this
without additional help. Whilst this is potentially something we can
fix in the <a href=https://github.com/Whiley/Whiley2Boogie>Whiley2Boogie</a>
backend, for now we simply mark the <code>function</code> as <code>unsafe</code>. This
means it will be ignored during verification. However, its
specification is still used when verifying other functions not marked
<code>unsafe</code>. Whilst this is not ideal, it is a pragmatic compromise for
now.</p><h2 id=conclusion>Conclusion</h2><p>Using Boogie / Z3 though the
<a href=https://github.com/Whiley/Whiley2Boogie>Whiley2Boogie</a> backend has
significantly improved our ability to verify non-trivial Whiley
programs. Work is ongoing here, and you can find a number of
<a href=https://github.com/Whiley/WyBench/tree/main/src>interesting
benchmarks</a> we are
currently working through.</p><hr></div></div><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-5582165-7","auto"),ga("send","pageview"))</script></body></html>