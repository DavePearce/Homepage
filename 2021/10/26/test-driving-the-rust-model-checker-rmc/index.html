<!doctype html><html lang=en><head><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta property="og:title" content="Test-Driving the Rust Model Checker (RMC)"><meta name=twitter:title content="Test-Driving the Rust Model Checker (RMC)"><meta property="og:description" content="RMC allows Rust programs to be model checked using CBMC."><meta name=twitter:description content="RMC allows Rust programs to be model checked using CBMC."><meta property="og:image" content="https://whileydave.com/images/2021/Test_Driving_Rust_Model_Checker_Preview.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://whileydave.com/images/2021/Test_Driving_Rust_Model_Checker_Preview.png"><meta property="og:url" content="https://whileydave.com/2021/10/26/test-driving-the-rust-model-checker-rmc/"><title>David J. Pearce
(Test-Driving the Rust Model Checker (RMC))</title><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css><link rel=stylesheet href=https://whileydave.com/css/page.css><link rel=stylesheet href=https://whileydave.com/css/menu.css><link rel=stylesheet href=https://whileydave.com/css/style.css><link rel=stylesheet href=https://whileydave.com/css/syntax.css></head><body><script>"use strict";function clearMenu(){var e,t,n=window.matchMedia("(max-width: 992px)");n.matches&&(e=document.getElementById("menu-content"),t=document.getElementById("menu"),e.style.display="none",t.style.filter="")}function toggleMenu(){var e,t,n=window.matchMedia("(max-width: 992px)");n.matches&&(e=document.getElementById("menu-content"),t=document.getElementById("menu"),e.style.display==="block"?(e.style.display="none",t.style.filter=""):(e.style.display="block",t.style.filter="brightness(0.8)"))}function toggleList(e){e.style.display="none";for(var t,o=e.parentNode,s=o.childNodes,n=0;n<s.length;++n)t=s[n],t.classList&&t.classList.contains("hidden")&&(t.style.display==="block"?t.style.display="none":t.style.display="block")}</script><header class=topbar><div class=topbar-header onclick=clearMenu()><div class=topbar-title>Dr. David J. Pearce</div><div class=topbar-subtitle></div></div><div class=topbar-social onclick=clearMenu()><a href=https://github.com/DavePearce><i class="fa fa-github" aria-hidden=true></i></a>
<a href=https://twitter.com/WhileyDave><i class="fa fa-twitter" aria-hidden=true></i></a>
<a href=https://www.youtube.com/user/redjamjar/><i class="fa fa-youtube-play" aria-hidden=true></i></a>
<a href=https://www.linkedin.com/in/david-pearce-8592647/><i class="fa fa-linkedin-square" aria-hidden=true></i></a></div><div class=topbar-menu><div id=menu onclick=toggleMenu()><div id=menu-icon><img src=https://whileydave.com/images/menu.png alt=Menu></div><div id=menu-content><a href=https://whileydave.com/blog/>Blog</a>
<a href=https://whileydave.com/projects/>Projects</a>
<a href=https://whileydave.com/publications/>Publications</a>
<a href=https://whileydave.com/talks/>Talks</a>
<a href=https://whileydave.com/>Home</a></div></div></div></header><div class=container onclick=clearMenu()><div class=content><h1 class=post-title>Test-Driving the Rust Model Checker (RMC)</h1><div class=post-date>Tuesday, October
26th,
2021</div><hr><p>The <a href=https://github.com/model-checking/rmc>Rust Model Checker (RMC)</a>
allows Rust programs to be model checked using the <a href=https://www.cprover.org/cbmc/>C Bounded Model
Checker (CBMC)</a>. In essence, RMC is an
extension to the Rust compiler which converts Rust&rsquo;s
<a href=https://rustc-dev-guide.rust-lang.org/mir/index.html>MIR</a> into the
input language of CBMC (<a href=http://www.cprover.org/goto-cc/>GOTO</a>).</p><p>Using RMC provide can provide much stronger guarantees than, for
example, testing with <code>cargo-fuzz</code> or <code>proptest</code>. To understand how
it works, I&rsquo;m going to walk through the process of checking the
following simple function:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Rust data-lang=Rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>index_of</span><span class=p>(</span><span class=n>items</span>: <span class=kp>&amp;</span><span class=p>[</span><span class=kt>u32</span><span class=p>],</span><span class=w> </span><span class=n>item</span>: <span class=kt>u32</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>usize</span> <span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=mi>0</span><span class=o>..</span><span class=n>items</span><span class=p>.</span><span class=n>len</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=n>items</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>item</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>return</span><span class=w> </span><span class=n>i</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=kt>usize</span>::<span class=n>MAX</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>This is a good function for testing verification systems, since it has
some nice post-conditions. To get started we need to add some helper
methods, the first of which is:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Rust data-lang=Rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>__nondet</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>()</span><span class=w> </span>-&gt; <span class=nc>T</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=fm>unimplemented!</span><span class=p>()</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>This function is known to RMC and has special significance. Here,
<code>__nondet&lt;T>()</code> returns a <em>non-deterministic value</em>. We can think of
this as an arbitrary value of the type <code>T</code> in question. This is where
the power of RMC comes from as, instead of testing individual values
of <code>T</code>, we&rsquo;re testing <em>all possible values</em> of <code>T</code>! The second helper
method we need is this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Rust data-lang=Rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>__VERIFIER_assume</span><span class=p>(</span><span class=n>cond</span>: <span class=kt>bool</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=fm>unimplemented!</span><span class=p>()</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>Again this has specifical significance to RMC and, as we&rsquo;ll see, it is
used for <em>constraining</em> non-determinstic values. For example, we
might do something like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Rust data-lang=Rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>x</span><span class=w> </span>: <span class=kt>u32</span> <span class=o>=</span><span class=w> </span><span class=n>__nondet</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>y</span><span class=w> </span>: <span class=kt>u32</span> <span class=o>=</span><span class=w> </span><span class=n>__nondet</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>__VERIFIER_assume</span><span class=p>(</span><span class=n>x</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>y</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><p>Here, we assigned arbitrary values to <code>x</code> and <code>y</code> and then constrained
<code>x</code> so that its always below <code>y</code>. Perhaps we had to do this to meet
some requirement of the API we&rsquo;re testing. This means RMC will never
consider the values e.g. <code>x=10, y=10</code> or <code>x=255, y=0</code>. But, it will
still consider <em>all</em> values where <code>x &lt; y</code>, such as <code>x=0,y=1</code>,
<code>x=255,y=256</code>, etc. We can visualise this as follows:</p><figure class=text-center><img height=300px alt="Illustrating a 2D plane showing which values of x and y meet the condition x < y." src=/images/2021/Fooling_Borrow_Checker_Plane.png></figure><h2 id=our-first-proof>Our First Proof</h2><p>We&rsquo;re now going to write our first &ldquo;test&rdquo; using RMC. Except that its
not a test in the conventional sense, since we&rsquo;re using arbitrary
values. To try and make this distinction clear, RMC instead refers to
them as <em>proofs</em>.</p><p>So, let&rsquo;s write our first proof:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Rust data-lang=Rust><span class=line><span class=cl><span class=cp>#[cfg(rmc)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cp>#[no_mangle]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>test_01</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kd>let</span><span class=w> </span><span class=n>xs</span><span class=w> </span>: <span class=p>[</span><span class=kt>u32</span><span class=p>;</span><span class=w> </span><span class=mi>2</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>__nondet</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=fm>assert!</span><span class=p>(</span><span class=n>index_of</span><span class=p>(</span><span class=o>&amp;</span><span class=n>xs</span><span class=p>,</span><span class=mi>0</span><span class=p>)</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kt>usize</span>::<span class=n>MAX</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>This tells RMC to test <code>index_of()</code> for all possible arrays of size
<code>2</code>. We can run RMC using e.g. <code>rmc index_of.rs</code> (if that&rsquo;s the name
of our file) and, in doing this, RMC will find the <code>assert</code> can fail.
This makes sense as some arrays may contain <code>0</code> so <code>index_of()</code> will
not always return <code>usize::MAX</code>. This is the key difference between
using RMC and an automated testing tool: <em>upto certain bounds, RMC
checks all possible values</em>.</p><p><strong>NOTE:</strong> At the moment, RMC requires <code>#[cfg(rmc)]</code> to identify
proofs. However, <a href=https://github.com/model-checking/rmc/issues/464>the
plan</a> is eventually
to use <code>#[proof]</code> in the same way <code>#[test]</code> is used.</p><p>Anyway, something isn&rsquo;t quite right yet. The <code>index_of()</code> method is
correct, but our proof is failing. We need to refine our proof so
that it reflects the true contract of <code>index_of()</code>. Specifically,
when given an array <code>xs</code> which doesn&rsquo;t contain <code>0</code>, we expect
<code>index_of(xs,0)</code> to return <code>usize::MAX</code>. The question is how to set
this up with RMC. In fact, it&rsquo;s pretty easy since we know the size of
<code>xs</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Rust data-lang=Rust><span class=line><span class=cl><span class=cp>#[cfg(rmc)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cp>#[no_mangle]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>test_01</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kd>let</span><span class=w> </span><span class=n>xs</span><span class=w> </span>: <span class=p>[</span><span class=kt>u32</span><span class=p>;</span><span class=w> </span><span class=mi>2</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>__nondet</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>__VERIFIER_assume</span><span class=p>(</span><span class=n>xs</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=mi>0</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>__VERIFIER_assume</span><span class=p>(</span><span class=n>xs</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=mi>0</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=fm>assert!</span><span class=p>(</span><span class=n>index_of</span><span class=p>(</span><span class=o>&amp;</span><span class=n>xs</span><span class=p>,</span><span class=mi>0</span><span class=p>)</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kt>usize</span>::<span class=n>MAX</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>We&rsquo;ve used <code>__VERIFIER_assume()</code> to tell RMC that it should assume the
elements in our array do not hold <code>0</code>. And finally RMC now reports,
as expected, that our proof suceeds!</p><h2 id=going-forward>Going Forward</h2><p>So, we&rsquo;ve written our first proof. <em>Now what?</em> Well, since our proof
only applies for arrays of size <code>2</code>, it would be nice to <em>generalise</em>
it. Unfortunately, testing arrays of arbitrary size is beyond the
limit of RMC but, for example, we can prove all arrays <em>upto</em> size
<code>3</code>. Furthermore our proof only checked for <code>item=0</code> but it would be
better to check for arbitrary values. So, let&rsquo;s put that altogether:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Rust data-lang=Rust><span class=line><span class=cl><span class=cp>#[cfg(rmc)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cp>#[no_mangle]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>test_01</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kd>let</span><span class=w> </span><span class=n>x</span><span class=w> </span>: <span class=kt>u32</span> <span class=o>=</span><span class=w> </span><span class=n>__nondet</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kd>let</span><span class=w> </span><span class=n>len</span><span class=w> </span>: <span class=kt>usize</span> <span class=o>=</span><span class=w> </span><span class=n>__nondet</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kd>let</span><span class=w> </span><span class=n>xs</span><span class=w> </span>: <span class=p>[</span><span class=kt>u32</span><span class=p>;</span><span class=w> </span><span class=mi>3</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>__nondet</span><span class=p>();</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// Apply Constraints  
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>  </span><span class=n>__VERIFIER_assume</span><span class=p>(</span><span class=n>len</span><span class=w> </span><span class=o>&lt;=</span><span class=w> </span><span class=mi>3</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>__VERIFIER_assume</span><span class=p>(</span><span class=n>xs</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=n>x</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>__VERIFIER_assume</span><span class=p>(</span><span class=n>xs</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=n>x</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>__VERIFIER_assume</span><span class=p>(</span><span class=n>xs</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=n>x</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// Check
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>  </span><span class=fm>assert!</span><span class=p>(</span><span class=n>index_of</span><span class=p>(</span><span class=o>&amp;</span><span class=n>xs</span><span class=p>[</span><span class=o>..</span><span class=n>len</span><span class=p>],</span><span class=n>x</span><span class=p>)</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kt>usize</span>::<span class=n>MAX</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p><em>This is getting more interesting!</em> Now we&rsquo;re looking for an arbitrary
value <code>x</code> instead of <code>0</code>. Likewise, the final statement takes a
slice of <code>xs</code> upto a given length <code>len</code>. Since <code>len</code> is constrained
to be anything upto and including length <code>3</code>, this means RMC now
checks all arrays upto length <code>3</code>.</p><p>Our updated proof represents a significant improvement over the first.
But, there are still tweaks we can make. For example, it&rsquo;s good to
employ a constant <code>LIMIT</code> which determines the maximum length:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Rust data-lang=Rust><span class=line><span class=cl><span class=w>  </span><span class=o>..</span><span class=p>.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kd>let</span><span class=w> </span><span class=n>xs</span><span class=w> </span>: <span class=p>[</span><span class=kt>u32</span><span class=p>;</span><span class=w> </span><span class=n>LIMIT</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>__nondet</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// Ensure length at most LIMIT
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>  </span><span class=n>__VERIFIER_assume</span><span class=p>(</span><span class=n>len</span><span class=w> </span><span class=o>&lt;=</span><span class=w> </span><span class=n>LIMIT</span><span class=p>);</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// Ensure element not in array below len
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>  </span><span class=k>for</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=mi>0</span><span class=o>..</span><span class=n>len</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>__VERIFIER_assume</span><span class=p>(</span><span class=n>xs</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=n>x</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>..</span><span class=p>.</span><span class=w>
</span></span></span></code></pre></div><p>Using <code>LIMIT</code> means we can easily try larger maximum lengths to see
how far RMC can go. However, using a <code>for</code> loop does cause some
difficulties for the underlying CBMC tool. To resolve this, we must
provide a command-line argument <code>--unwind X</code> where <code>X</code> is some bound
(e.g. <code>3</code>). This tells CBMC to <em>unroll</em> the loop at most <code>X</code> times.
In this case the maximum length of the array determines (roughly
speaking) how much unrolling CBMC needs to be confident the proof
holds.</p><h2 id=the-flip-side>The Flip Side</h2><p>Now we&rsquo;ve generalised our proof, its looking pretty nice. But, it
only checks the case when <code>item</code> is <em>not</em> in <code>items</code> &mdash; that&rsquo;s only
half the story! So, we should add a second proof for the case where
<code>item</code> <em>is</em> in <code>items</code>. This is my first attempt:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Rust data-lang=Rust><span class=line><span class=cl><span class=cp>#[cfg(rmc)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cp>#[no_mangle]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>test_02</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>x</span><span class=w> </span>: <span class=kt>u32</span> <span class=o>=</span><span class=w> </span><span class=n>__nondet</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>len</span><span class=w> </span>: <span class=kt>usize</span> <span class=o>=</span><span class=w> </span><span class=n>__nondet</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>xs</span><span class=w> </span>: <span class=p>[</span><span class=kt>u32</span><span class=p>;</span><span class=w> </span><span class=n>LIMIT</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>__nondet</span><span class=p>();</span><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>i</span><span class=w> </span>: <span class=kt>usize</span> <span class=o>=</span><span class=w> </span><span class=n>__nondet</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// Apply Constraints
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=n>__VERIFIER_assume</span><span class=p>(</span><span class=n>len</span><span class=w> </span><span class=o>&lt;=</span><span class=w> </span><span class=n>LIMIT</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>__VERIFIER_assume</span><span class=p>(</span><span class=n>i</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>len</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>__VERIFIER_assume</span><span class=p>(</span><span class=n>xs</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>x</span><span class=p>);</span><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// Compute result
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>result</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>index_of</span><span class=p>(</span><span class=o>&amp;</span><span class=n>xs</span><span class=p>[</span><span class=o>..</span><span class=n>len</span><span class=p>],</span><span class=n>x</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// Check it matches
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=fm>assert!</span><span class=p>(</span><span class=n>xs</span><span class=p>[</span><span class=n>result</span><span class=p>]</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>x</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>This is roughly similar to before, except we now require <em>some</em> <code>i</code>
where <code>xs[i] == x</code>. Also, we cannot assume <code>index_of(&xs[..len],x)</code>
returns <code>i</code> <em>since there might be more than one occurence of <code>x</code> in
the array</em>.</p><p>We can observe that <code>index_of()</code> actually returns the <em>first</em> index of
<code>item</code>. So, to make things more interesting, let&rsquo;s assume this is
actually part of its contract. To check this, we must further
constrain <code>xs</code> to ensure <code>x</code> does not occur below <code>i</code> as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Rust data-lang=Rust><span class=line><span class=cl><span class=w>  </span><span class=o>..</span><span class=p>.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// Ensure nothing below i matches
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>  </span><span class=k>for</span><span class=w> </span><span class=n>j</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=mi>0</span><span class=o>..</span><span class=n>i</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>__VERIFIER_assume</span><span class=p>(</span><span class=n>xs</span><span class=p>[</span><span class=n>j</span><span class=p>]</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=n>x</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// Check found correct one
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>  </span><span class=fm>assert!</span><span class=p>(</span><span class=n>index_of</span><span class=p>(</span><span class=o>&amp;</span><span class=n>xs</span><span class=p>[</span><span class=o>..</span><span class=n>len</span><span class=p>],</span><span class=n>x</span><span class=p>)</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>i</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>..</span><span class=p>.</span><span class=w>
</span></span></span></code></pre></div><p>From this we see that RMC proofs can be made quite sophisticated using
just the <code>__nondet&lt;T>()</code> and <code>__VERIFIER_assume()</code> statements. Also,
its worth noting another way of achieving this is to do the check
<em>after</em> calling <code>index_of()</code> (thanks to <code>@zhassan-aws</code> for pointing
this out):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Rust data-lang=Rust><span class=line><span class=cl><span class=w>  </span><span class=o>..</span><span class=p>.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kd>let</span><span class=w> </span><span class=n>result</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>indexof</span><span class=p>(</span><span class=o>&amp;</span><span class=n>xs</span><span class=p>[</span><span class=o>..</span><span class=n>len</span><span class=p>],</span><span class=n>x</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// Check it matches
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>  </span><span class=fm>assert!</span><span class=p>(</span><span class=n>xs</span><span class=p>[</span><span class=n>result</span><span class=p>]</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>x</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// Check its first
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>  </span><span class=k>for</span><span class=w> </span><span class=n>j</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=mi>0</span><span class=o>..</span><span class=n>result</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>     </span><span class=fm>assert!</span><span class=p>(</span><span class=n>xs</span><span class=p>[</span><span class=n>j</span><span class=p>]</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=n>x</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>..</span><span class=p>.</span><span class=w>
</span></span></span></code></pre></div><h2 id=conclusion>Conclusion</h2><p>Hopefully this has given you an insight into how RMC works, and what a
proof is like. We&rsquo;ve only touched the tip of the iceberg here, but
the post was already quite long! You can learn more about using RMC
from the <a href=https://model-checking.github.io/rmc/>Getting Started
Guide</a>. Also, I found <a href=https://www.amazon.science/publications/model-checking-as-a-human-endeavor>this
paper</a>
provides good background on using tools like this in an industrial
setting.</p><p>Finally, if you want to play around with RMC, here are a few
suggestions of things you could try:</p><ul><li><p>Implement <code>fill(items: &mut [u32], item: u32)</code> which fills a given
array <code>items</code> with a given value <code>item</code>.</p></li><li><p>Implement <code>reverse(items: &mut [u32])</code> which reverses the
contents of <code>items</code>.</p></li><li><p>Implement <code>index_of()</code> using <code>Vec&lt;T></code> instead of a slice.</p></li></ul><hr><i>Follow the discussion on
<a href=https://twitter.com/whileydave/status/1453196832784355332>Twitter</a>
or
<a href=https://www.reddit.com/r/rust/comments/qh238p/testdriving_the_rust_model_checker_rmc/>Reddit</a></i></div></div><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-5582165-7","auto"),ga("send","pageview"))</script></body></html>