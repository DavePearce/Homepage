<!doctype html><html lang=en><head><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta property="og:title" content="Formalising Flow Typing with Union, Intersection and Negation Types"><meta name=twitter:title content="Formalising Flow Typing with Union, Intersection and Negation Types"><meta property="og:url" content="https://whileydave.com/2012/10/31/formalising-flow-typing-with-union-intersection-and-negation-types/"><title>David J. Pearce
(Formalising Flow Typing with Union, Intersection and Negation Types)</title><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css><link rel=stylesheet href=https://whileydave.com/css/page.css><link rel=stylesheet href=https://whileydave.com/css/menu.css><link rel=stylesheet href=https://whileydave.com/css/style.css><link rel=stylesheet href=https://whileydave.com/css/syntax.css></head><body><script>"use strict";function clearMenu(){var e,t,n=window.matchMedia("(max-width: 992px)");n.matches&&(e=document.getElementById("menu-content"),t=document.getElementById("menu"),e.style.display="none",t.style.filter="")}function toggleMenu(){var e,t,n=window.matchMedia("(max-width: 992px)");n.matches&&(e=document.getElementById("menu-content"),t=document.getElementById("menu"),e.style.display==="block"?(e.style.display="none",t.style.filter=""):(e.style.display="block",t.style.filter="brightness(0.8)"))}function toggleList(e){e.style.display="none";for(var t,o=e.parentNode,s=o.childNodes,n=0;n<s.length;++n)t=s[n],t.classList&&t.classList.contains("hidden")&&(t.style.display==="block"?t.style.display="none":t.style.display="block")}</script><header class=topbar><div class=topbar-header onclick=clearMenu()><div class=topbar-title>Dr. David J. Pearce</div><div class=topbar-subtitle></div></div><div class=topbar-social onclick=clearMenu()><a href=https://github.com/DavePearce><i class="fa fa-github" aria-hidden=true></i></a>
<a href=https://twitter.com/WhileyDave><i class="fa fa-twitter" aria-hidden=true></i></a>
<a href=https://www.youtube.com/user/redjamjar/><i class="fa fa-youtube-play" aria-hidden=true></i></a>
<a href=https://www.linkedin.com/in/david-pearce-8592647/><i class="fa fa-linkedin-square" aria-hidden=true></i></a></div><div class=topbar-menu><div id=menu onclick=toggleMenu()><div id=menu-icon><img src=https://whileydave.com/images/menu.png alt=Menu></div><div id=menu-content><a href=https://whileydave.com/blog/>Blog</a>
<a href=https://whileydave.com/projects/>Projects</a>
<a href=https://whileydave.com/publications/>Publications</a>
<a href=https://whileydave.com/talks/>Talks</a>
<a href=https://whileydave.com/>Home</a></div></div></div></header><div class=container onclick=clearMenu()><div class=content><h1 class=post-title>Formalising Flow Typing with Union, Intersection and Negation Types</h1><div class=post-date>Wednesday, October
31st,
2012</div><hr><p>The Whiley language takes an unusual approaching to static typing called <em>flow typing</em>.  This helps to give Whiley the look-and-feel of a dynamically typed language.  The key idea behind flow typing is to allow variables to have different types at different points in a program.  For example, consider the following code written in a typical object oriented language (i.e. Java):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Square</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=kd>private</span> <span class=kt>int</span> <span class=n>x</span><span class=o>,</span> <span class=n>y</span><span class=o>,</span> <span class=n>len</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=o>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>equals</span><span class=o>(</span><span class=n>Object</span> <span class=n>o</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=o>(</span><span class=n>o</span> <span class=k>instanceof</span> <span class=n>Square</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>      <span class=n>Square</span> <span class=n>s</span> <span class=o>=</span> <span class=o>(</span><span class=n>Square</span><span class=o>)</span> <span class=n>o</span><span class=o>;</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=n>x</span> <span class=o>==</span> <span class=n>s</span><span class=o>.</span><span class=na>x</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>             <span class=n>y</span> <span class=o>==</span> <span class=n>s</span><span class=o>.</span><span class=na>y</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>             <span class=n>len</span> <span class=o>==</span> <span class=n>s</span><span class=o>.</span><span class=na>len</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>false</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span> <span class=o>}</span>
</span></span></code></pre></div><p>What is frustrating here, is that we need to cast variable <code>o</code> to an entirely new variable <code>s</code>. The condition <code>o instanceof Square</code> asserts that variable <code>o</code> has type <code>Square</code> &mdash; and, the compiler should really be able to exploit this to avoid the unnecessary cast.</p><p>In Whiley, the compiler is able (amongst other things) to exploit type tests in this manner. For example, consider the following Whiley program:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl><span class=n>define</span> <span class=n>Square</span> <span class=n>as</span> <span class=p>{</span> <span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=kt>int</span> <span class=n>y</span><span class=p>,</span> <span class=kt>int</span> <span class=n>len</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>define</span> <span class=n>Circle</span> <span class=n>as</span> <span class=p>{</span> <span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=kt>int</span> <span class=n>y</span><span class=p>,</span> <span class=kt>int</span> <span class=n>radius</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>define</span> <span class=n>Shape</span> <span class=n>as</span> <span class=n>Square</span> <span class=o>|</span> <span class=n>Circle</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>boolean</span> <span class=n>equals</span><span class=p>(</span><span class=n>Square</span> <span class=n>s1</span><span class=p>,</span> <span class=n>Shape</span> <span class=n>s2</span><span class=p>)</span><span class=o>:</span>
</span></span><span class=line><span class=cl>   <span class=k>if</span> <span class=n>s2</span> <span class=k>is</span> <span class=n>Square</span><span class=o>:</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=n>s1</span><span class=p>.</span><span class=n>x</span> <span class=o>==</span> <span class=n>s2</span><span class=p>.</span><span class=n>x</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>             <span class=n>s1</span><span class=p>.</span><span class=n>y</span> <span class=o>==</span> <span class=n>s2</span><span class=p>.</span><span class=n>y</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>             <span class=n>s1</span><span class=p>.</span><span class=n>len</span> <span class=o>==</span> <span class=n>s2</span><span class=p>.</span><span class=n>len</span>
</span></span><span class=line><span class=cl>   <span class=k>else</span><span class=o>:</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=kc>false</span>
</span></span></code></pre></div><p>In this example, no casting is necessary for variable <code>s2</code> as the Whiley compiler knows it has type <code>Square</code> when the condition <code>s2 is Square</code> holds. An interesting question is: <em>what type does <code>s2</code> have on the false branch?</em> Well, clearly, it is <em>not</em> a <code>Square</code>. And, that&rsquo;s exactly how it&rsquo;s implemented in the compiler &mdash; using a <em>negation type</em>. A negation type <code>¬T</code> represents a type containing everything except <code>T</code>. In our example above, the type of <code>s2</code> on the false branch is <code>Shape & ¬Square</code>. Here, <code>T1 & T2</code> represents the <em>intersection</em> of two types <code>T1</code> and <code>T2</code>. Thus, <code>Shape & ¬Square</code> represents everything in <code>Shape</code> but not in <code>Square</code>.</p><h2 id=subtyping-semantics>Subtyping Semantics</h2><p>In building a compiler, it&rsquo;s obviously important to develop algorithms for manipulating the types being used.  In this article, I want to focus on the algorithm for <em>subtyping</em>.  This simply reports whether or not a type <code>T1</code> subtypes a type <code>T2</code>, denoted <code>T1 &lt;= T2</code>. Based on the description given so far, one has an intuitive understanding of types as sets. That is, a type <code>T</code> represents the set of values which can be held in a variable declared with type <code>T</code>. In this way, we can think of <code>T1</code> being a subtype of <code>T2</code> if the set of values represented by <code>T1</code> is a subset of those represented by <code>T2</code>.</p><p>We now begin to formalise more precisely what types in Whiley mean (i.e. their <em>semantics</em>). We use the following language of types, which is a cut-down version of those found in Whiley:</p><figure class=text-center><img width=600px src=/images/2012/Types1.png></figure><p>Here, <code>any</code> is the type containing all values, <code>int</code> is the type of integers, (<code>T1,...,Tn)</code> is a tuple type, <code>¬T</code> is a negation type, <code>T1 /\ T2</code> an intersection type (written <code>T1 & T2</code> in Whiley source syntax), and <code>T1 \/ T2</code> a union type (written <code>T1 | T2</code> in Whiley source syntax).</p><p>To accompany our language of types, we need to define what constitutes a value in the system:</p><p><a href=http://whiley.org/wp-content/uploads/2012/10/Types2.png><figure class=text-center><imgsrc="http://whiley.org/wp-content/uploads/2012/10/types2.png"></figure></a></p><p>Here, <code>v</code> represents a value which is one of two possibilities: either it is an integer, or it is a tuple value the form <code>(v1,...,vn)</code>.  Using this we can give a <em>semantic interpretation</em> of types in our language:</p><p><a href=http://whiley.org/wp-content/uploads/2012/10/Types3.png><figure class=text-center><imgsrc="http://whiley.org/wp-content/uploads/2012/10/types3.png"></figure></a></p><p>Here, we have defined a way to construct the set of values represented by a given type  <code>T</code>.  Whilst this may all seem rather mundane, it provides the necessary foundation for the subtyping algorithm.</p><h2 id=an-incomplete-subtyping-algorithm>An (Incomplete) Subtyping Algorithm</h2><p>The subtyping algorithm is intended to determine when a type <code>T1</code> is a subtype of a type <code>T2</code>.  Or, equivalently, when the set of values represented by <code>T1</code> is a subset of those represented by <code>T2</code>. The algorithm is surprisingly difficult to get right, and it has taken me sometime to develop. The following represents a good attempt to capture the algorithm and is presented as a series of recursive &ldquo;type rules&rdquo; covering the different possible forms of <code>T1</code> and <code>T2</code>:</p><p><a href=http://whiley.org/wp-content/uploads/2012/10/Types4.png><figure class=text-center><imgsrc="http://whiley.org/wp-content/uploads/2012/10/types4.png"></figure></a></p><p>Under these rules, we can for example show that <code>(int,int)</code> is a subtype of <code>(any,any)</code> and, likewise, that <code>(int,int)</code>is a subtype of <code>(int,any)|(any,int)</code>.</p><p>The real challenge with the above subtyping rules is: <em>how do I know they are right?</em> Obviously, I want to be sure that the type checking algorithm in my compiler will work as expected.  But, it&rsquo;s rather difficult to decide this just by staring at the rules.  We need to break the problem down and we do this using the following notions of soundness and completeness:</p><ul><li><p><strong>Soundness</strong>.  If the algorithm decides <code>T1</code> subtypes <code>T2</code>, then it must follow that every value in <code>T1</code> is also in <code>T2</code>.</p></li><li><p><strong>Completeness</strong>.  If every value in <code>T1</code> is also in <code>T2</code>, then the algorithm must decide that <code>T1</code> subtypes <code>T2</code>.</p></li></ul><p>In fact, the above rules can be shown as sound.  <em>However, they are not complete</em>.  For example, we cannot show that <code>any</code> is a subtype of <code>int | ¬int</code> &mdash; a fact which is indeed true under our semantic interpretation.</p><h2 id=fixing-the-subtyping-algorithm>Fixing the Subtyping Algorithm</h2><p>Now, the question is:</p><p><em>Is there a sound and complete algorithm for subtyping testing in this language and, if so, what is it?</em>
The first part of the question (i.e. existence) was already shown by Frisch, Castagna, and Benzaken in their <a href=http://dx.doi.org/10.1145/1391289.1391293>excellent (albeit complicated) paper</a>.</p><p>The second part of the question (i.e. finding an actual algorithm) is also very important for me since I&rsquo;m implementing an actual compiler.  To figure this out, I went back to the drawing board several times and, finally, found a reasonable algorithm which is discussed here:</p><ul><li><strong>Sound and Complete Flow Typing with Unions, Intersections and Negations</strong>. David J. Pearce. In <em>Proceedings of the Conference on Verification, Model Checking, and Abstract Interpretation (VMCAI)</em>, 2013 (to appear) [<a href=/publications/Pea13_VMCAI_preprint.pdf>PDF</a>]</li></ul><p>I won&rsquo;t go into all the details here since its quite involved and the paper does a good job explaining things.  However, the key idea is to represent types in a &ldquo;special form&rdquo; such that we can easily perform the subtype tests.  The challenge is then to convert any given type <code>T</code> into its corresponding &ldquo;special form&rdquo;&mldr;</p><p>That&rsquo;s all for now!</p><hr></div></div><script async src="https://www.googletagmanager.com/gtag/js?id=G-9MRLB1FVZX"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-9MRLB1FVZX",{anonymize_ip:!1})}</script></body></html>