<!doctype html><html lang=en><head><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta property="og:title" content="Termination of Flow Typing in Whiley"><meta name=twitter:title content="Termination of Flow Typing in Whiley"><meta property="og:url" content="https://whileydave.com/2012/04/17/termination-of-flow-typing-in-whiley/"><title>David J. Pearce
(Termination of Flow Typing in Whiley)</title><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css><link rel=stylesheet href=https://whileydave.com/css/page.css><link rel=stylesheet href=https://whileydave.com/css/menu.css><link rel=stylesheet href=https://whileydave.com/css/style.css><link rel=stylesheet href=https://whileydave.com/css/syntax.css></head><body><script>"use strict";function clearMenu(){var e,t,n=window.matchMedia("(max-width: 992px)");n.matches&&(e=document.getElementById("menu-content"),t=document.getElementById("menu"),e.style.display="none",t.style.filter="")}function toggleMenu(){var e,t,n=window.matchMedia("(max-width: 992px)");n.matches&&(e=document.getElementById("menu-content"),t=document.getElementById("menu"),e.style.display==="block"?(e.style.display="none",t.style.filter=""):(e.style.display="block",t.style.filter="brightness(0.8)"))}function toggleList(e){e.style.display="none";for(var t,o=e.parentNode,s=o.childNodes,n=0;n<s.length;++n)t=s[n],t.classList&&t.classList.contains("hidden")&&(t.style.display==="block"?t.style.display="none":t.style.display="block")}</script><header class=topbar><div class=topbar-header onclick=clearMenu()><div class=topbar-title>Dr. David J. Pearce</div><div class=topbar-subtitle></div></div><div class=topbar-social onclick=clearMenu()><a href=https://github.com/DavePearce><i class="fa fa-github" aria-hidden=true></i></a>
<a href=https://twitter.com/WhileyDave><i class="fa fa-twitter" aria-hidden=true></i></a>
<a href=https://www.youtube.com/user/redjamjar/><i class="fa fa-youtube-play" aria-hidden=true></i></a>
<a href=https://www.linkedin.com/in/david-pearce-8592647/><i class="fa fa-linkedin-square" aria-hidden=true></i></a></div><div class=topbar-menu><div id=menu onclick=toggleMenu()><div id=menu-icon><img src=https://whileydave.com/images/menu.png alt=Menu></div><div id=menu-content><a href=https://whileydave.com/blog/>Blog</a>
<a href=https://whileydave.com/projects/>Projects</a>
<a href=https://whileydave.com/publications/>Publications</a>
<a href=https://whileydave.com/talks/>Talks</a>
<a href=https://whileydave.com/>Home</a></div></div></div></header><div class=container onclick=clearMenu()><div class=content><h1 class=post-title>Termination of Flow Typing in Whiley</h1><div class=post-date>Tuesday, April
17th,
2012</div><hr><p>Whiley uses <em>flow typing</em> to give it the look-and-feel of a dynamically typed language (see <a href=http://whiley.org/guide/typing/flow-typing/>this page</a> for more on flow typing).  In short, flow typing means that variables can have different types at different program points.  For example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl><span class=n>define</span> <span class=n>Node</span> <span class=n>as</span> <span class=p>{</span> <span class=kt>int</span> <span class=n>data</span><span class=p>,</span> <span class=n>Tree</span> <span class=n>left</span><span class=p>,</span> <span class=n>Tree</span> <span class=n>right</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>define</span> <span class=n>Tree</span> <span class=n>as</span> <span class=kc>null</span> <span class=o>|</span> <span class=n>Node</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Insert item into tree
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Tree</span> <span class=n>insert</span><span class=p>(</span><span class=n>Tree</span> <span class=n>tree</span><span class=p>,</span> <span class=kt>int</span> <span class=n>item</span><span class=p>)</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>tree</span> <span class=k>is</span> <span class=kc>null</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>          <span class=n>data</span><span class=o>:</span> <span class=n>item</span><span class=p>,</span>
</span></span><span class=line><span class=cl>          <span class=n>left</span><span class=o>:</span> <span class=kc>null</span><span class=p>,</span>
</span></span><span class=line><span class=cl>          <span class=n>right</span><span class=o>:</span> <span class=kc>null</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span> <span class=n>item</span> <span class=o>&lt;</span> <span class=n>tree</span><span class=p>.</span><span class=n>data</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=n>tree</span><span class=p>.</span><span class=n>left</span> <span class=o>=</span> <span class=n>insert</span><span class=p>(</span><span class=n>tree</span><span class=p>.</span><span class=n>left</span><span class=p>,</span><span class=n>item</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=n>tree</span><span class=p>.</span><span class=n>right</span> <span class=o>=</span> <span class=n>insert</span><span class=p>(</span><span class=n>tree</span><span class=p>.</span><span class=n>right</span><span class=p>,</span><span class=n>item</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1>// done
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=n>tree</span>
</span></span></code></pre></div><p>Here, Whiley&rsquo;s flow typing system automatically <em>retypes</em> the variable <code>tree</code> to <code>Node</code> on the false branch of the condition <code>tree is null</code>. Thus, we can safely use <code>tree.left</code> and <code>tree.right</code> without having to explicitly cast <code>tree</code> to a <code>Node</code>. In this way, we see that variable <code>tree</code> has different types at different points. In this case, it always has one of the following types: <code>Tree</code>, <code>Node</code> or <code>null</code> (the latter being its type on the true branch of the condition <code>tree is null</code>).</p><p>In the above example, the different types of tree are related &mdash; i.e. <code>Node</code> and <code>null</code> are both subtypes of <code>Tree</code>. However, Whiley&rsquo;s flow typing system can also work with unrelated types. A more involved example, based on my Chess benchmark, illustrates:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl><span class=n>define</span> <span class=n>LongPos</span> <span class=n>as</span> <span class=p>{</span> <span class=kt>int</span> <span class=n>col</span><span class=p>,</span> <span class=kt>int</span> <span class=n>row</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>define</span> <span class=n>LongMove</span> <span class=n>as</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>Piece</span> <span class=n>piece</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=n>LongPos</span> <span class=kd>from</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=n>LongPos</span> <span class=n>to</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>define</span> <span class=n>ShortPos</span> <span class=n>as</span> <span class=p>{</span><span class=kt>int</span> <span class=n>row</span><span class=p>}</span> <span class=o>|</span> <span class=p>{</span><span class=kt>int</span> <span class=n>col</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>define</span> <span class=n>ShortMove</span> <span class=n>as</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>Piece</span> <span class=n>piece</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=n>ShortPos</span> <span class=kd>from</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=n>LongPos</span> <span class=n>to</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Find matching pieces on the board.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>[</span><span class=n>Pos</span><span class=p>]</span> <span class=n>find</span><span class=p>(</span><span class=n>Piece</span> <span class=n>p</span><span class=p>,</span> <span class=n>Board</span> <span class=n>b</span><span class=p>)</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Intersect destination with possible moves of matching pieces.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>[</span><span class=n>Pos</span><span class=p>]</span> <span class=n>narrow</span><span class=p>(</span><span class=n>ShortMove</span> <span class=n>m</span><span class=p>,</span> <span class=p>[</span><span class=n>Pos</span><span class=p>]</span> <span class=n>ms</span><span class=p>,</span> <span class=n>Board</span> <span class=n>b</span><span class=p>)</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Convert move in short notation into long notation.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>LongMove</span> <span class=n>convert</span><span class=p>(</span><span class=n>ShortMove</span> <span class=n>m</span><span class=p>,</span> <span class=n>Board</span> <span class=n>b</span><span class=p>)</span> <span class=n>throws</span> <span class=n>Error</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>matches</span> <span class=o>=</span> <span class=n>find</span><span class=p>(</span><span class=n>m</span><span class=p>.</span><span class=n>piece</span><span class=p>,</span><span class=n>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>matches</span> <span class=o>=</span> <span class=n>narrow</span><span class=p>(</span><span class=n>m</span><span class=p>.</span><span class=n>to</span><span class=p>,</span><span class=n>matches</span><span class=p>,</span><span class=n>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=o>|</span><span class=n>matches</span><span class=o>|</span> <span class=o>!=</span> <span class=mi>1</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=n>throw</span> <span class=n>Error</span><span class=p>(</span><span class=err>&#34;</span><span class=n>invalid</span> <span class=n>move</span><span class=err>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>m</span><span class=p>.</span><span class=kd>from</span> <span class=o>=</span> <span class=n>matches</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>m</span>
</span></span></code></pre></div><p>This code converts moves expressed in <em>short algebraic notation</em> into <em>long algebraic notation</em> (see <a href=http://en.wikipedia.org/wiki/Algebraic_notation_(chess)>this</a> for more). In the short notation, moves are given in an abbreviated (and potentially ambiguous) form with only the destination square given. For example, a move <code>Nf6</code> indicates a Knight moving to square <code>f6</code>. If the player has only one knight, then the move must refer to it. However, if there are two Knights, the system must determine which it is. This is done by <code>narrow()</code> above, which intersects the destination with the possible moves of the matching pieces. In the case of multiple matches, an <code>Error</code> is thrown. The notation also permits explicit disambiguation by providing either the <em>rank</em> or <em>file</em> of the given piece. For example, <code>Neg3</code> indicates the Knight on file <code>e</code> moves to square <code>g3</code>.</p><p>Flow typing is crucial in type checking the above fragment. The critical issue resolves around the statement <code>m.from = matches[0]</code>. This retypes variable <code>m</code> from <code>ShortMove</code> to <code>LongMove</code>, allowing the subsequent statement <code>return m</code> to be type checked. In this case, there is no subtyping relationship between <code>ShortMove</code> and <code>LongMove</code> &mdash; they are essentially unrelated.</p><h2 id=a-problem-of-termination>A Problem of Termination</h2><p>We now come to the main topic of this post. Consider the following very simple example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl><span class=n>define</span> <span class=n>Rec</span> <span class=n>as</span> <span class=kt>int</span> <span class=o>|</span> <span class=p>{</span> <span class=n>Rec</span> <span class=n>f</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Rec</span> <span class=n>loopy</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=kt>int</span> <span class=n>y</span><span class=p>)</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=n>z</span> <span class=o>=</span> <span class=p>{</span> <span class=n>f</span> <span class=o>:</span> <span class=n>x</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>while</span> <span class=n>x</span> <span class=o>&lt;</span> <span class=n>y</span><span class=o>:</span>
</span></span><span class=line><span class=cl>     <span class=n>z</span><span class=p>.</span><span class=n>f</span> <span class=o>=</span> <span class=n>z</span>
</span></span><span class=line><span class=cl>     <span class=n>x</span> <span class=o>=</span> <span class=n>x</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>z</span>
</span></span></code></pre></div><p>This program currently causes the Whiley Compiler to enter an infinite loop! <em>But, why is that?</em> Well, the key is that flow typing is implemented in the style of a <a href=http://en.wikipedia.org/wiki/Data-flow_analysis>dataflow analysis</a>. Roughly speaking, the algorithm employs an <em>environment</em> which maps variables to their current type. It then processes each statement updating the environment as it proceeds. The following illustrates the process for the first two statements above:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl><span class=n>Rec</span> <span class=n>loopy</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=kt>int</span> <span class=n>y</span><span class=p>)</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=c1>// x-&gt;int, y-&gt;int
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>z</span> <span class=o>=</span> <span class=p>{</span> <span class=n>f</span> <span class=o>:</span> <span class=n>x</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=c1>// x=&gt;int, y=&gt;int, z=&gt;{int f}
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=p>...</span>
</span></span></code></pre></div><p>In many ways, this is the natural way to implement the flow typing algorithm and follows, for example, the approach used in the JVM bytecode verifier (perhaps the most widely used example of flow typing).</p><p><em>So, why does the above short program not terminate?</em> Well, a dataflow analysis handles loops by iterating until a <em>fixed-point</em> is reached. This is done by first propagating through the loop body to update the environment, like so:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl>  <span class=c1>// x=&gt;int, y=&gt;int, z=&gt;{int f}
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>while</span> <span class=n>x</span> <span class=o>&lt;</span> <span class=n>y</span><span class=o>:</span>
</span></span><span class=line><span class=cl>      <span class=c1>// x=&gt;int, y=&gt;int, z=&gt;{int f}
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=n>z</span><span class=p>.</span><span class=n>f</span> <span class=o>=</span> <span class=n>z</span>
</span></span><span class=line><span class=cl>      <span class=c1>// x=&gt;int, y=&gt;int, z=&gt;{{int f] f}
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=n>x</span> <span class=o>=</span> <span class=n>x</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>      <span class=c1>// x=&gt;int, y=&gt;int, z=&gt;{{int f] f}
</span></span></span></code></pre></div><p>At this point, it merges the new environment with that originally going into the loop and repeats the process:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl>  <span class=c1>// x=&gt;int, y=&gt;int, z=&gt;{int f}
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>while</span> <span class=n>x</span> <span class=o>&lt;</span> <span class=n>y</span><span class=o>:</span>
</span></span><span class=line><span class=cl>      <span class=c1>// x=&gt;int, y=&gt;int, z=&gt;{{int f}|int f}
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=n>z</span><span class=p>.</span><span class=n>f</span> <span class=o>=</span> <span class=n>z</span>
</span></span><span class=line><span class=cl>      <span class=c1>// x=&gt;int, y=&gt;int, z=&gt;{{{int f}|int f} f}
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=n>x</span> <span class=o>=</span> <span class=n>x</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>      <span class=c1>// x=&gt;int, y=&gt;int, z=&gt;{{{int f}|int f} f}
</span></span></span></code></pre></div><p>And then repeats again:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl>  <span class=c1>// x=&gt;int, y=&gt;int, z=&gt;{int f}
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>while</span> <span class=n>x</span> <span class=o>&lt;</span> <span class=n>y</span><span class=o>:</span>
</span></span><span class=line><span class=cl>      <span class=c1>// x=&gt;int, y=&gt;int, z=&gt;{{{int f}|int f} f}
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=n>z</span><span class=p>.</span><span class=n>f</span> <span class=o>=</span> <span class=n>z</span>
</span></span><span class=line><span class=cl>      <span class=c1>// x=&gt;int, y=&gt;int, z=&gt;{{{{int f}|int f} f} f}
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=n>x</span> <span class=o>=</span> <span class=n>x</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>      <span class=c1>// x=&gt;int, y=&gt;int, z=&gt;{{{{int f}|int f} f} f}
</span></span></span></code></pre></div><p>And so on, until there is no change in the environment (i.e. the fixed point is reached). For a typical dataflow analysis, this should happen within a few iterations. However, for the above flow typing algorithm, <em>this process will never terminate because it is constructing successively larger types for variable <code>z</code></em>.</p><p>In fact, we can obtain a valid flow-typing for our simple program as the following illustrates:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl><span class=n>Rec</span> <span class=n>loopy</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=kt>int</span> <span class=n>y</span><span class=p>)</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=c1>// x-&gt;int, y-&gt;int
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>z</span> <span class=o>=</span> <span class=p>{</span> <span class=n>f</span> <span class=o>:</span> <span class=n>x</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=c1>// x=&gt;int, y=&gt;int, z=&gt;{int f}
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>while</span> <span class=n>x</span> <span class=o>&lt;</span> <span class=n>y</span><span class=o>:</span>
</span></span><span class=line><span class=cl>      <span class=c1>// x=&gt;int, y=&gt;int, z=&gt;{Rec f}
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=n>z</span><span class=p>.</span><span class=n>f</span> <span class=o>=</span> <span class=n>z</span>
</span></span><span class=line><span class=cl>      <span class=c1>// x=&gt;int, y=&gt;int, z=&gt;{Rec f}
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=n>x</span> <span class=o>=</span> <span class=n>x</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>   <span class=c1>// x=&gt;int, y=&gt;int, z=&gt;{Rec f}
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=k>return</span> <span class=n>z</span>
</span></span></code></pre></div><p>The key is that assigning <code>{Rec f}</code> to field <code>f</code> gives the type <code>{{Rec f} f}</code> &mdash; which is a subtype of <code>{Rec f}</code>. Hence, the above typing is valid (albeit conservative). The problem is how to go about finding this typing, given that the standard dataflow approach does not succeed.</p><p>At this point, I&rsquo;m not going to say too much more. That&rsquo;s because I&rsquo;ve written up a <a href=/publications/ECSTR12-10.pdf>detailed account of the solution in a technical report</a>. The key idea is to use a <em>constraint-based</em> approach, rather than a dataflow approach. Whilst this is slightly more complex, it has one important advantage: <em>the algorithm always terminates!</em></p><hr></div></div><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-5582165-7","auto"),ga("send","pageview"))</script></body></html>