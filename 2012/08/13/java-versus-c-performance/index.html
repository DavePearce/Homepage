<!doctype html><html lang=en><head><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta property="og:title" content="Java versus C++ Performance"><meta name=twitter:title content="Java versus C++ Performance"><meta property="og:url" content="https://whileydave.com/2012/08/13/java-versus-c-performance/"><title>David J. Pearce
(Java versus C++ Performance)</title><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css><link rel=stylesheet href=https://whileydave.com/css/page.css><link rel=stylesheet href=https://whileydave.com/css/menu.css><link rel=stylesheet href=https://whileydave.com/css/style.css><link rel=stylesheet href=https://whileydave.com/css/syntax.css></head><body><script>"use strict";function clearMenu(){var e,t,n=window.matchMedia("(max-width: 992px)");n.matches&&(e=document.getElementById("menu-content"),t=document.getElementById("menu"),e.style.display="none",t.style.filter="")}function toggleMenu(){var e,t,n=window.matchMedia("(max-width: 992px)");n.matches&&(e=document.getElementById("menu-content"),t=document.getElementById("menu"),e.style.display==="block"?(e.style.display="none",t.style.filter=""):(e.style.display="block",t.style.filter="brightness(0.8)"))}function toggleList(e){e.style.display="none";for(var t,o=e.parentNode,s=o.childNodes,n=0;n<s.length;++n)t=s[n],t.classList&&t.classList.contains("hidden")&&(t.style.display==="block"?t.style.display="none":t.style.display="block")}</script><header class=topbar><div class=topbar-header onclick=clearMenu()><div class=topbar-title>Dr. David J. Pearce</div><div class=topbar-subtitle></div></div><div class=topbar-social onclick=clearMenu()><a href=https://github.com/DavePearce><i class="fa fa-github" aria-hidden=true></i></a>
<a href=https://twitter.com/WhileyDave><i class="fa fa-twitter" aria-hidden=true></i></a>
<a href=https://www.youtube.com/user/redjamjar/><i class="fa fa-youtube-play" aria-hidden=true></i></a>
<a href=https://www.linkedin.com/in/david-pearce-8592647/><i class="fa fa-linkedin-square" aria-hidden=true></i></a></div><div class=topbar-menu><div id=menu onclick=toggleMenu()><div id=menu-icon><img src=https://whileydave.com/images/menu.png alt=Menu></div><div id=menu-content><a href=https://whileydave.com/blog/>Blog</a>
<a href=https://whileydave.com/projects/>Projects</a>
<a href=https://whileydave.com/publications/>Publications</a>
<a href=https://whileydave.com/talks/>Talks</a>
<a href=https://whileydave.com/>Home</a></div></div></div></header><div class=container onclick=clearMenu()><div class=content><h1 class=post-title>Java versus C++ Performance</h1><div class=post-date>Monday, August
13th,
2012</div><hr><p>Recently, I came across an interesting <a href=http://programmers.stackexchange.com/q/159373/25936>discussion of C++ versus Java performance over on Stack Exchange</a>. There was also some <a href=http://www.reddit.com/r/programming/comments/xo4my/what_backs_up_the_claim_that_c_can_be_faster_than/>good discussion of the article on Reddit</a> which included a link to an <a href=https://days2011.scala-lang.org/sites/days2011/files/ws3-1-Hundt.pdf>interesting article from Google</a>.</p><p>Understanding these languages from a performance perspective is important to me, as it impacts the design of Whiley. So, I thought I&rsquo;d highlight the main strands from that article and the subsequent discussions, and also add a few points I think were missed:</p><ul><li><p><strong>Memory Usage.</strong> Accessing RAM has become relatively slow as CPU performance has increased and, hence, memory utilisation is extremely important in practice.  Java fairs quite badly on this front since: a) every object occupies <a href=http://www.javamex.com/tutorials/memory/object_memory_usage.shtml>at least 8 bytes</a>; b) you can&rsquo;t stack allocate objects; c) the commonly used collections library forces most things to be an object.  Also, arrays of objects in Java are really arrays of references and, hence, cannot be allocated contiguously &mdash; which hurts cache performance.</p></li><li><p><strong>Garbage Collection</strong>.  This is a common complaint against Java performance.  With explicit explicit memory management in C++, you can tightly control the process of allocating and deallocating memory.  This means, for example, large chunks can be allocated up front and pooled.  And, also, that long-lived memory imposes minimal overhead.  However, there is one C++ performance problem I have encountered here: <em>memory fragmentation</em>.  The garbage collector is constantly compacting used memory into a contiguous block &mdash; which can really help performance.  In contrast, for long running applications in C++, memory can become severely fragmented which affects both allocation time and cache performance.  Particularly if the amount of allocated memory at any one time fluctuates significantly.</p></li><li><p><strong>Language Specification</strong>.  The Java Language Specification is much more specific on the order in which Java programs are executed.  For example, that expressions are always executed in left-to-right fashion.  In C++, there is more flexibility in terms of implementation &mdash; which makes things harder to debug, but also gives the compiler more freedom.  Personally, I think the Java Language Spec is really a step in the right direction to ensuring software quality (i.e. that there are no unexpected surprises), so I&rsquo;d be happy to live with this cost.</p></li><li><p><strong>Execution Model.</strong> There are advantages to using a <a href=http://en.wikipedia.org/wiki/Just-in-time_compilation>Virtual Machine with Just-In-Time compilation</a> (i.e. Java), compared with a static compilation model (i.e. C++).  In particular, a virtual machine can optimise according to the current workload of the program.  In contrast, a static compilation model has to guess ahead-of-time what the workload will be, and where optimisation should be focused.  This causes problems because some optimisations (e.g. inlining) negatively impact performance if used pervasively.  To combat this, modern C++ compilers now support <em><a href=http://en.wikipedia.org/wiki/Profile-guided_optimization>profile guided optimisation</a></em> which helps mitigate this.  Nevertheless, on long running programs which have varying and unpredictable workload behaviour, the JIT should (in theory, at least) have an advantage.  Web applications might be one area where this holds true, although it&rsquo;s unclear to me how well current JIT&rsquo;s adapt to changing workloads (i.e. will they actually <em>undo</em> an optimisation when it no longer makes sense?).</p></li></ul><p>My general feeling is that performance remains a critical issue for language design.  Many people say &ldquo;<em>machines are fast enough</em>&rdquo; or that &ldquo;<em>with a sufficiently smart compiler&mldr;</em>&rdquo;, etc.  In practice, these things never come to pass because the goalposts themselves are moving.  For example, web applications must routinely scale up to millions of hits a day (or more), compared with tens of thousands only a few years ago.  And, in the future, we&rsquo;ll demand even more.</p><p>Finally, the focus on memory utilisation as a fundamental performance bottleneck makes me question the future of <a href=http://www.javalobby.org/java/forums/t83631.html>pure object-oriented languages</a>.  Today, these language appear to be back in vogue (e.g. Scala, Ruby, etc).  But, I just wonder whether these languages will be able to deliver the performance needed for the future &mldr;</p><p><em>Thoughts?</em></p><hr></div></div><script async src="https://www.googletagmanager.com/gtag/js?id=G-9MRLB1FVZX"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-9MRLB1FVZX",{anonymize_ip:!1})}</script></body></html>