<!doctype html><html lang=en><head><script async src="https://www.googletagmanager.com/gtag/js?id=G-9MRLB1FVZX"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-9MRLB1FVZX",{anonymize_ip:!1})}</script><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta property="og:title" content="Generating Verification Conditions for Whiley"><meta name=twitter:title content="Generating Verification Conditions for Whiley"><meta property="og:url" content="https://whileydave.com/2012/12/04/generating-verification-conditions-for-whiley/"><title>David J. Pearce
(Generating Verification Conditions for Whiley)</title><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css><link rel=stylesheet href=https://whileydave.com/css/page.css><link rel=stylesheet href=https://whileydave.com/css/menu.css><link rel=stylesheet href=https://whileydave.com/css/style.css><link rel=stylesheet href=https://whileydave.com/css/syntax.css></head><body><script>"use strict";function clearMenu(){var e,t,n=window.matchMedia("(max-width: 992px)");n.matches&&(e=document.getElementById("menu-content"),t=document.getElementById("menu"),e.style.display="none",t.style.filter="")}function toggleMenu(){var e,t,n=window.matchMedia("(max-width: 992px)");n.matches&&(e=document.getElementById("menu-content"),t=document.getElementById("menu"),e.style.display==="block"?(e.style.display="none",t.style.filter=""):(e.style.display="block",t.style.filter="brightness(0.8)"))}function toggleList(e){e.style.display="none";for(var t,o=e.parentNode,s=o.childNodes,n=0;n<s.length;++n)t=s[n],t.classList&&t.classList.contains("hidden")&&(t.style.display==="block"?t.style.display="none":t.style.display="block")}</script><header class=topbar><div class=topbar-header onclick=clearMenu()><div class=topbar-title>Dr. David J. Pearce</div><div class=topbar-subtitle></div></div><div class=topbar-social onclick=clearMenu()><a href=https://github.com/DavePearce><i class="fa fa-github" aria-hidden=true></i></a>
<a href=https://twitter.com/WhileyDave><i class="fa fa-twitter" aria-hidden=true></i></a>
<a href=https://www.youtube.com/user/redjamjar/><i class="fa fa-youtube-play" aria-hidden=true></i></a>
<a href=https://www.linkedin.com/in/david-pearce-8592647/><i class="fa fa-linkedin-square" aria-hidden=true></i></a></div><div class=topbar-menu><div id=menu onclick=toggleMenu()><div id=menu-icon><img src=https://whileydave.com/images/menu.png alt=Menu></div><div id=menu-content><a href=https://whileydave.com/blog/>Blog</a>
<a href=https://whileydave.com/projects/>Projects</a>
<a href=https://whileydave.com/publications/>Publications</a>
<a href=https://whileydave.com/talks/>Talks</a>
<a href=https://whileydave.com/>Home</a></div></div></div></header><div class=container onclick=clearMenu()><div class=content><h1 class=post-title>Generating Verification Conditions for Whiley</h1><div class=post-date>Tuesday, December
4th,
2012</div><hr><p>Probably the most interesting aspect of the <a href=http://whiley.org>Whiley</a> language is that it supports compile-time verification of <a href=http://en.wikipedia.org/wiki/Precondition>preconditions</a>, <a href=http://en.wikipedia.org/wiki/Postcondition>postconditions</a> and other<a href=http://en.wikipedia.org/wiki/Invariant_%28computer_science%29> invariants</a>.  There are two main aspects of how this works:</p><ul><li><p><strong>Generation of Verification Conditions (VCs) from the source code</strong>.  A verification condition is a logical expression which, if proved to be <a href=http://en.wikipedia.org/wiki/Satisfiability>satisfiable</a>, indicates an error in the program.</p></li><li><p><strong>Discharging verification conditions with the <a href=http://en.wikipedia.org/wiki/Automated_theorem_proving>Automated Theorem Prover (ATP)</a></strong>.  Here, the verification conditions are passed into the ATP which is responsible for deciding whether they are satisfiable or not.</p></li></ul><p>In this article, I&rsquo;ll be presenting the mechanism for generating verification conditions in the Whiley compiler, since it&rsquo;s a tricky process to get right.  Also, understanding this really helps to understand what exactly the automated theorem prover does.</p><h2 id=understanding-verification-conditions>Understanding Verification Conditions</h2><p>As a first example, consider this simple Whiley program:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl> <span class=kt>int</span> <span class=n>inc</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>)</span> <span class=k>requires</span> <span class=n>x</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=p>,</span> <span class=k>ensures</span> <span class=err>$</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>x</span> <span class=o>+</span> <span class=mi>1</span>
</span></span></code></pre></div><p>The function <code>inc</code> accepts a single parameter <code>x</code> where it is required that <code>x >= 0</code> on entry (a.k.a the <em>precondition</em>).  The <code>ensures</code> clause of the function mandates that the return value (given by <code>$</code>) must be greater than zero (a.k.a the <em>postcondition</em>). The Whiley compiler must verify the postcondition holds assuming the precondition does. To do this, it generates a verification condition at the <code>return</code> statement with which the ATP can decide whether an error exists or (i.e. whether or not the VC is satisfiable).</p><p>For the above example, the verification condition would be: <code>x >= 0 ==> x+1 &lt;= 0</code>.  Now this might seem odd if you had been expecting <code>x >= 0 && x+1 > 0</code>. To understand what&rsquo;s going on, it&rsquo;s useful to split the VC into: the <em>assertion</em> being checked; and, the <em>assumptions</em> we have.  For the above program, the assertion we&rsquo;re checking is that <code>$ > 0</code> which, if we substitute <code>$</code> for the actual returned value, gives us <code>x+1 > 0</code>. The assumptions we have are that <code>x >= 0</code>. To construct the VC, we combine the assumptions and assertion together using <code>==></code> (i.e. an implication) to give our final verification condition.</p><h2 id=basic-control-flow>Basic Control-Flow</h2><p>We&rsquo;ll now consider the process of generating verification conditions in more detail.  To begin with, we&rsquo;ll just consider basic control-flow (i.e. <code>if</code> statements) to get the idea.  Here&rsquo;s an example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl><span class=kt>int</span> <span class=n>abs</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>)</span> <span class=k>ensures</span> <span class=err>$</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>x</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=o>:</span>
</span></span><span class=line><span class=cl>         <span class=k>return</span> <span class=n>x</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=o>:</span>
</span></span><span class=line><span class=cl>         <span class=k>return</span> <span class=o>-</span><span class=n>x</span>
</span></span></code></pre></div><p>This example is nice because it only consists of an <code>if</code> statement along with a postcondition.  To verify this function the verifier performs a <em>path-sensitive</em> traversal, accumulating the verification condition as it goes.  In this case, it will first traverse down the true branch and then, separately, traverse down the false branch.  When doing this, it will assume the branch condition holds (resp. does not hold) as appropriate.  The following illustrates the process:</p><figure class=text-center><img width=600px src=/images/2012/Example-1b.png></figure><p>Here, we see the two execution paths that the verifier traverses along with the verification conditions generated for each.  Upon reaching a <code>return</code> statement, the verifier must check the postcondition holds.  This is done by first substituting <code>$</code> for the returned expression to generate the assertion and combining it with the <em>accumulated assumptions</em> to produce a verification condition.  The verifier then passes each of these to the automated theorem prover which attempts to prove they are unsatisfiable (and, hence, that the postcondition holds for all executions of that path).</p><p>Whilst the above example is very simple, it does illustrate the main points.  A slightly more complex example is the following:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl><span class=kt>int</span> <span class=n>abs</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=kt>int</span> <span class=n>y</span><span class=p>)</span> <span class=k>ensures</span> <span class=err>$</span> <span class=o>&gt;=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>x</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=n>x</span> <span class=o>=</span> <span class=o>-</span><span class=n>x</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>y</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=n>y</span> <span class=o>=</span> <span class=o>-</span><span class=n>y</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>x</span> <span class=o>+</span> <span class=n>y</span>
</span></span></code></pre></div><p>This takes the basic idea from before, but adds a second conditional. Since the generation process is done using a path-sensitive traversal, we end up with four distinct verification conditions to be checked. The following illustrates:</p><figure class=text-center><img width=600px src=/images/2012/Example-2b.png></figure><p>Here, we can see how the verification condition generator has propagated the effects of assignments through subsequent expressions to produce a verification condition expressed in terms of the function parameters.</p><h2 id=pre-post-conditions>Pre-/Post-Conditions</h2><p>A <a href=http://en.wikipedia.org/wiki/Precondition>precondition</a> is a set of constraints that are <em>assumed</em> to hold on entry to a function.  The idea is to <em>assert</em> (i.e. check with the automated theorem prover) that a function&rsquo;s precondition holds when it is called, and then assume it does within its body.  In contrast, a <a href=http://en.wikipedia.org/wiki/Postcondition>postcondition</a> is asserted at all <code>return</code> statements within the function body and then assumed at call sites.  To help make this distinction clear, it&rsquo;s useful to imagine the code has explicit <code>assume</code> and <code>assert</code> statements which capture this behaviour.  To illustrate, here&rsquo;s a (recursive) implementation of <a href=http://en.wikipedia.org/wiki/Euclidean_algorithm>Euclid&rsquo;s algorithm for find the Greatest Common Divisor</a>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl><span class=kt>int</span> <span class=n>gcd</span><span class=p>(</span><span class=kt>int</span> <span class=n>a</span><span class=p>,</span> <span class=kt>int</span> <span class=n>b</span><span class=p>)</span> <span class=k>requires</span> <span class=n>a</span> <span class=o>&gt;=</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=n>b</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=p>,</span> <span class=k>ensures</span> <span class=err>$</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>b</span> <span class=o>==</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>       <span class=k>return</span> <span class=n>a</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=o>:</span>
</span></span><span class=line><span class=cl>       <span class=k>return</span> <span class=n>gcd</span><span class=p>(</span><span class=n>b</span><span class=p>,</span> <span class=n>a</span> <span class=o>%</span> <span class=n>b</span><span class=p>)</span>
</span></span></code></pre></div><p>The above is provided as-is to the VC generator, which we now imagine inserts <code>assert</code> and <code>assume</code> statements (before proceeding to actually generate VCs) like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl><span class=kt>int</span> <span class=n>gcd</span><span class=p>(</span><span class=kt>int</span> <span class=n>a</span><span class=p>,</span> <span class=kt>int</span> <span class=n>b</span><span class=p>)</span> <span class=k>requires</span> <span class=n>a</span> <span class=o>&gt;=</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=n>b</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=p>,</span> <span class=k>ensures</span> <span class=err>$</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=c1>// generated from my precondition
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>assume</span> <span class=n>a</span> <span class=o>&gt;=</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=n>b</span> <span class=o>&gt;=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=n>b</span> <span class=o>==</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>       <span class=c1>// generated from my postcondition
</span></span></span><span class=line><span class=cl><span class=c1></span>       <span class=k>assert</span> <span class=n>a</span> <span class=o>&gt;=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>       <span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>       <span class=k>return</span> <span class=n>a</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=o>:</span>
</span></span><span class=line><span class=cl>       <span class=c1>// generated from call target&#39;s precondition
</span></span></span><span class=line><span class=cl><span class=c1></span>       <span class=k>assert</span> <span class=n>b</span> <span class=o>&gt;=</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>a</span> <span class=o>%</span> <span class=n>b</span><span class=p>)</span> <span class=o>&gt;=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>       <span class=c1>// generated from my postcondition
</span></span></span><span class=line><span class=cl><span class=c1></span>       <span class=k>assert</span> <span class=n>gcd</span><span class=p>(</span><span class=n>b</span><span class=p>,</span> <span class=n>a</span><span class=o>%</span><span class=n>b</span><span class=p>)</span> <span class=o>&gt;=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>       <span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>       <span class=k>return</span> <span class=n>gcd</span><span class=p>(</span><span class=n>b</span><span class=p>,</span> <span class=n>a</span> <span class=o>%</span> <span class=n>b</span><span class=p>)</span>
</span></span></code></pre></div><p>The VC generator then performs the path-sensitive traversal accumulating assumptions and, for each <code>assert</code>, invokes the automated theorem prover to check the condition holds.  The <code>assume</code> statements are assimilated into the set of assumptions when encountered <em>and do not cause the automated theorem prover to be invoked</em>.  The above example generates three verification conditions to be checked &mdash; i.e. one for each <code>assert</code> statement (in this case).  These are:</p><ul><li><p><code>a >= 0 && b >= 0 && b == 0 ==> a >= 0</code> &mdash; generated at Line 7 to check the postcondition of <code>gcd()</code> is met.</p></li><li><p><code>a >= 0 && b >= 0 && b != 0 ==> (b >= 0 && (a%b) >= 0)</code> &mdash; generated at Line 12 to check the precondition of <code>gcd(b,a%b)</code> is met at the call site.</p></li><li><p><code>a >= 0 && b >= 0 && b != 0 ==> gcd(b,a%b) >= 0</code> &mdash; generated at Line 14 to check the postcondition of <code>gcd()</code> is met</p></li></ul><p>A final point about postconditions is that the VC generator <em>must be careful to retain the original values of parameter variables</em>.  Consider this example, where the postcondition explicitly refers to the parameter <code>x</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl><span class=kt>int</span> <span class=n>increment</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>)</span> <span class=k>ensures</span> <span class=err>$</span> <span class=o>&gt;</span> <span class=n>x</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>x</span> <span class=o>=</span> <span class=n>x</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>x</span>
</span></span></code></pre></div><p>To see the problem, let us naively imagine that an <code>assert</code> statement is inserted (like before) as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl><span class=kt>int</span> <span class=n>increment</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>)</span> <span class=k>ensures</span> <span class=err>$</span> <span class=o>&gt;</span> <span class=n>x</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>x</span> <span class=o>=</span> <span class=n>x</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=c1>// generated naively from my postcondition
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>assert</span> <span class=n>x</span> <span class=o>&gt;</span> <span class=n>x</span>
</span></span><span class=line><span class=cl>    <span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=n>x</span>
</span></span></code></pre></div><p>We can clearly see that <code>x > x</code> can never be <code>true</code> &mdash; so something must be wrong! The problem is that, in generating the <code>assert</code> statement, we have not used the original value of <code>x</code> on entry. To correctly insert an imaginary <code>assert</code> statement, we must insert additional code as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl><span class=kt>int</span> <span class=n>increment</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>)</span> <span class=k>ensures</span> <span class=err>$</span> <span class=o>&gt;</span> <span class=n>x</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=err>$</span><span class=n>x</span> <span class=o>=</span> <span class=n>x</span>
</span></span><span class=line><span class=cl>    <span class=n>x</span> <span class=o>=</span> <span class=n>x</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=c1>// generated sensibly from my postcondition
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>assert</span> <span class=n>x</span> <span class=o>&gt;</span> <span class=err>$</span><span class=n>x</span>
</span></span><span class=line><span class=cl>    <span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=n>x</span>
</span></span></code></pre></div><p>Here, we&rsquo;ve inserted an imaginary &ldquo;shadow&rdquo; variable (i.e. <code>$x</code>) to store the value that <code>x</code> held on entry. The VC generated is then: <code>x+1 > x</code> which is evidently <code>true</code>.</p><h2 id=loop-invariants>Loop Invariants</h2><p>Dealing with loops is more challenging than the basic control-flow we&rsquo;ve seen above.  Consider this  example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl><span class=n>define</span> <span class=n>nat</span> <span class=n>as</span> <span class=kt>int</span> <span class=k>where</span> <span class=err>$</span> <span class=o>&gt;=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>nat</span> <span class=n>loop</span><span class=p>(</span><span class=n>nat</span> <span class=n>start</span><span class=p>,</span> <span class=n>nat</span> <span class=n>end</span><span class=p>)</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>i</span> <span class=o>=</span> <span class=n>start</span>
</span></span><span class=line><span class=cl>    <span class=n>r</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>end</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=n>r</span> <span class=o>=</span> <span class=n>r</span> <span class=o>+</span> <span class=n>i</span>
</span></span><span class=line><span class=cl>        <span class=n>i</span> <span class=o>=</span> <span class=n>i</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>r</span>
</span></span></code></pre></div><p>(<strong>note</strong>: this example uses Whiley&rsquo;s <code>define</code> statement to define a <em>constrained type</em>. These are treated the same as before and expand as pre-/post-conditions)</p><p>The problem with the above is that the VC generator cannot perform a true path-sensitive traversal of the function since it has an <em>infinite number of paths</em>. Therefore, it approximates this by traversing the loop just once. The user must provide a <em>loop invariant</em> to help the VC generator do this.  Adding a loop invariant to our above example looks like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl><span class=n>define</span> <span class=n>nat</span> <span class=n>as</span> <span class=kt>int</span> <span class=k>where</span> <span class=err>$</span> <span class=o>&gt;=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>nat</span> <span class=n>loop</span><span class=p>(</span><span class=n>nat</span> <span class=n>start</span><span class=p>,</span> <span class=n>nat</span> <span class=n>end</span><span class=p>)</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>i</span> <span class=o>=</span> <span class=n>start</span>
</span></span><span class=line><span class=cl>    <span class=n>r</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>end</span> <span class=k>where</span> <span class=n>r</span> <span class=o>&gt;=</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=n>i</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=n>r</span> <span class=o>=</span> <span class=n>r</span> <span class=o>+</span> <span class=n>i</span>
</span></span><span class=line><span class=cl>        <span class=n>i</span> <span class=o>=</span> <span class=n>i</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>r</span>
</span></span></code></pre></div><p>The VC generator must first assert the loop invariant holds on entry to the loop; then, it will assume it at the start of the loop body along with the loop condition and, from this, assert the loop invariant holds at the end of the body. We can expand the example to illustrate this by inserting <code>assert</code> and <code>assume</code> statements as before:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl><span class=n>define</span> <span class=n>nat</span> <span class=n>as</span> <span class=kt>int</span> <span class=k>where</span> <span class=err>$</span> <span class=o>&gt;=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>nat</span> <span class=n>loop</span><span class=p>(</span><span class=n>nat</span> <span class=n>start</span><span class=p>,</span> <span class=n>nat</span> <span class=n>end</span><span class=p>)</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>i</span> <span class=o>=</span> <span class=n>start</span>
</span></span><span class=line><span class=cl>    <span class=n>r</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=c1>// generated to check invariant holds on entry
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>assert</span> <span class=n>r</span> <span class=o>&gt;=</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=n>i</span> <span class=o>&gt;=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>while</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>end</span> <span class=k>where</span> <span class=n>r</span> <span class=o>&gt;=</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=n>i</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=c1>// generated from my loop invariant
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>assume</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>end</span> <span class=o>&amp;&amp;</span> <span class=n>r</span> <span class=o>&gt;=</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=n>i</span> <span class=o>&gt;=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>        <span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>r</span> <span class=o>=</span> <span class=n>r</span> <span class=o>+</span> <span class=n>i</span>
</span></span><span class=line><span class=cl>        <span class=n>i</span> <span class=o>=</span> <span class=n>i</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=c1>// generated to check invariant holds on next iteration
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>assert</span> <span class=n>r</span> <span class=o>&gt;=</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=n>i</span> <span class=o>&gt;=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>        <span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// generated from loop condition and invariant
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>assume</span> <span class=n>i</span> <span class=o>&gt;=</span> <span class=n>end</span> <span class=o>&amp;&amp;</span> <span class=n>r</span> <span class=o>&gt;=</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=n>i</span> <span class=o>&gt;=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=n>r</span>
</span></span></code></pre></div><p>In the above, there are two distinct paths that the VC generator will traverse: the first goes into the loop and stops at the end of the body; the second skips the loop body entirely.  The following illustrates these two paths:</p><figure class=text-center><img width=200px src=/images/2012/Example-3.png></figure><p>An important issue which is not clear above, is that the VC generator must <em>invalidate</em> variables which are modified in the loop body before each of the <code>assume</code> statements.  To understand this better, consider the following example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl><span class=kt>int</span> <span class=n>f</span><span class=p>(</span><span class=kt>int</span> <span class=n>end</span><span class=p>)</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=n>r</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=k>assert</span> <span class=n>r</span> <span class=o>&lt;</span> <span class=mi>10</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>end</span> <span class=k>where</span> <span class=n>r</span> <span class=o>&lt;</span> <span class=mi>10</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=k>assume</span> <span class=n>r</span> <span class=o>&lt;</span> <span class=mi>10</span>
</span></span><span class=line><span class=cl>        <span class=n>r</span> <span class=o>=</span> <span class=n>r</span> <span class=o>+</span> <span class=n>i</span>
</span></span><span class=line><span class=cl>        <span class=n>i</span> <span class=o>=</span> <span class=n>i</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=k>assert</span> <span class=n>r</span> <span class=o>&lt;</span> <span class=mi>10</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>r</span>
</span></span></code></pre></div><p>If the VC generator does not invalidate the variables <code>i</code> and <code>r</code> on entry to the loop, then it will retain the initial values assigned to those variables for the single iteration of the loop it considers. When it reaches the end of the loop body, the value retained for <code>r</code> will be <code>0</code> and the assertion will trivially hold <em>despite the fact that it is invalid</em>. The invalidation of a variable is achieved by assigning it a <em>fresh variable</em> (i.e one which is not used elsewhere in the program code, often referred to as a <em>skolem constant</em>).</p><p>Consider the path taken by the VC generator through the loop body. Let&rsquo;s assume variable <code>r</code> is invalidated on entry to the loop by assigning the skolem <code>$r0</code> and variable <code>i</code> is invalidated by assigning <code>$i0</code>. Then, the resulting verification condition at the end of the loop body would be: <code>($r0 &lt; 10 && $i0 &lt; end) ==> $r0+$i0 &lt; 10</code>. Since this formula has many invalid assignments (e.g. <code>$r0 == 9 && $i0 == 1 && end == 20</code>), the automated theorem prover will now correctly identify the error present in the code.</p><h2 id=conclusion>Conclusion</h2><p>Hopefully, this article helped you understand what verification conditions are, and how they are generated.  There is, unfortunately, quite a lot about generating verification conditions for modern languages (e.g. Whiley) that I&rsquo;ve left out in order to keep the article focused.  In the future, I&rsquo;ll expand on the more advanced issues and give insight into how things work inside the Whiley compiler.  For now, I&rsquo;ve compiled a list of relevant papers which should provide useful additional background.</p><h2 id=further-reading>Further Reading</h2><p>There are quite a few interesting papers and articles on the subject of generate verification conditions.  Here&rsquo;s a selection of those I&rsquo;ve found interesting:</p><ul><li><p><strong>Verification conditions for source-level imperative programs</strong>, Maria Joa ̃o Frade and Jorge Sousa Pinto. <em>Computer Science Review</em>, 5(3):252–277, 2011. (<a href=http://repositorium.sdum.uminho.pt/bitstream/1822/12547/1/verification-conditions-revised.pdf>PDF</a> / <a href=http://dx.doi.org/10.1016/j.cosrev.2011.02.002>DOI</a>)</p></li><li><p><strong>Boogie: A Modular Reusable Veriﬁer for Object-Oriented Programs</strong>, Mike Barnett, Bor-Yuh Evan Chang, Robert DeLine,Bart Jacobs, and K. Rustan M. Leino.  In <em>Proceedings of FMCO</em>, 2005. (<a href=http://research.microsoft.com/en-us/um/people/leino/papers/krml160.pdf>PDF</a> / <a href=http://dx.doi.org/10.1007/11804192_17>DOI</a>)</p></li><li><p><strong>Avoiding exponential explosion: generating compact verification conditions,</strong> Cormac Flanagan and James Saxe. In <em>Proceedings of POPL</em>, 2001.  (<a href=http://users.soe.ucsc.edu/~cormac/papers/popl01.pdf>PDF</a> / <a href=http://dx.doi.org/10.1145/360204.360220>DOI</a>)</p></li><li><p><strong>Efficient Weakest Preconditions</strong>, Rustan Leino.  In <em>Information Processing Letters</em>, 2005.  (<a href=http://research.microsoft.com/pubs/70052/tr-2004-34.pdf>PDF</a> / <a href=http://dx.doi.org/10.1016/j.ipl.2004.10.015>DOI</a>)</p></li><li><p><strong>Weakest Precondition for Unstructured Programs</strong>, Mike Barnett and Rustan Leino. In <em>Proceedings of PASTE</em>, 2005. (<a href=http://research.microsoft.com/en-us/um/people/leino/papers/krml157.pdf>PDF</a> / <a href=http://dx.doi.org/10.1145/1108792.1108813>DOI</a>)</p></li><li><p><strong>Generating Error Traces from Verification Condition Counterexamples</strong>, Rustan Leino, Todd Millstein and James Saxe.  In <em>Formal Methods for Components and Objects</em>, 2005.  (<a href=http://research.microsoft.com/en-us/um/people/leino/papers/krml120.pdf>PDF</a> / <a href=http://dx.doi.org/10.1016/j.scico.2004.05.016>DOI</a>)</p></li><li><p><strong>Proving SPARK Verification Conditions with SMT Solvers</strong>, Paul B. Jackson and Grant Olney, Technical Report, 2011. (<a href=http://homepages.inf.ed.ac.uk/pbj/papers/vct-dec09-draft.pdf>PDF</a>)</p></li></ul><hr></div></div></body></html>