<!doctype html><html lang=en><head><script async src="https://www.googletagmanager.com/gtag/js?id=G-9MRLB1FVZX"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-9MRLB1FVZX",{anonymize_ip:!1})}</script><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta property="og:title" content="Flow Typing for References in Whiley"><meta name=twitter:title content="Flow Typing for References in Whiley"><meta property="og:url" content="https://whileydave.com/2012/06/11/flow-typing-for-references-in-whiley/"><title>David J. Pearce
(Flow Typing for References in Whiley)</title><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css><link rel=stylesheet href=https://whileydave.com/css/page.css><link rel=stylesheet href=https://whileydave.com/css/menu.css><link rel=stylesheet href=https://whileydave.com/css/style.css><link rel=stylesheet href=https://whileydave.com/css/syntax.css></head><body><script>"use strict";function clearMenu(){var e,t,n=window.matchMedia("(max-width: 992px)");n.matches&&(e=document.getElementById("menu-content"),t=document.getElementById("menu"),e.style.display="none",t.style.filter="")}function toggleMenu(){var e,t,n=window.matchMedia("(max-width: 992px)");n.matches&&(e=document.getElementById("menu-content"),t=document.getElementById("menu"),e.style.display==="block"?(e.style.display="none",t.style.filter=""):(e.style.display="block",t.style.filter="brightness(0.8)"))}function toggleList(e){e.style.display="none";for(var t,o=e.parentNode,s=o.childNodes,n=0;n<s.length;++n)t=s[n],t.classList&&t.classList.contains("hidden")&&(t.style.display==="block"?t.style.display="none":t.style.display="block")}</script><header class=topbar><div class=topbar-header onclick=clearMenu()><div class=topbar-title>Dr. David J. Pearce</div><div class=topbar-subtitle></div></div><div class=topbar-social onclick=clearMenu()><a href=https://github.com/DavePearce><i class="fa fa-github" aria-hidden=true></i></a>
<a href=https://twitter.com/WhileyDave><i class="fa fa-twitter" aria-hidden=true></i></a>
<a href=https://www.youtube.com/user/redjamjar/><i class="fa fa-youtube-play" aria-hidden=true></i></a>
<a href=https://www.linkedin.com/in/david-pearce-8592647/><i class="fa fa-linkedin-square" aria-hidden=true></i></a></div><div class=topbar-menu><div id=menu onclick=toggleMenu()><div id=menu-icon><img src=https://whileydave.com/images/menu.png alt=Menu></div><div id=menu-content><a href=https://whileydave.com/blog/>Blog</a>
<a href=https://whileydave.com/projects/>Projects</a>
<a href=https://whileydave.com/publications/>Publications</a>
<a href=https://whileydave.com/talks/>Talks</a>
<a href=https://whileydave.com/>Home</a></div></div></div></header><div class=container onclick=clearMenu()><div class=content><h1 class=post-title>Flow Typing for References in Whiley</h1><div class=post-date>Monday, June
11th,
2012</div><hr><p>The Whiley language splits into a fully functional &ldquo;core&rdquo; and an imperative &ldquo;outer layer&rdquo;.  References and objects do not exist within the functional core.  However, they can exist within the imperative outer layer and are necessary for supporting state and other side-effecting computation.  Here&rsquo;s a simple example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl><span class=n>define</span> <span class=n>Buffer</span> <span class=n>as</span> <span class=n>ref</span> <span class=p>{</span> <span class=p>[</span><span class=kt>int</span><span class=p>]</span> <span class=n>items</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Buffer</span> <span class=o>::</span><span class=n>Buffer</span><span class=p>()</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=k>new</span> <span class=p>{</span><span class=n>items</span><span class=o>:</span> <span class=p>[]}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>Buffer</span><span class=o>::</span><span class=n>read</span><span class=p>()</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>item</span> <span class=o>=</span> <span class=n>this</span><span class=o>-&gt;</span><span class=n>items</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=c1>// get head
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>this</span><span class=o>-&gt;</span><span class=n>items</span> <span class=o>=</span> <span class=n>this</span><span class=o>-&gt;</span><span class=n>items</span><span class=p>[</span><span class=mi>1</span><span class=p>..]</span> <span class=c1>// strip head
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=n>item</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>Buffer</span><span class=o>::</span><span class=n>write</span><span class=p>(</span><span class=kt>int</span> <span class=n>item</span><span class=p>)</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>this</span><span class=o>-&gt;</span><span class=n>items</span> <span class=o>=</span> <span class=n>this</span><span class=o>-&gt;</span><span class=n>items</span> <span class=o>+</span> <span class=p>[</span><span class=n>item</span><span class=p>]</span>
</span></span></code></pre></div><p>What we see here is the definition of a simple <code>Buffer</code> with a default constructor <code>::Buffer() </code>and two methods <code>read()</code> and <code>write(int)</code>. We can tell that <code>Buffer</code> is a reference type because of the <code>ref</code> keyword. Instances of <code>Buffer</code> are objects in the true sense (i.e. as in Java, C++, C#, etc), and can be aliased from multiple locations in the heap.</p><h2 id=flow-typing-for-general-references>Flow Typing for General References</h2><p>Since objects can be aliased, we must be treat them differently from normal data values in Whiley.  To understand why,  consider this example involving a record value:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl><span class=n>define</span> <span class=n>IntPoint</span> <span class=n>as</span> <span class=p>{</span><span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=kt>int</span> <span class=n>y</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>define</span> <span class=n>RealPoint</span> <span class=n>as</span> <span class=p>{</span><span class=n>real</span> <span class=n>x</span><span class=p>,</span> <span class=n>real</span> <span class=n>y</span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>IntPoint</span> <span class=n>floor</span><span class=p>(</span><span class=n>RealPoint</span> <span class=n>p</span><span class=p>)</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span><span class=p>.</span><span class=n>x</span> <span class=o>=</span> <span class=n>Math</span><span class=p>.</span><span class=n>floor</span><span class=p>(</span><span class=n>p</span><span class=p>.</span><span class=n>x</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span><span class=p>.</span><span class=n>y</span> <span class=o>=</span> <span class=n>Math</span><span class=p>.</span><span class=n>floor</span><span class=p>(</span><span class=n>p</span><span class=p>.</span><span class=n>y</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>p</span> <span class=c1>// OK
</span></span></span></code></pre></div><p>The above example is type safe because variable <code>p</code> is retyped from <code>{real x, real y}</code> to <code>{int x, int y}</code> by the two field assignments.</p><p>Now, let&rsquo;s consider the same example but this time using <em>references to records</em>, rather than just records:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl><span class=n>define</span> <span class=n>IntPoint</span> <span class=n>as</span> <span class=n>ref</span> <span class=p>{</span><span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=kt>int</span> <span class=n>y</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>define</span> <span class=n>RealPoint</span> <span class=n>as</span> <span class=n>ref</span> <span class=p>{</span><span class=n>real</span> <span class=n>x</span><span class=p>,</span> <span class=n>real</span> <span class=n>y</span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>IntPoint</span> <span class=o>::</span><span class=n>floor</span><span class=p>(</span><span class=n>RealPoint</span> <span class=n>p</span><span class=p>)</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span><span class=o>-&gt;</span><span class=n>x</span> <span class=o>=</span> <span class=n>Math</span><span class=p>.</span><span class=n>floor</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>x</span><span class=p>)</span>  <span class=c1>// NOT OK
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>p</span><span class=o>-&gt;</span><span class=n>y</span> <span class=o>=</span> <span class=n>Math</span><span class=p>.</span><span class=n>floor</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>y</span><span class=p>)</span> <span class=c1>// NOT OK
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=n>p</span>
</span></span></code></pre></div><p>Notice that <code>floor(RealPoint)</code> has become <code>::floor(RealPoint)</code> &mdash; signalling that it is no longer a <em>function</em> in the functional core, but a <em>method</em> in the imperative outer layer. Also, notice that we must use the <code>p->x</code> notation to access field <code>x</code> of <code>p</code> which (like C/C++) is syntactic sugar for <code>(*p).x</code>.</p><p>The problem is, our example involving references to records will not compile because it is unsafe. This stems from the difference between values (which cannot be aliased) and objects (which can) in Whiley. To understand why, consider this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl><span class=n>real</span> <span class=o>::</span><span class=n>f</span><span class=p>(</span><span class=n>RealPoint</span> <span class=n>p</span><span class=p>)</span><span class=o>:</span>
</span></span><span class=line><span class=cl>   <span class=n>q</span> <span class=o>=</span> <span class=n>floor</span><span class=p>(</span><span class=n>p</span><span class=p>)</span>
</span></span><span class=line><span class=cl>   <span class=k>return</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>x</span>
</span></span></code></pre></div><p>Suppose that <code>::floor(RealPoint)</code> was consider safe. Then, the above code would produce a runtime type error because <code>p->x</code> would give an <code>int</code> value when the runtime was expecting a <code>real</code> value (since these are distinct values in Whiley). The problem is that the method <code>::f(RealPoint)</code> expects <code>p</code> to have type <code>RealPoint</code> after <code>::floor(RealPoint)</code> is called but, in fact, it would have type <code>IntPoint</code> [if we allowed <code>::floor(RealPoint)</code> to compile].</p><p>In a nutshell, the conclusion here is that we cannot retype general objects in the same way that we can for the value types (such as records, lists, etc).</p><h2 id=flow-typing-for-unique-references>Flow Typing for Unique References</h2><p>In fact, there are situations when we can safely retype objects!  For example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl><span class=n>IntPoint</span> <span class=o>::</span><span class=n>create</span><span class=p>()</span><span class=o>:</span>
</span></span><span class=line><span class=cl>   <span class=n>p</span> <span class=o>=</span> <span class=k>new</span> <span class=p>{</span><span class=n>x</span><span class=o>:</span><span class=mi>1</span><span class=p>.</span><span class=mi>23</span><span class=p>,</span> <span class=n>y</span><span class=o>:</span><span class=mi>2</span><span class=p>.</span><span class=mi>34</span><span class=p>}</span>
</span></span><span class=line><span class=cl>   <span class=n>p</span><span class=o>-&gt;</span><span class=n>x</span> <span class=o>=</span> <span class=n>Math</span><span class=p>.</span><span class=n>floor</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>x</span><span class=p>)</span>
</span></span><span class=line><span class=cl>   <span class=n>p</span><span class=o>-&gt;</span><span class=n>y</span> <span class=o>=</span> <span class=n>Math</span><span class=p>.</span><span class=n>floor</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>y</span><span class=p>)</span>
</span></span><span class=line><span class=cl>   <span class=k>return</span> <span class=n>p</span>
</span></span></code></pre></div><p>This example is rather artificial, but it makes the point. The above code always works correctly because we know that <code>p</code> is a <em>unique reference</em>. By unique reference, I mean that the variable <code>p</code> holds the only reference to that object and no one else does (i.e. the object is not aliased). In such case, we could safely retype <code>p</code> if the system contained such a notion of unique reference (which, at the moment, the Whiley compiler does not). Whilst this idea is a little speculative at this stage, there has been quite a bit of work done on this in the academic literature.  Here a few examples:</p><ul><li><p><strong>Alias Annotations for Program Understanding</strong>, Jonathan Aldrich Valentin Kostadinov Craig Chambers.  In <em>Proceedings of the ACM Conference on Object-Oriented Programming Systems, Languages, and Applications (OOPSLA)</em>, 2002.  [ <a href=http://dx.doi.org/10.1145/583854.582448>ACM Link</a> / <a href=http://archjava.fluid.cs.cmu.edu/papers/oopsla02.pdf>PDF</a> ]</p></li><li><p><strong>External Uniqueness is Unique Enough</strong>, Dave Clarke and Tobias Wrigstad.  In <em>Proceedings of the European Conference on Object-Oriented Programming (ECOOP)</em>, 2003. [ <a href=http://www.springerlink.com/content/qu8hp60a3qe9f4k0/>SpringerLink</a> / <a href=https://lirias.kuleuven.be/bitstream/123456789/203436/1/euiue.pdf>PDF</a> ]</p></li></ul><p>Anyway, hopefully that is some food for thought &mldr;</p><hr></div></div></body></html>