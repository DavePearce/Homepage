<!doctype html><html lang=en><head><script async src="https://www.googletagmanager.com/gtag/js?id=G-9MRLB1FVZX"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-9MRLB1FVZX",{anonymize_ip:!1})}</script><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta property="og:title" content="Example: Sum Over a Positive List"><meta name=twitter:title content="Example: Sum Over a Positive List"><meta property="og:url" content="https://whileydave.com/2010/06/30/example-sum-over-a-positive-list/"><title>David J. Pearce
(Example: Sum Over a Positive List)</title><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css><link rel=stylesheet href=https://whileydave.com/css/page.css><link rel=stylesheet href=https://whileydave.com/css/menu.css><link rel=stylesheet href=https://whileydave.com/css/style.css><link rel=stylesheet href=https://whileydave.com/css/syntax.css></head><body><script>"use strict";function clearMenu(){var e,t,n=window.matchMedia("(max-width: 992px)");n.matches&&(e=document.getElementById("menu-content"),t=document.getElementById("menu"),e.style.display="none",t.style.filter="")}function toggleMenu(){var e,t,n=window.matchMedia("(max-width: 992px)");n.matches&&(e=document.getElementById("menu-content"),t=document.getElementById("menu"),e.style.display==="block"?(e.style.display="none",t.style.filter=""):(e.style.display="block",t.style.filter="brightness(0.8)"))}function toggleList(e){e.style.display="none";for(var t,o=e.parentNode,s=o.childNodes,n=0;n<s.length;++n)t=s[n],t.classList&&t.classList.contains("hidden")&&(t.style.display==="block"?t.style.display="none":t.style.display="block")}</script><header class=topbar><div class=topbar-header onclick=clearMenu()><div class=topbar-title>Dr. David J. Pearce</div><div class=topbar-subtitle></div></div><div class=topbar-social onclick=clearMenu()><a href=https://github.com/DavePearce><i class="fa fa-github" aria-hidden=true></i></a>
<a href=https://twitter.com/WhileyDave><i class="fa fa-twitter" aria-hidden=true></i></a>
<a href=https://www.youtube.com/user/redjamjar/><i class="fa fa-youtube-play" aria-hidden=true></i></a>
<a href=https://www.linkedin.com/in/david-pearce-8592647/><i class="fa fa-linkedin-square" aria-hidden=true></i></a></div><div class=topbar-menu><div id=menu onclick=toggleMenu()><div id=menu-icon><img src=https://whileydave.com/images/menu.png alt=Menu></div><div id=menu-content><a href=https://whileydave.com/blog/>Blog</a>
<a href=https://whileydave.com/projects/>Projects</a>
<a href=https://whileydave.com/publications/>Publications</a>
<a href=https://whileydave.com/talks/>Talks</a>
<a href=https://whileydave.com/>Home</a></div></div></div></header><div class=container onclick=clearMenu()><div class=content><h1 class=post-title>Example: Sum Over a Positive List</h1><div class=post-date>Wednesday, June
30th,
2010</div><hr><p>So, here&rsquo;s the first Whiley programming example.  Obviously, it&rsquo;s pretty simple as Whiley is not quite ready for big code just yet.  The idea is to compute the sum of a positive list which, of course, will give you a positive number.  We want Whiley to realise this and correct us if there&rsquo;s a mistake.  So, first, the definition of a positive list:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl><span class=n>define</span> <span class=n>poslist</span> <span class=n>as</span> <span class=p>[</span><span class=kt>int</span><span class=p>]</span> <span class=k>where</span> <span class=k>no</span> <span class=p>{</span><span class=n>x</span> <span class=k>in</span> <span class=err>$</span> <span class=o>|</span> <span class=n>x</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>}</span>
</span></span></code></pre></div><p>This is fairly straight-forward.  We require a list of integers which contains no element that is below zero.  Now, the main recursive method:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl><span class=kt>int</span> <span class=n>sum</span><span class=p>(</span><span class=n>poslist</span> <span class=n>ls</span><span class=p>,</span> <span class=kt>int</span> <span class=n>i</span><span class=p>)</span> <span class=k>requires</span> <span class=n>i</span> <span class=o>&gt;=</span><span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=o>|</span><span class=n>ls</span><span class=o>|</span><span class=p>,</span> <span class=k>ensures</span> <span class=err>$</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=o>:</span>
</span></span><span class=line><span class=cl>   <span class=k>if</span><span class=p>(</span><span class=n>i</span> <span class=o>==</span> <span class=o>|</span><span class=n>ls</span><span class=o>|</span><span class=p>)</span><span class=o>:</span>
</span></span><span class=line><span class=cl>     <span class=k>return</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>   <span class=k>else</span><span class=o>:</span>
</span></span><span class=line><span class=cl>     <span class=k>return</span> <span class=n>ls</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>+</span> <span class=n>sum</span><span class=p>(</span><span class=n>ls</span><span class=p>,</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span>
</span></span></code></pre></div><p>This one is a bit more involved.  Firstly, i&rsquo;m iterating through the list using recursion because Whiley doesn&rsquo;t support a while loop yet (see the <a href=http://whiley.org/docs/faq/>FAQ</a>).  Second, we can see that the iterator <code>i</code> is required to be <code>>= 0</code> and <code>&lt;=</code> the length of the list on entry.  This may seem slightly strange, since we don&rsquo;t want to access a list past it&rsquo;s bounds &mldr; however, I use the <code>i==|ls|</code> as the base case which just returns <code>0</code>.  Furthermore, I want to support summing over an empty list.</p><p>The key is that the code states explicitly that the return value <code>$</code> must be <code>>= 0</code> (which we know since we&rsquo;re summing over a positive list).  The beauty of it is that Whiley knows this too, and will pass this code as being correct.  Make any changes, however, such as using a normal list instead of a <code>poslist</code>, and it will give you a syntax error.</p><p><em>So, how does it work?</em> Well, Whiley begins by generating 4 check statements which are inserted before the final return like so:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl> <span class=p>...</span>
</span></span><span class=line><span class=cl> <span class=n>check</span> <span class=n>i</span><span class=o>&gt;=</span><span class=mi>0</span><span class=p>,</span> <span class=err>&#34;</span><span class=n>list</span> <span class=n>index</span> <span class=n>might</span> <span class=n>be</span> <span class=n>negative</span><span class=err>&#34;</span>
</span></span><span class=line><span class=cl> <span class=n>check</span> <span class=n>i</span><span class=o>&lt;|</span><span class=n>ls</span><span class=o>|</span><span class=p>,</span> <span class=err>&#34;</span><span class=n>list</span> <span class=n>index</span> <span class=n>might</span> <span class=n>exceed</span> <span class=n>length</span><span class=err>&#34;</span>
</span></span><span class=line><span class=cl> <span class=n>check</span> <span class=p>((</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=o>&gt;=</span><span class=mi>0</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=o>&lt;=|</span><span class=n>ls</span><span class=o>|</span><span class=p>))</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=k>no</span> <span class=p>{</span><span class=n>x</span> <span class=k>in</span> <span class=n>ls</span> <span class=o>|</span> <span class=n>x</span><span class=o>&lt;</span><span class=mi>0</span><span class=p>}),</span> <span class=err>&#34;</span><span class=kd>function</span> <span class=n>precondition</span> <span class=n>not</span> <span class=n>satisfied</span><span class=err>&#34;</span>
</span></span><span class=line><span class=cl> <span class=n>check</span> <span class=n>ls</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>+</span><span class=n>sum</span><span class=p>(</span><span class=n>ls</span><span class=p>,</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span><span class=o>&gt;=</span><span class=mi>0</span><span class=p>,</span> <span class=err>&#34;</span><span class=kd>function</span> <span class=n>postcondition</span> <span class=n>not</span> <span class=n>satisfied</span><span class=err>&#34;</span>
</span></span><span class=line><span class=cl> <span class=k>return</span> <span class=n>ls</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>+</span> <span class=n>sum</span><span class=p>(</span><span class=n>ls</span><span class=p>,</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span>
</span></span></code></pre></div><p>We can see that each check is associated with a message, which will be reported if the check fails at compile time.  For each check, Whiley generates a <em>Verification Condition (VC)</em> which is an encoding of the check that takes into account what is known from the context.  For example, the verification condition for the first check is:</p><pre tabindex=0><code> [int] ls; int i;
 i!=|ls| &amp;&amp; 0&lt;=i &amp;&amp; i&lt;=|ls| &amp;&amp; all [x : ls | 0 &lt;= ls[x]] &amp;&amp; i&lt;0
</code></pre><p>Here, we see  <code>i!=|ls|</code> (gleaned from if condition), <code>0&lt;=i && i&lt;|ls|</code> (gleaned from the pre-condition) and <code>all [x : ls | 0 &lt;= ls[x]]</code> (also gleaned from pre-condition).  The final part, <code>i&lt;0</code> comes from the check condition itself, but is the inverted version of it.  The reason it is inverted is that we want to check for <em>unsatisfiability</em>; that is, if the verification is unsatisfiable (i.e. no assignment of values will make it true) then that implies there is no possible value which could have invalidated the check condition.  This is then passed to the theorem prover which attempts to decide whether it&rsquo;s<a href=http://en.wikipedia.org/wiki/Satisfiability_Modulo_Theories> unsatisfiable or not</a>.</p><p>The above verification condition is easy for the theorem prover to prove as unsatisfiable since it contains <code>i&lt;=0 && i&lt;0</code> &mldr; which is clearly impossible.  Just for a taste, here&rsquo;s the VC for the final check:</p><pre tabindex=0><code>[int] ls; int i,$; int([int],int) &amp;sum;
i!=|ls| &amp;&amp; 0&lt;=i &amp;&amp; i&lt;=|ls| &amp;&amp; all [x : ls | 0 &lt;= ls[x]] &amp;&amp;
 0&lt;=sum(ls,i+1) &amp;&amp; 0&gt;ls[i]+sum(ls,i+1)
</code></pre><p>This one is more involved and, to be honest, i&rsquo;m not going to delve into the details.  If you&rsquo;re interested in learning more about this, then checkout the <a href=https://github.com/Whiley/WhileyTheoremProver/>Whiley Theorem Prover</a>.</p><hr></div></div></body></html>