<!doctype html><html lang=en><head><script async src="https://www.googletagmanager.com/gtag/js?id=G-9MRLB1FVZX"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-9MRLB1FVZX",{anonymize_ip:!1})}</script><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta property="og:title" content="The Trouble with Quantifier Instantiation in an SMT Solver? Triggers."><meta name=twitter:title content="The Trouble with Quantifier Instantiation in an SMT Solver? Triggers."><meta property="og:url" content="https://whileydave.com/2010/06/22/the-trouble-with-quantifier-instantiation-in-an-smt-solver-triggers./"><title>David J. Pearce
(The Trouble with Quantifier Instantiation in an SMT Solver? Triggers.)</title><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css><link rel=stylesheet href=https://whileydave.com/css/page.css><link rel=stylesheet href=https://whileydave.com/css/menu.css><link rel=stylesheet href=https://whileydave.com/css/style.css><link rel=stylesheet href=https://whileydave.com/css/syntax.css></head><body><script>"use strict";function clearMenu(){var e,t,n=window.matchMedia("(max-width: 992px)");n.matches&&(e=document.getElementById("menu-content"),t=document.getElementById("menu"),e.style.display="none",t.style.filter="")}function toggleMenu(){var e,t,n=window.matchMedia("(max-width: 992px)");n.matches&&(e=document.getElementById("menu-content"),t=document.getElementById("menu"),e.style.display==="block"?(e.style.display="none",t.style.filter=""):(e.style.display="block",t.style.filter="brightness(0.8)"))}function toggleList(e){e.style.display="none";for(var t,o=e.parentNode,s=o.childNodes,n=0;n<s.length;++n)t=s[n],t.classList&&t.classList.contains("hidden")&&(t.style.display==="block"?t.style.display="none":t.style.display="block")}</script><header class=topbar><div class=topbar-header onclick=clearMenu()><div class=topbar-title>Dr. David J. Pearce</div><div class=topbar-subtitle></div></div><div class=topbar-social onclick=clearMenu()><a href=https://github.com/DavePearce><i class="fa fa-github" aria-hidden=true></i></a>
<a href=https://twitter.com/WhileyDave><i class="fa fa-twitter" aria-hidden=true></i></a>
<a href=https://www.youtube.com/user/redjamjar/><i class="fa fa-youtube-play" aria-hidden=true></i></a>
<a href=https://www.linkedin.com/in/david-pearce-8592647/><i class="fa fa-linkedin-square" aria-hidden=true></i></a></div><div class=topbar-menu><div id=menu onclick=toggleMenu()><div id=menu-icon><img src=https://whileydave.com/images/menu.png alt=Menu></div><div id=menu-content><a href=https://whileydave.com/blog/>Blog</a>
<a href=https://whileydave.com/projects/>Projects</a>
<a href=https://whileydave.com/publications/>Publications</a>
<a href=https://whileydave.com/talks/>Talks</a>
<a href=https://whileydave.com/>Home</a></div></div></div></header><div class=container onclick=clearMenu()><div class=content><h1 class=post-title>The Trouble with Quantifier Instantiation in an SMT Solver? Triggers.</h1><div class=post-date>Tuesday, June
22nd,
2010</div><hr><p>So, i&rsquo;ve been recently working through the quantifier instantiation mechanism in <a href=http://whiley.org/wyone>wyone</a>.  This is a tricky, yet important topic.  There&rsquo;s been a lot of interesting research in this area as well (see further reading below for some examples), although I found the papers often hard work at times.</p><p>Anyway, the basic idea is pretty straightforward.  Let&rsquo;s imagine we&rsquo;re testing the following formula for <a href=http://en.wikipedia.org/wiki/Satisfiability_Modulo_Theories>satisfiability</a>:</p><pre tabindex=0><code>in(x,xs) &amp;&amp; x &lt; 0 &amp;&amp; forall Y [ in(Y,xs) ==&gt; Y &gt;= 0 ]
</code></pre><p>In this formula, the <code>forall</code> expression enforces a constraint that every element in the &ldquo;collection&rdquo; <code>xs</code> must be positive.  On the other hand, we have a variable <code>x</code> which is known to be in <code>xs</code>, and is negative.  Therefore, we can easily see that there is a contradiction here.  <em>But, how does the SMT solver show this?</em> The answer is through <a href=http://en.wikipedia.org/wiki/Universal_instantiation>quantifier instantiation</a>.  To do this, it constructs a binding from quantified variables to ground literals (or possibly ground formulas).  Once a suitable binding is found, it instantiates the quantifier.  For our example, a good binding would be <code>[Y->x]</code> and using this to instantiate our quantifier gives:</p><pre tabindex=0><code>in(x,xs) &amp;&amp; x &lt; 0 &amp;&amp; forall Y [ in(Y,xs) ==&gt; Y &gt;= 0 ]
=&gt; &amp;&amp; in(x,xs) ==&gt; x &gt;= 0
=&gt; &amp;&amp; x &gt;= 0
</code></pre><p>At this point, the arithmetic theory of the SMT solver will kick in and immediately derive a contradiction from <code>x&lt;0 && x>=0</code>.</p><p>The difficulty in this process stems from the problem of finding a good binding.  A lot of work in this area has been done, particularly with systems like Prolog which use <a href=http://en.wikipedia.org/wiki/Unification_%28computing%29>unification</a>.  Modern SMT solvers usually rely on so-called <em>triggers</em> to generate the binding.  A trigger is essentially just a pattern match which generates bindings.  In our example, you could trigger on <code>in(X,Y)</code> literals:  when you saw one in a quantified formula, you&rsquo;d try and generate a binding by looking at all existing ground instances of it. In our example, that would lead to unifying <code>in(x,xs)</code> against <code>in(Y,xs)</code> and that would generate the required binding.</p><p>This approach to quantification has numerous drawbacks.  First and foremost, it can be very expensive to determine a binding as this requires a potentially exponential search through all possible trigger matches.  Secondly, the problem arises when the SMT solver doesn&rsquo;t use the exact trigger you need to get the contradiction.  This is particularly likely to happen when the formula involves triggering on arithmetic expressions.  For example:</p><pre tabindex=0><code>f(x-1,x) &amp;&amp; !g(x-1,x) &amp;&amp; forall X,Y [ f(X,X+Y) ==&gt; g(X,X+Y) ]
</code></pre><p>(Ok, this is a slightly artificial example, but it makes the point)</p><p>The challenge here is to obtain the binding <code>[X->x-1, Y->1]</code> which will lead us to the contradiction.  Certainly, this is possible &mldr; but the problem of unification is suddenly much harder as we must be prepared to make complex expression rewrites during unification.  At some point, the SMT solver may give up searching for matches, and you&rsquo;ll be forced to write formulas in a way that helps it find them.</p><p>Anyway, that&rsquo;s all for now.  But, I&rsquo;d be quite interested to know how far existing solvers like Z3 or Simplify go in this department &mldr;</p><h2 id=further-reading>Further Reading</h2><ul><li><p><strong>E-matching for Fun and Profit</strong>, <a href="http://portal.acm.org/author_page.cfm?id=81367593542&coll=GUIDE&dl=GUIDE&trk=0&CFID=94491488&CFTOKEN=50134837">Michał Moskal</a>, <a href="http://portal.acm.org/author_page.cfm?id=81367596192&coll=GUIDE&dl=GUIDE&trk=0&CFID=94491488&CFTOKEN=50134837">Jakub Łopuszańsk</a>i, Joseph R. Kiniry. <em>Electronic Notes in Theoretical Computer Science (ENTCS)</em>, 198(2): 19-35, 2008. [<a href=http://kind.ucd.ie/documents/published/MoskalKiniry07.pdf>PDF</a>]</p></li><li><p><strong>Efficient E-matching for SMT Solvers</strong>, Leonardo de Moura and Nikolaj Bjorner. In <em>Proceedings of the 21st international conference on Automated Deduction</em>, LNCS 4603:183-198, 2007. [<a href="http://citeseerx.ist.psu.edu/icons/pdf.gif;jsessionid=B43237574994909B06DFAC7293CE8438">PDF</a>]</p></li><li><p><strong>Programming with triggers</strong>, <a href="http://portal.acm.org/author_page.cfm?id=81367593542&coll=GUIDE&dl=GUIDE&trk=0&CFID=92476326&CFTOKEN=78919110">Michał Moskal</a>.  In <em>Proceedings of the Workshop on Satisfiability Modulo Theories</em>, pages 20&ndash;29, 2009. [<a href=http://research.microsoft.com/en-us/um/people/moskal/pdf/prtrig.pdf>PDF</a>]</p></li></ul><hr></div></div></body></html>