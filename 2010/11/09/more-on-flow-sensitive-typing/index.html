<!doctype html><html lang=en><head><script async src="https://www.googletagmanager.com/gtag/js?id=G-9MRLB1FVZX"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-9MRLB1FVZX",{anonymize_ip:!1})}</script><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta property="og:title" content="More on Flow-Sensitive Typing"><meta name=twitter:title content="More on Flow-Sensitive Typing"><meta property="og:url" content="https://whileydave.com/2010/11/09/more-on-flow-sensitive-typing/"><title>David J. Pearce
(More on Flow-Sensitive Typing)</title><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css><link rel=stylesheet href=https://whileydave.com/css/page.css><link rel=stylesheet href=https://whileydave.com/css/menu.css><link rel=stylesheet href=https://whileydave.com/css/style.css><link rel=stylesheet href=https://whileydave.com/css/syntax.css></head><body><script>"use strict";function clearMenu(){var e,t,n=window.matchMedia("(max-width: 992px)");n.matches&&(e=document.getElementById("menu-content"),t=document.getElementById("menu"),e.style.display="none",t.style.filter="")}function toggleMenu(){var e,t,n=window.matchMedia("(max-width: 992px)");n.matches&&(e=document.getElementById("menu-content"),t=document.getElementById("menu"),e.style.display==="block"?(e.style.display="none",t.style.filter=""):(e.style.display="block",t.style.filter="brightness(0.8)"))}function toggleList(e){e.style.display="none";for(var t,o=e.parentNode,s=o.childNodes,n=0;n<s.length;++n)t=s[n],t.classList&&t.classList.contains("hidden")&&(t.style.display==="block"?t.style.display="none":t.style.display="block")}</script><header class=topbar><div class=topbar-header onclick=clearMenu()><div class=topbar-title>Dr. David J. Pearce</div><div class=topbar-subtitle></div></div><div class=topbar-social onclick=clearMenu()><a href=https://github.com/DavePearce><i class="fa fa-github" aria-hidden=true></i></a>
<a href=https://twitter.com/WhileyDave><i class="fa fa-twitter" aria-hidden=true></i></a>
<a href=https://www.youtube.com/user/redjamjar/><i class="fa fa-youtube-play" aria-hidden=true></i></a>
<a href=https://www.linkedin.com/in/david-pearce-8592647/><i class="fa fa-linkedin-square" aria-hidden=true></i></a></div><div class=topbar-menu><div id=menu onclick=toggleMenu()><div id=menu-icon><img src=https://whileydave.com/images/menu.png alt=Menu></div><div id=menu-content><a href=https://whileydave.com/blog/>Blog</a>
<a href=https://whileydave.com/projects/>Projects</a>
<a href=https://whileydave.com/publications/>Publications</a>
<a href=https://whileydave.com/talks/>Talks</a>
<a href=https://whileydave.com/>Home</a></div></div></div></header><div class=container onclick=clearMenu()><div class=content><h1 class=post-title>More on Flow-Sensitive Typing</h1><div class=post-date>Tuesday, November
9th,
2010</div><hr><p>The idea behind <a href=/2010/09/22/on-flow-sensitive-types-in-whiley/>flow-sensitive typing in Whiley</a> is to give a <a href=http://en.wikipedia.org/wiki/Type_system#Static_typing>statically typed language</a> the look-and-feel of a <a href=http://wikipedia.org/wiki/Dynamic_programming_language>dynamically typed language</a> (as much as possible).  The following illustrates:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl> <span class=kt>int</span> <span class=n>average</span><span class=p>([</span><span class=kt>int</span><span class=p>]</span> <span class=n>items</span><span class=p>)</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>v</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=k>in</span> <span class=n>items</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=n>v</span> <span class=o>=</span> <span class=n>v</span> <span class=o>+</span> <span class=n>items</span><span class=p>[</span><span class=n>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>v</span> <span class=o>/</span> <span class=o>|</span><span class=n>items</span><span class=o>|</span>
</span></span></code></pre></div><p>Here, we see that there are only two type declarations: one for the parameter, and one for the return. Otherwise, it looks much like a dynamically typed language. Variable <code>v</code> is <em>declared by assignment</em> to have type <code>int</code>. In other words, assigning <code>0</code> declares it and gives it the type <code>int</code> at that point. We could assign variable <code>v</code> other values later on, and it&rsquo;s type would be automatically updated to reflect this. The following gives an artificial example to illustrate:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl> <span class=kt>int</span> <span class=n>f</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>)</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>y</span> <span class=o>=</span> <span class=mi>1123</span>
</span></span><span class=line><span class=cl>    <span class=c1>// here, y has type int
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>x</span> <span class=o>=</span> <span class=n>x</span> <span class=o>+</span> <span class=n>y</span>
</span></span><span class=line><span class=cl>    <span class=n>y</span> <span class=o>=</span> <span class=err>&#34;</span><span class=n>Hello</span><span class=err>&#34;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// now, y has type string
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=n>x</span> <span class=o>+</span> <span class=o>|</span><span class=n>v</span><span class=o>|</span>
</span></span></code></pre></div><p>A number of interesting issues arise with Whiley&rsquo;s flow-sensitive typing system, and we&rsquo;ll look at them in more detail now.</p><h2 id=conditionals>Conditionals</h2><p>An on obvious question is: <em>what happens when a variable is declared on one side of a conditional?</em> Here&rsquo;s an example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl><span class=kt>int</span> <span class=n>f</span><span class=p>(</span><span class=kt>int</span> <span class=n>y</span><span class=p>)</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>y</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=n>x</span> <span class=o>=</span> <span class=mi>123</span>
</span></span><span class=line><span class=cl>    <span class=c1>// following line gives a syntax error
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=n>x</span> <span class=o>+</span> <span class=n>y</span>
</span></span></code></pre></div><p>This code does not compile, since variable <code>x</code> may be undefined at the <code>return</code> statement.  It gets more interesting if we do this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl><span class=n>real</span> <span class=n>f</span><span class=p>(</span><span class=kt>int</span> <span class=n>y</span><span class=p>)</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>y</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=n>x</span> <span class=o>=</span> <span class=n>y</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=n>x</span> <span class=o>=</span> <span class=mi>1</span><span class=p>.</span><span class=mi>23</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>x</span>
</span></span></code></pre></div><p>Now, the question is: <em>what type does x have at the return statement?</em> The answer, as expected, is <code>real</code> (i.e. because every <code>int</code> is also a <code>real</code>).</p><p>But, wait! <em>What happens if the types assigned on either side are unreleated?</em> Well, in this case, Whiley uses a <a href=http://en.wikipedia.org/wiki/Type_system#Union_types>union type</a> (and see my <a href=/2010/09/22/on-flow-sensitive-types-in-whiley/>earlier post</a> for more on this).</p><h2 id=lists>Lists</h2><p>List assignment has some interesting and surprising properties in Whiley.  For example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl><span class=n>real</span> <span class=n>f</span><span class=p>([</span><span class=kt>int</span><span class=p>]</span> <span class=n>ls</span><span class=p>)</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=o>|</span><span class=n>ls</span><span class=o>|</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=n>ls</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span><span class=p>.</span><span class=mi>23</span>
</span></span><span class=line><span class=cl>    <span class=c1>// type of ls is now [real]
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>...</span>
</span></span></code></pre></div><p>Here, we have a potential assignment from a <code>real</code> value to an element of <code>ls</code>. Whiley does not complain that this is an error, despite the type of ls (on entry) being <code>[int]</code>. Instead, Whiley updates the type of <code>ls</code> to reflect this. Thus, since we now have at least one element of type <code>real</code>, the whole list is now considered to have type <code>[real]</code>.</p><h2 id=records>Records</h2><p>Things really start to get interesting when we consider records.  For example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl><span class=n>define</span> <span class=n>Point</span> <span class=n>as</span> <span class=p>{</span><span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=kt>int</span> <span class=n>y</span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>real</span> <span class=n>f</span><span class=p>(</span><span class=n>Point</span> <span class=n>p</span><span class=p>)</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span><span class=p>.</span><span class=n>x</span> <span class=o>=</span> <span class=mi>1</span><span class=p>.</span><span class=mi>234</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span> <span class=c1>// type of p now {real x, int y}
</span></span></span></code></pre></div><p>What we see here is that the type of variable <code>p</code> is updated by the assignment to field <code>x</code>. The reason for allowing this is to reflect dynamic languages as much as possible. In a dynamic language, such an assignment would be always be permitted and, hence, so it is in Whiley.</p><p>Most dynamic languages also have <em>field-creation-by-assignment</em> semantics as well. However, in Whiley, I don&rsquo;t permit this and, hence, the following is a compile-time error:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl><span class=kt>int</span> <span class=n>f</span><span class=p>(</span><span class=n>Point</span> <span class=n>p</span><span class=p>)</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span><span class=p>.</span><span class=n>z</span> <span class=o>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span></code></pre></div><p>The reason I don&rsquo;t allow this, is that I believe it will cause too many subtle errors.  That is, if the programmer meant to assign to variable <code>x</code>, but made a typo and assigned variable <code>z</code>, then <em>the system would not complain</em>. For me, this would be going too far.</p><h2 id=record-subtyping>Record Subtyping</h2><p>In a language like Java, you create data-types using classes.  Each class has a specific name, and classes with different names are distinct.  Inheritance and interfaces can be used to allow some degree of interchangeability, but this remains very static and rigid in nature.  Whiley adopts a much more flexible approach, sometimes known as <em>structural subtyping</em>.  First and foremost, records in Whiley are not associated with names &mdash; they are really just macros which expand.  So, for example, this piece of code</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl><span class=n>define</span> <span class=n>Point</span> <span class=n>as</span> <span class=p>{</span><span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=kt>int</span> <span class=n>y</span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>getX</span><span class=p>(</span><span class=n>Point</span> <span class=n>p</span><span class=p>)</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>p</span><span class=p>.</span><span class=n>x</span>
</span></span></code></pre></div><p>is essentially identical to this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl><span class=kt>int</span> <span class=n>getX</span><span class=p>({</span><span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=kt>int</span> <span class=n>y</span><span class=p>}</span> <span class=n>p</span><span class=p>)</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>p</span><span class=p>.</span><span class=n>x</span>
</span></span></code></pre></div><p>In other words, the name <code>Point</code> has no semantic meaning in the language. The beauty of this is that we can easily interchange Points with types defined elsewhere, potentially by others. For example, suppose in some other file we have this definition:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl><span class=n>define</span> <span class=n>Point2D</span> <span class=n>as</span> <span class=p>{</span><span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=kt>int</span> <span class=n>y</span><span class=p>}</span>
</span></span></code></pre></div><p>Well, any method that accepts a <code>Point2D</code> will also accept an <code>Point</code> instance (and vice versa) &mdash; <em>despite the fact that these types may come from files which were developed in isolation</em>. There&rsquo;s no need to write code which converts between <code>Point</code>s and <code>Point2D</code>s, etc. Similarly, subtyping of records works as expected:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl><span class=n>define</span> <span class=n>RealPoint2D</span> <span class=n>as</span> <span class=p>{</span><span class=n>real</span> <span class=n>x</span><span class=p>,</span> <span class=n>real</span> <span class=n>y</span><span class=p>}</span>
</span></span></code></pre></div><p>Here, we can pass <code>Point</code> instances into functions which accept <code>RealPoint2D</code>s (since every <code>Point</code> is a <code>RealPoint2D</code>). However, we cannot pass <code>RealPoint2D</code> instancess into functions expecting Points as, for example, <code>{x:2.2,y:1.0}</code> is not an instance of <code>Point</code>.</p><p>Finally, Whiley also also supports subtyping between records with different numbers of fields:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl><span class=n>define</span> <span class=n>Point3D</span> <span class=n>as</span> <span class=p>{</span><span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=kt>int</span> <span class=n>y</span><span class=p>,</span> <span class=kt>int</span> <span class=n>z</span><span class=p>}</span>
</span></span></code></pre></div><p>A <code>Point3D</code> instance can be passed into a function expecting a <code>Point</code> or a <code>Point2D</code>, etc. Again, no awkward conversions between different types are necessary, making life just that bit simpler&mldr;</p><h2 id=conclusion>Conclusion</h2><p>I&rsquo;m a big fan of both dynamic and static typing (for different reasons, obviously).  I see no reason why we can&rsquo;t get the best of both worlds, and this is what I&rsquo;m trying to do with Whiley&rsquo;s type system.  As usual, only time will tell if it really makes sense or not.  For now, I&rsquo;ll let you decide&mldr;</p><hr></div></div></body></html>