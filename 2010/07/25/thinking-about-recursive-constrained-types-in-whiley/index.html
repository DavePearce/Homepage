<!doctype html><html lang=en><head><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta property="og:title" content="Thinking about Recursive Constrained Types in Whiley"><meta name=twitter:title content="Thinking about Recursive Constrained Types in Whiley"><meta property="og:url" content="https://whileydave.com/2010/07/25/thinking-about-recursive-constrained-types-in-whiley/"><title>David J. Pearce
(Thinking about Recursive Constrained Types in Whiley)</title><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css><link rel=stylesheet href=https://whileydave.com/css/page.css><link rel=stylesheet href=https://whileydave.com/css/menu.css><link rel=stylesheet href=https://whileydave.com/css/style.css></head><body><script>"use strict";function clearMenu(){var e,t,n=window.matchMedia("(max-width: 992px)");n.matches&&(e=document.getElementById("menu-content"),t=document.getElementById("menu"),e.style.display="none",t.style.filter="")}function toggleMenu(){var e,t,n=window.matchMedia("(max-width: 992px)");n.matches&&(e=document.getElementById("menu-content"),t=document.getElementById("menu"),e.style.display==="block"?(e.style.display="none",t.style.filter=""):(e.style.display="block",t.style.filter="brightness(0.8)"))}function toggleList(e){e.style.display="none";for(var t,o=e.parentNode,s=o.childNodes,n=0;n<s.length;++n)t=s[n],t.classList&&t.classList.contains("hidden")&&(t.style.display==="block"?t.style.display="none":t.style.display="block")}</script><header class=topbar><div class=topbar-header onclick=clearMenu()><div class=topbar-title>Dr. David J. Pearce</div><div class=topbar-subtitle></div></div><div class=topbar-social onclick=clearMenu()><a href=https://github.com/DavePearce><i class="fa fa-github" aria-hidden=true></i></a>
<a href=https://twitter.com/WhileyDave><i class="fa fa-twitter" aria-hidden=true></i></a>
<a href=https://www.youtube.com/user/redjamjar/><i class="fa fa-youtube-play" aria-hidden=true></i></a>
<a href=https://www.linkedin.com/in/david-pearce-8592647/><i class="fa fa-linkedin-square" aria-hidden=true></i></a></div><div class=topbar-menu><div id=menu onclick=toggleMenu()><div id=menu-icon><img src=https://whileydave.com/images/menu.png alt=Menu></div><div id=menu-content><a href=https://whileydave.com/blog/>Blog</a>
<a href=https://whileydave.com/projects/>Projects</a>
<a href=https://whileydave.com/publications/>Publications</a>
<a href=https://whileydave.com/talks/>Talks</a>
<a href=https://whileydave.com/>Home</a></div></div></div></header><div class=container onclick=clearMenu()><div class=content><h1 class=post-title>Thinking about Recursive Constrained Types in Whiley</h1><div class=post-date>Sunday, July
25th,
2010</div><hr><p>Whiley supports so-called <a href=http://wikipedia.org/wiki/algebraic_data_type>Algebraic Data Types</a> for constructing tree-like data structures.  For example, an expression tree might be defined like so:</p><pre tabindex=0><code>define ADD as 1
define SUB as 2
define MUL as 3
define DIV as 4
define binop as {ADD,SUB,MUL,DIV}
define expr as int | (binop op, expr lhs, expr rhs)
</code></pre><p>Using this definition for <code>expr</code>, we can create a variety of trees representing compound arithmetic expressions.  There is nothing particularly surprising about this so far, as languages like <a href=http://wikipedia.org/wiki/haskell_(programming_language)>Haskell</a> have similar constructs.</p><p>The key difference from other languages is that Whiley supports <em>constrained types</em>.  That is, types with specific constraints on them which restrict the values that variables of those types may take.  In the above example, <code>binop</code> is an example of a constrained type.  In this particular case, it is not so exciting because you can achieve the same thing with <a href=http://wikipedia.org/wiki/enumerated_type>enumerations</a> in most languages.</p><p>We can refine our example to make it a little more interesting as follows:</p><pre tabindex=0><code>define bexpr as (binop op, expr lhs, expr rhs)
             where !(lhs ~= int &amp;&amp; rhs ~= int)
define expr as int | string| bexpr
</code></pre><p>This introduces a constraint that prevents both sides of a binary operation from being constants.  We could think of it as an optimisation as, in such a case, we can immediately evaluate the operation to produce a value.  I have introduced the <code>string</code> option to represents variables (otherwise, our expression trees would always be constants!).</p><p>At this point, things start to get tricky.  Not with the syntax of the language per se, but rather with the details of how we will check all this at <a href=http://wikipedia.org/wiki/compile_time>compile time</a>.  First, let&rsquo;s imagine a simple case:</p><pre tabindex=0><code>expr e = (op:ADD,lhs:1,rhs:(op:SUB,lhs:2,rhs:&#34;x&#34;))
</code></pre><p>This builds the expression <code>1+(2-x)</code> and assigns it to variable <code>e</code>.  To check at compile time that the constraints imposed by <code>bexpr</code> are satisfied is relatively straightforward.  We simply &ldquo;unroll&rdquo; the recursive constrained type, which introduces the following checks:</p><pre tabindex=0><code>expr e = (op:ADD,lhs:1,rhs:(op:SUB,lhs:2,rhs:&#34;x&#34;))
check !(e.lhs ~= int &amp;&amp; e.rhs ~= int)
check !(e.rhs.lhs ~= int &amp;&amp; e.rhs.rhs ~= int)
</code></pre><p>Both of these checks are fairly straightforward for the theorem prover <a href=wyone>wyone</a> to discharge.  A harder problem lies with this example:</p><pre tabindex=0><code>define asexpr as bexpr where $.op in {ADD,SUB}
void f(asexpr e1):
    expr e2 = e1
</code></pre><p>Obviously, this is a contrived example, but it does make the point.  That is, we need to check that the constraints placed on variable <code>e2</code> remain satisfied after the assignment.  Whilst this appears fairly obvious to a human, the machine must follow a process.  In this case, we cannot &ldquo;unroll&rdquo; the recursive constrained type as we did before, since <code>e1</code> is an arbitrary instance of <code>asexpr</code>.</p><p>The question is <em>what can we do?</em> And, that&rsquo;s about where my thinking is up to right now.  Essentially, it needs some kind of structural induction to show that <code>asexpr</code> implies <code>expr</code>.  Generally speaking, <a href=http://wikipedia.org/wiki/Satisfiability_Modulo_Theories>SMT solvers</a> (and other kinds of automated theorem provers) avoid providing induction primitives as this is considered very complex, and more suited to a Human.</p><h2 id=further-reading>Further Reading</h2><ul><li><p><strong>Constrained Types for Object-Oriented Languages</strong>, Nat Nystrom, et al. [<a href=http://ranger.uta.edu/~nystrom/papers/oopsla08.pdf>PDF</a>]</p></li><li><p><strong>Constrained Types and their Expressiveness</strong>, Palsberg and Smith.  [<a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.25.8386&rep=rep1&type=pdf">PDF</a>]</p></li><li><p><strong>Lambda Calculus with Constrained Types</strong>, Val Breazu-Tannen and Albert R. Meyer. [<a href=http://dx.doi.org/10.1007/3-540-15648-8>DOI</a>]</p></li></ul><hr></div></div><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-5582165-7","auto"),ga("send","pageview"))</script></body></html>