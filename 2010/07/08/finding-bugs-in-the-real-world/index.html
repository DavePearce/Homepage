<!doctype html><html lang=en><head><script async src="https://www.googletagmanager.com/gtag/js?id=G-9MRLB1FVZX"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-9MRLB1FVZX",{anonymize_ip:!1})}</script><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta property="og:title" content="Finding Bugs in the Real World"><meta name=twitter:title content="Finding Bugs in the Real World"><meta property="og:url" content="https://whileydave.com/2010/07/08/finding-bugs-in-the-real-world/"><title>David J. Pearce
(Finding Bugs in the Real World)</title><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css><link rel=stylesheet href=https://whileydave.com/css/page.css><link rel=stylesheet href=https://whileydave.com/css/menu.css><link rel=stylesheet href=https://whileydave.com/css/style.css><link rel=stylesheet href=https://whileydave.com/css/syntax.css></head><body><script>"use strict";function clearMenu(){var e,t,n=window.matchMedia("(max-width: 992px)");n.matches&&(e=document.getElementById("menu-content"),t=document.getElementById("menu"),e.style.display="none",t.style.filter="")}function toggleMenu(){var e,t,n=window.matchMedia("(max-width: 992px)");n.matches&&(e=document.getElementById("menu-content"),t=document.getElementById("menu"),e.style.display==="block"?(e.style.display="none",t.style.filter=""):(e.style.display="block",t.style.filter="brightness(0.8)"))}function toggleList(e){e.style.display="none";for(var t,o=e.parentNode,s=o.childNodes,n=0;n<s.length;++n)t=s[n],t.classList&&t.classList.contains("hidden")&&(t.style.display==="block"?t.style.display="none":t.style.display="block")}</script><header class=topbar><div class=topbar-header onclick=clearMenu()><div class=topbar-title>Dr. David J. Pearce</div><div class=topbar-subtitle></div></div><div class=topbar-social onclick=clearMenu()><a href=https://github.com/DavePearce><i class="fa fa-github" aria-hidden=true></i></a>
<a href=https://twitter.com/WhileyDave><i class="fa fa-twitter" aria-hidden=true></i></a>
<a href=https://www.youtube.com/user/redjamjar/><i class="fa fa-youtube-play" aria-hidden=true></i></a>
<a href=https://www.linkedin.com/in/david-pearce-8592647/><i class="fa fa-linkedin-square" aria-hidden=true></i></a></div><div class=topbar-menu><div id=menu onclick=toggleMenu()><div id=menu-icon><img src=https://whileydave.com/images/menu.png alt=Menu></div><div id=menu-content><a href=https://whileydave.com/blog/>Blog</a>
<a href=https://whileydave.com/projects/>Projects</a>
<a href=https://whileydave.com/publications/>Publications</a>
<a href=https://whileydave.com/talks/>Talks</a>
<a href=https://whileydave.com/>Home</a></div></div></div></header><div class=container onclick=clearMenu()><div class=content><h1 class=post-title>Finding Bugs in the Real World</h1><div class=post-date>Thursday, July
8th,
2010</div><hr><p>There&rsquo;s a really interesting article over on CACM about static analysis in the real world.  Here&rsquo;s the <a href=http://cacm.acm.org/magazines/2010/2/69354-a-few-billion-lines-of-code-later/fulltext>Link</a>.</p><p>The article is a report from experiences gained in the commercialisation of a tool by <a href=http://www.coverity.com/>Coverity</a> which uses <a href=http://wikipedia.org/wiki/static_code_analysis>static code analysis</a> to find bugs.  The tool applies a set of relatively straight-forward rules to identify problems in code (e.g. that a lock is followed by an unlock).  They need to check millions of lines of code with minimal setup, find as many real errors as possible whilst also minimising the number of <em>false positives</em>.  They can&rsquo;t use annotations or specifications, as this requires too much intervention (remember, they&rsquo;re analysing millions of lines of <em>existing</em> code).  So, the tool is unsound, but that&rsquo;s OK provided it finds lots of real errors:</p><blockquote><p>Like other early static-tool researchers, we benefited from what seems an empirical law: Assuming you have a reasonable tool, if you run it over a large, previously unchecked system, you will always find bugs.</p></blockquote><p>Now, this all sounds fine in theory &mldr; but the real problems stem from more practical and surprising issues:</p><blockquote><p>The problems that show up when thousands of programmers use a tool to check hundreds (or even thousands) of code bases do not show up when you and your co-authors check only a few.</p></blockquote><p>One of the key challenges seems to be convincing a client to use the tool, which comes down to the &ldquo;pre-sale demonstration&rdquo;.  The problem is that there isn&rsquo;t much time, and the results need to be really good &mldr; otherwise, they&rsquo;re not going to be interested.  The context of the trial is, of course, a very large program with an ad-hoc build system written by the client.  They&rsquo;ll be expecting you to get to grips with it quickly, and that the tool will work on it with minimal (if any) changes.  The massive variation in build systems, compiler compatibility and just plain wierd stuff you can do with macros and the like in C, made all of this extremely difficult.</p><p>Now, the really interesting thing is that, assuming they get past the pre-trial stage then, of course, they&rsquo;re going to start finding bugs in the code.  <em>That&rsquo;s the point, right?</em> Well, what happens when the client won&rsquo;t accept they have a bug?</p><blockquote><p>Arguing reliably kills sales. What to do? One trick is to try to organize a large meeting so their peers do the work for you. The more people in the room, the more likely there is someone very smart and respected and cares (about bugs and about the given code), can diagnose an error (to counter arguments it&rsquo;s a false positive), has been burned by a similar error, loses his/her bonus for errors, or is in another group (another potential sale).</p></blockquote><p>Anyway, I don&rsquo;t want to spoil it all for you &mldr; it&rsquo;s such great stuff.  The conclusion seems to be that clients are often ignorant of subtle coding issues and are likely to stay that way because of internal politics.  That is, doing something which dramatically increases the number of known defects usually gets someone fired, not promoted &mldr;</p><hr></div></div></body></html>