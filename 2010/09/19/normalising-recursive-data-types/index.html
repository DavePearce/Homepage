<!doctype html><html lang=en><head><script async src="https://www.googletagmanager.com/gtag/js?id=G-9MRLB1FVZX"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-9MRLB1FVZX",{anonymize_ip:!1})}</script><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta property="og:title" content="Normalising Recursive Data Types"><meta name=twitter:title content="Normalising Recursive Data Types"><meta property="og:url" content="https://whileydave.com/2010/09/19/normalising-recursive-data-types/"><title>David J. Pearce
(Normalising Recursive Data Types)</title><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css><link rel=stylesheet href=https://whileydave.com/css/page.css><link rel=stylesheet href=https://whileydave.com/css/menu.css><link rel=stylesheet href=https://whileydave.com/css/style.css><link rel=stylesheet href=https://whileydave.com/css/syntax.css></head><body><script>"use strict";function clearMenu(){var e,t,n=window.matchMedia("(max-width: 992px)");n.matches&&(e=document.getElementById("menu-content"),t=document.getElementById("menu"),e.style.display="none",t.style.filter="")}function toggleMenu(){var e,t,n=window.matchMedia("(max-width: 992px)");n.matches&&(e=document.getElementById("menu-content"),t=document.getElementById("menu"),e.style.display==="block"?(e.style.display="none",t.style.filter=""):(e.style.display="block",t.style.filter="brightness(0.8)"))}function toggleList(e){e.style.display="none";for(var t,o=e.parentNode,s=o.childNodes,n=0;n<s.length;++n)t=s[n],t.classList&&t.classList.contains("hidden")&&(t.style.display==="block"?t.style.display="none":t.style.display="block")}</script><header class=topbar><div class=topbar-header onclick=clearMenu()><div class=topbar-title>Dr. David J. Pearce</div><div class=topbar-subtitle></div></div><div class=topbar-social onclick=clearMenu()><a href=https://github.com/DavePearce><i class="fa fa-github" aria-hidden=true></i></a>
<a href=https://twitter.com/WhileyDave><i class="fa fa-twitter" aria-hidden=true></i></a>
<a href=https://www.youtube.com/user/redjamjar/><i class="fa fa-youtube-play" aria-hidden=true></i></a>
<a href=https://www.linkedin.com/in/david-pearce-8592647/><i class="fa fa-linkedin-square" aria-hidden=true></i></a></div><div class=topbar-menu><div id=menu onclick=toggleMenu()><div id=menu-icon><img src=https://whileydave.com/images/menu.png alt=Menu></div><div id=menu-content><a href=https://whileydave.com/blog/>Blog</a>
<a href=https://whileydave.com/projects/>Projects</a>
<a href=https://whileydave.com/publications/>Publications</a>
<a href=https://whileydave.com/talks/>Talks</a>
<a href=https://whileydave.com/>Home</a></div></div></div></header><div class=container onclick=clearMenu()><div class=content><h1 class=post-title>Normalising Recursive Data Types</h1><div class=post-date>Sunday, September
19th,
2010</div><hr><p>Recently, I came across an interesting problem with the type system I&rsquo;m using in Whiley.  Specifically, the problem relates to recursive types which are equivalent but not identical.  Consider, for example, the following Whiley code:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl><span class=n>define</span> <span class=n>Link</span> <span class=n>as</span> <span class=p>{</span> <span class=kt>int</span> <span class=n>data</span><span class=p>,</span> <span class=n>LinkedList</span> <span class=n>next</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>define</span> <span class=n>LinkedList</span> <span class=n>as</span> <span class=kc>null</span> <span class=o>|</span> <span class=n>Link</span>
</span></span></code></pre></div><p>This is a fairly straightforward definition of a <a href=http://wikipedia.org/wiki/linked_list>linked list</a>.</p><p>Now, the question is: <em>what is the type of a LinkedList?</em> To determine this, the compiler does a <a href=http://wikipedia.org/wiki/depth-first_search>depth-first search</a> from the <code>define</code> point.  So, starting from  <code>LinkedList</code>, it traverses into the body of the defintion, and then into the bodies of those datatypes it contains (i.e. <code>Link</code> in this case).  At some point during this traversal, it will encounter the name <code>LinkedList</code> again, which signals a recursive data type.  This traversal leads to the following (recursive) type:
<code>X &lt; null | {int data, X next} ></code>
Here, the braces signify a recursive type on variable X.  Such a type essentially captures an infinite number of concrete types, which can be obtained by unfolding.  Some examples are</p><pre tabindex=0><code>null
{int data, null next}
{int data, {int data, null next} next}
</code></pre><p>All of these are subtypes of the original recursive type.</p><p>Now, onto the problem at hand, which is nicely illustrated by the following Whiley code:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl><span class=kt>int</span> <span class=n>length</span><span class=p>(</span><span class=n>LinkedList</span> <span class=n>list</span><span class=p>)</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=n>list</span> <span class=o>~=</span> <span class=n>Link</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>1</span> <span class=o>+</span> <span class=n>length</span><span class=p>(</span><span class=n>list</span><span class=p>.</span><span class=n>next</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>else</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span>
</span></span></code></pre></div><p>This little example shows how to determine the length of a list.  In particular, we use the <code>~=</code> type test operation to check the runtime type of <code>list</code>.  What this doing is essentially checking whether <code>Link</code> is a subtype of <code>LinkedList</code>.  The actual types in question are:</p><pre tabindex=0><code>LinkedList ==&gt; X &lt; null | {int data, X next} &gt;
Link ========&gt; Y &lt; {int data, null|Y next} &gt;
</code></pre><p>So, <em>how do we test whether one is the subtype of the other?</em> Well, this is the thing: <em>we need them to be the same, but they&rsquo;re obviously not.</em></p><p>To resolve this issue, we can normalise the recursive types.  There are different ways this could be done, but for the moment I do it by <em>unfactoring</em> them.  That is, by pulling out bits which are not recursive, like so:</p><pre tabindex=0><code>X &lt; null | {int data, X next} &gt;
=====&gt; null | X &lt; {int data, null|X next}&gt;
</code></pre><p>The key is that the second component of the derived type is now identical to the type of <code>Link</code> and we can now easily perform the subtype test.</p><p>Anyway, it&rsquo;s not completely clear to me whether this unfactoring process is sufficient for all possible cases or, indeed, what the complexity class of subtype testing in the presence of recursive types like these is (hopefully, it&rsquo;s at least decidable :).  Digging around briefly, I did come across the following paper which seems related, but I need time to digest it properly:</p><ul><li><em>Subtyping Recursive Types</em>, Roberto M. Amadio1 Luca Cardelli, TOPLAS, 1993.  [<a href="http://portal.acm.org/citation.cfm?id=155231">ACM DL</a>] [<a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.65.4769&rep=rep1&type=pdf">PDF</a>]</li></ul><hr></div></div></body></html>