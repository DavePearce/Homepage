<!doctype html><html lang=en><head><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta property="og:title" content="On Flow-Sensitive Types in Whiley"><meta name=twitter:title content="On Flow-Sensitive Types in Whiley"><meta property="og:url" content="https://whileydave.com/2010/09/22/on-flow-sensitive-types-in-whiley/"><title>David J. Pearce
(On Flow-Sensitive Types in Whiley)</title><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css><link rel=stylesheet href=https://whileydave.com/css/page.css><link rel=stylesheet href=https://whileydave.com/css/menu.css><link rel=stylesheet href=https://whileydave.com/css/style.css><link rel=stylesheet href=https://whileydave.com/css/syntax.css></head><body><script>"use strict";function clearMenu(){var e,t,n=window.matchMedia("(max-width: 992px)");n.matches&&(e=document.getElementById("menu-content"),t=document.getElementById("menu"),e.style.display="none",t.style.filter="")}function toggleMenu(){var e,t,n=window.matchMedia("(max-width: 992px)");n.matches&&(e=document.getElementById("menu-content"),t=document.getElementById("menu"),e.style.display==="block"?(e.style.display="none",t.style.filter=""):(e.style.display="block",t.style.filter="brightness(0.8)"))}function toggleList(e){e.style.display="none";for(var t,o=e.parentNode,s=o.childNodes,n=0;n<s.length;++n)t=s[n],t.classList&&t.classList.contains("hidden")&&(t.style.display==="block"?t.style.display="none":t.style.display="block")}</script><header class=topbar><div class=topbar-header onclick=clearMenu()><div class=topbar-title>Dr. David J. Pearce</div><div class=topbar-subtitle></div></div><div class=topbar-social onclick=clearMenu()><a href=https://github.com/DavePearce><i class="fa fa-github" aria-hidden=true></i></a>
<a href=https://twitter.com/WhileyDave><i class="fa fa-twitter" aria-hidden=true></i></a>
<a href=https://www.youtube.com/user/redjamjar/><i class="fa fa-youtube-play" aria-hidden=true></i></a>
<a href=https://www.linkedin.com/in/david-pearce-8592647/><i class="fa fa-linkedin-square" aria-hidden=true></i></a></div><div class=topbar-menu><div id=menu onclick=toggleMenu()><div id=menu-icon><img src=https://whileydave.com/images/menu.png alt=Menu></div><div id=menu-content><a href=https://whileydave.com/blog/>Blog</a>
<a href=https://whileydave.com/projects/>Projects</a>
<a href=https://whileydave.com/publications/>Publications</a>
<a href=https://whileydave.com/talks/>Talks</a>
<a href=https://whileydave.com/>Home</a></div></div></div></header><div class=container onclick=clearMenu()><div class=content><h1 class=post-title>On Flow-Sensitive Types in Whiley</h1><div class=post-date>Wednesday, September
22nd,
2010</div><hr><p>In the ensuing months since the previous release of Whiley, I have been working away on a major rewrite of the compiler. This is now almost ready, at last! One of the &ldquo;executive decisions&rdquo; I made recently, was to move away from a declared variable model to a completely <a href=http://wikipedia.org/wiki/Data-flow_analysis>flow-sensitive</a> typing model. To understand this, consider the following program written in the old version of Whiley:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl><span class=p>[</span><span class=kt>int</span><span class=p>]</span> <span class=n>f</span><span class=p>(</span><span class=kt>int</span> <span class=n>y</span><span class=p>)</span><span class=o>:</span>
</span></span><span class=line><span class=cl>   <span class=kt>int</span> <span class=n>x</span> <span class=o>=</span> <span class=n>y</span>
</span></span><span class=line><span class=cl>   <span class=n>x</span> <span class=o>=</span> <span class=p>[</span><span class=mi>1</span><span class=p>,</span><span class=mi>2</span><span class=p>,</span><span class=mi>3</span><span class=p>,</span><span class=n>x</span><span class=p>]</span>
</span></span><span class=line><span class=cl>   <span class=k>return</span> <span class=n>x</span>
</span></span></code></pre></div><p>Here, variable <code>x</code> is declared to have type <code>int</code>, making the subsequent assignment of <code>[1,2,3,x]</code> a type error.  In the new version of Whiley, we don&rsquo;t declare variables at all, so this just becomes:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl><span class=p>[</span><span class=kt>int</span><span class=p>]</span> <span class=n>f</span><span class=p>(</span><span class=kt>int</span> <span class=n>y</span><span class=p>)</span><span class=o>:</span>
</span></span><span class=line><span class=cl>   <span class=n>x</span> <span class=o>=</span> <span class=n>y</span>
</span></span><span class=line><span class=cl>   <span class=n>x</span> <span class=o>=</span> <span class=p>[</span><span class=mi>1</span><span class=p>,</span><span class=mi>2</span><span class=p>,</span><span class=mi>3</span><span class=p>,</span><span class=n>x</span><span class=p>]</span>
</span></span><span class=line><span class=cl>   <span class=k>return</span> <span class=n>x</span>
</span></span></code></pre></div><p>Here, the type of <code>x</code> after the first assignment is <code>int</code>, whilst after the second assignment it&rsquo;s <code>[int]</code>.  There is no type error like before and, in fact, the type of a variable is now free to change at will.  Observe that the parameters and return value are still typed, since these constitute part of the function&rsquo;s specification.</p><p>This approaching to typing, which I call <em>flow-sensitive typing</em>, is rather nice and makes Whiley feel more like a dynamically typed language.  The reason for the switch  arose from me writing some non-trivial benchmarks in Whiley, and finding that type declarations really get in the way.</p><p>Some neat things happen when you start defining types in different places.  For example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl><span class=n>real</span> <span class=n>f</span><span class=p>(</span><span class=kt>int</span> <span class=n>y</span><span class=p>)</span><span class=o>:</span>
</span></span><span class=line><span class=cl>   <span class=k>if</span> <span class=n>y</span> <span class=o>&gt;</span> <span class=mi>1</span><span class=o>:</span>
</span></span><span class=line><span class=cl>      <span class=n>x</span> <span class=o>=</span> <span class=n>y</span>
</span></span><span class=line><span class=cl>   <span class=k>else</span><span class=o>:</span>
</span></span><span class=line><span class=cl>      <span class=n>x</span> <span class=o>=</span> <span class=mi>2</span><span class=p>.</span><span class=mi>0</span>
</span></span><span class=line><span class=cl>   <span class=k>return</span> <span class=n>x</span>
</span></span></code></pre></div><p>Here, the type of <code>x</code> after the assignment from <code>y</code> is <code>int</code>; similarly, after the other assignment it&rsquo;s <code>real</code>.  Then, after the if-statement it&rsquo;s also <code>real</code> as this is the <a href=http://wikipedia.org/wiki/supermum>least upper bound</a> of <code>int</code> and <code>real</code>.  A more interesting case is this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl><span class=n>define</span> <span class=n>intList</span> <span class=n>as</span> <span class=kt>int</span> <span class=o>|</span> <span class=p>[</span><span class=kt>int</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>intList</span> <span class=n>f</span><span class=p>(</span><span class=kt>int</span> <span class=n>y</span><span class=p>)</span><span class=o>:</span>
</span></span><span class=line><span class=cl>   <span class=k>if</span> <span class=n>y</span> <span class=o>&gt;</span> <span class=mi>1</span><span class=o>:</span>
</span></span><span class=line><span class=cl>      <span class=n>x</span> <span class=o>=</span> <span class=n>y</span>
</span></span><span class=line><span class=cl>   <span class=k>else</span><span class=o>:</span>
</span></span><span class=line><span class=cl>      <span class=n>x</span> <span class=o>=</span> <span class=p>[</span><span class=mi>1</span><span class=p>,</span><span class=mi>2</span><span class=p>,</span><span class=mi>3</span><span class=p>]</span>
</span></span><span class=line><span class=cl>   <span class=k>return</span> <span class=n>x</span>
</span></span></code></pre></div><p>Here, the type of <code>x</code> at the return statement is <code>int|[int]</code>, which represents the fact that <code>x</code> can hold either an <code>int</code> or a <code>[int]</code> value at that point.</p><p>Anyway, flow-sensitive types add real flexibility whilst also reducing the amount of code &mdash; seems like a win-win to me! Of course, some will say that it does make reasoning about functions more complex in Whiley. Whilst I agree this is true to some extent, I don&rsquo;t see it as a major issue. In particular, Whiley has no notion of global variables and, hence, there is never any confusion regarding <a href=http://wikipedia.org/wiki/Scope_(programming)>variable scope</a> (unlike e.g. <a href=http://wikipedia.org/wiki/JavaScript>JavaScript</a> or <a href=http://wikipedia.org/wiki/Python_(programming_language)>Python</a>).</p><hr></div></div><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-5582165-7","auto"),ga("send","pageview"))</script></body></html>