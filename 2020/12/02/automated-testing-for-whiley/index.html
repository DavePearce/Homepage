<!doctype html><html lang=en><head><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta property="og:title" content="Automated Testing for Whiley"><meta name=twitter:title content="Automated Testing for Whiley"><meta property="og:description" content="New functionality for automated testing is available on whileylabs.com.  This generates test inputs for functions and runs them through the code looking for problems (e.g. divide-by-zero, index-out-of-bounds, etc). In many ways, it is similar to the QuickCheck line of tools (with the added benefit that Whiley has first-class specifications)."><meta name=twitter:description content="New functionality for automated testing is available on whileylabs.com.  This generates test inputs for functions and runs them through the code looking for problems (e.g. divide-by-zero, index-out-of-bounds, etc). In many ways, it is similar to the QuickCheck line of tools (with the added benefit that Whiley has first-class specifications)."><meta property="og:image" content="https://whileydave.com/images/2020/QuickCheckDemo.jpg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://whileydave.com/images/2020/QuickCheckDemo.jpg"><meta name=twitter:image:alt content="https://whileydave.com/Image of Editing Code in WhileyLabs"><meta name=twitter:site content="@whileydave"><meta property="og:url" content="https://whileydave.com/2020/12/02/automated-testing-for-whiley/"><title>David J. Pearce
(Automated Testing for Whiley)</title><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css><link rel=stylesheet href=https://whileydave.com/css/page.css><link rel=stylesheet href=https://whileydave.com/css/menu.css><link rel=stylesheet href=https://whileydave.com/css/style.css><link rel=stylesheet href=https://whileydave.com/css/syntax.css></head><body><script>"use strict";function clearMenu(){var e,t,n=window.matchMedia("(max-width: 992px)");n.matches&&(e=document.getElementById("menu-content"),t=document.getElementById("menu"),e.style.display="none",t.style.filter="")}function toggleMenu(){var e,t,n=window.matchMedia("(max-width: 992px)");n.matches&&(e=document.getElementById("menu-content"),t=document.getElementById("menu"),e.style.display==="block"?(e.style.display="none",t.style.filter=""):(e.style.display="block",t.style.filter="brightness(0.8)"))}function toggleList(e){e.style.display="none";for(var t,o=e.parentNode,s=o.childNodes,n=0;n<s.length;++n)t=s[n],t.classList&&t.classList.contains("hidden")&&(t.style.display==="block"?t.style.display="none":t.style.display="block")}</script><header class=topbar><div class=topbar-header onclick=clearMenu()><div class=topbar-title>Dr. David J. Pearce</div><div class=topbar-subtitle></div></div><div class=topbar-social onclick=clearMenu()><a href=https://github.com/DavePearce><i class="fa fa-github" aria-hidden=true></i></a>
<a href=https://twitter.com/WhileyDave><i class="fa fa-twitter" aria-hidden=true></i></a>
<a href=https://www.youtube.com/user/redjamjar/><i class="fa fa-youtube-play" aria-hidden=true></i></a>
<a href=https://www.linkedin.com/in/david-pearce-8592647/><i class="fa fa-linkedin-square" aria-hidden=true></i></a></div><div class=topbar-menu><div id=menu onclick=toggleMenu()><div id=menu-icon><img src=https://whileydave.com/images/menu.png alt=Menu></div><div id=menu-content><a href=https://whileydave.com/blog/>Blog</a>
<a href=https://whileydave.com/projects/>Projects</a>
<a href=https://whileydave.com/publications/>Publications</a>
<a href=https://whileydave.com/talks/>Talks</a>
<a href=https://whileydave.com/>Home</a></div></div></div></header><div class=container onclick=clearMenu()><div class=content><h1 class=post-title>Automated Testing for Whiley</h1><div class=post-date>Wednesday, December
2nd,
2020</div><hr><p>Recently, the <a href=http://whileylabs.com>online editor for Whiley</a> was updated with some new features. Actually, the update represents a <em>complete rewrite of the front-end in Whiley</em>. Obviously, I am very excited about that! Previously it was written using raw (i.e. ugly) JavaScript, but now uses a framework for <a href="https://www.youtube.com/watch?v=yYGEcyCHiZk">Functional Reactive Programming</a> (called <a href=https://github.com/DavePearce/Web.wy>Web.wy</a>). That has made a huge difference to how the code looks. Still, I&rsquo;m not going to talk about that here. Rather, it is the new <em>check</em> feature (highlighted in red below) that I&rsquo;m interested in:</p><figure class=text-center><img width=709px src=/images/2020/AutomatedTesting_WhileyLabs.png></figure><p><em>What is this new &ldquo;check&rdquo; feature then?</em> In a nutshell, it automatically generates test inputs for functions and runs them through the code looking for problems (e.g. <em>divide-by-zero</em>, <em>index-out-of-bounds</em>, etc). In many ways, it is similar to the <a href=https://en.wikipedia.org/wiki/QuickCheck>QuickCheck</a> line of tools (with the added benefit that Whiley has first-class specifications). We can think of it as a &ldquo;half-way&rdquo; step towards formal verification. The key is that it is easier to check a program than it is to statically verify it (more on this below). Some might think that having a check feature like this doesn&rsquo;t make sense when you also have static verification. But, I prefer to think of them as <em>complementary</em>. Thinking about a developer&rsquo;s workflow, we might imagine checking a function first as we develop it (since this is easier and quicker) before, finally, attempting to statically verify it (since this is harder and may force the specification to be further refined).</p><h2 id=example>Example</h2><p>As a simple example to illustrate how it works, consider the following
signature for the <code>max(int[])</code> function:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl><span class=kd>function</span> <span class=n>max</span><span class=p>(</span><span class=kt>int</span><span class=p>[]</span> <span class=n>items</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=p>(</span><span class=kt>int</span> <span class=n>r</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>// items cannot be empty
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>requires</span> <span class=o>|</span><span class=n>items</span><span class=o>|</span> <span class=o>&gt;</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=c1>// result not smaller than any in items
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>ensures</span> <span class=k>all</span> <span class=p>{</span> <span class=n>i</span> <span class=k>in</span> <span class=mi>0</span><span class=p>..</span><span class=o>|</span><span class=n>items</span><span class=o>|</span> <span class=o>|</span> <span class=n>r</span> <span class=o>&gt;=</span> <span class=n>items</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// result is element in items
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>ensures</span> <span class=k>some</span> <span class=p>{</span> <span class=n>i</span> <span class=k>in</span> <span class=mi>0</span><span class=p>..</span><span class=o>|</span><span class=n>items</span><span class=o>|</span> <span class=o>|</span> <span class=n>r</span> <span class=o>==</span> <span class=n>items</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=p>}</span><span class=o>:</span>
</span></span><span class=line><span class=cl>   <span class=p>...</span>
</span></span></code></pre></div><p>We&rsquo;re not really concerned with the implementation here (and we can
assume it might have bugs). To check this function, the tool will do
the following:</p><ol><li><p><strong>(Generate)</strong> The tool generates some number of valid inputs.
That is, input values which meet the precondition. For our example
above, that is any <code>int[]</code> array containing at least one element.</p></li><li><p><strong>(Execute)</strong>. The function in question is then executed using
each of the generated inputs. This may lead to obvious failures
(e.g. out-of-bounds or divide-by-zero errors), in which case we&rsquo;ve
already found some bugs!</p></li><li><p><strong>(Check)</strong>. For any execution which completed, the tool then
checks the result against the postcondition. If the postcondition
doesn&rsquo;t hold then, again, this indicates a bug somewhere.</p></li></ol><p>The key is that the specification acts as the <a href=https://en.wikipedia.org/wiki/Test_oracle>test
oracle</a>. In other words,
<em>having written the specification we get testing for free</em>! And, the
tool takes care of the difficult stuff so we don&rsquo;t have to. For
example, generating valid inputs efficiently is harder than it looks
(more on this below).</p><h2 id=technical-stuff>Technical Stuff</h2><p>The main technical challenge is that of efficiently generating <em>input
values under constraints</em>. To start with, we can generate raw input
values for the various data types in Whiley:</p><ul><li><p><strong>Primitives.</strong> These are pretty easy. For example, to generate
values of type <code>int</code>, we&rsquo;ll use some (configurable) domain
(e.g. <code>-2 .. 2</code>) of values. We can easily sample uniformly
from this domain as well (e.g. using Knuth&rsquo;s <a href=https://rosettacode.org/wiki/Knuth%27s_algorithm_S>Algorithm
S</a>).</p></li><li><p><strong>Arrays</strong>. Here, we limit the maximum length of an array
(e.g. length <code>2</code>), and then enumerate all arrays upto this
length. To generate values in the array, we recursively call
the generator associated with the element type. For the array
type <code>int[]</code> and assuming max length <code>2</code> and integers <code>-1..1</code>,
we might generate: <code>[]</code>, <code>[-1]</code>, <code>[0]</code>, <code>[1]</code>, <code>[-1,-1]</code>,
<code>[0,-1]</code>,<code>[1,-2]</code>, etc.</p></li><li><p><strong>Records</strong>. These are similar, except there is no maximum
length. For each field, we recursively generate values using
the generator associated with its type. For the record type
<code>{bool flag, int data}</code> and assuming and integers <code>-1..1</code>, we
might generate: <code>{flag:false,data:-1}</code>, <code>{flag:true,data:-1}</code>,
<code>{flag:false,data:0}</code>, <code>{flag:true,data:0}</code>,
<code>{flag:false,data:1}</code>, etc.</p></li><li><p><strong>References</strong>. These are more tricky as we must allow for
aliasing between heap locations. For a single reference type
<code>&int</code>, we generate heap locations for each of the possible
integer values. However, for two reference types
(e.g. parameters <code>&int x, &int y</code>), we have to additionally
consider both the <em>aliased</em> and <em>non-aliased</em> cases.</p></li><li><p><strong>Lambdas</strong>. These are very challenging as, in principle, it
requires enumerating all implementations of a function!
Consider the lambda type <code>function(int)->(int)</code> &mdash; <em>how do we
generate values (i.e. implementations) of this type?</em> There is
no easy answer here, but there are some strategies we can use.
Firstly, we can scour the source program looking for functions
with the same signature. Secondly, we can generate simple
input/output mappings (e.g. <code>{-1=>-1, 0=>0, 1=>1}</code>). We can go
beyond this by applying <em>rotations</em> (e.g. <code>{-1=>0, 0=>1, 1=>-1}</code>).</p></li></ul><p>Given the ability to generate arbitrary values for a type, the more
difficult question is how to generate values which meet some
constraint. For example, consider this data type:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl><span class=kd>type</span> <span class=n>List</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=k>is</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>     <span class=kt>int</span> <span class=n>length</span><span class=p>,</span>
</span></span><span class=line><span class=cl>     <span class=n>T</span><span class=p>[]</span> <span class=n>items</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>where</span> <span class=mi>0</span> <span class=o>&lt;=</span> <span class=n>length</span>
</span></span><span class=line><span class=cl><span class=k>where</span> <span class=n>length</span> <span class=o>&lt;=</span> <span class=o>|</span><span class=n>items</span><span class=o>|</span>
</span></span></code></pre></div><p>The current approach we take is rather simplistic here. We simply
generate all values of the <em>underlying type</em> and discard those which
don&rsquo;t satisfy the invariant. This works, but it has some problems:</p><ol><li><p><em>(Scale)</em>. Enumerating all values of a complex data type upto a
given bound can be expensive. We might easily need to generate
<em>1K</em>, <em>10K</em>, <em>100K</em> (or more) values, of which only a tiny
fraction may satisfy our invariant. For our <code>List</code> example
above, assuming a maximum array length of <code>3</code> and integer range
<code>-3..3</code>, there are <em>2800</em> possible values of the underlying type
of which only <em>1534</em> meet the invariant (55%). That&rsquo;s not too
bad, but as we get more invariants this changes quite quickly.
Consider this example taken from an implementation of <a href=https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm>Tarjan&rsquo;s
algorithm</a>
for computing <em>strongly connected compoenents</em>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-whiley data-lang=whiley><span class=line><span class=cl><span class=kd>type</span> <span class=n>Data</span> <span class=k>is</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>bool</span><span class=p>[]</span> <span class=n>visited</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span><span class=p>[]</span> <span class=n>lowlink</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span><span class=p>[]</span> <span class=n>index</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>where</span> <span class=o>|</span><span class=n>visited</span><span class=o>|</span> <span class=o>==</span> <span class=o>|</span><span class=n>lowlink</span><span class=o>|</span>
</span></span><span class=line><span class=cl><span class=k>where</span> <span class=o>|</span><span class=n>lowlink</span><span class=o>|</span> <span class=o>==</span> <span class=o>|</span><span class=n>index</span><span class=o>|</span>
</span></span></code></pre></div><p>In this case, there are
<em>2.4M</em> values of the underlying type, of which only <em>946K</em> match
the invariant (39%). And, as we add more invariants (e.g. that
no element in <code>lowlink</code> can be negative) this ratio continues a
downward trend.</p></li><li><p><em>(Sampling)</em>. Another interesting issue arises with sampling.
Typically, we want to sample from large domains (i.e. rather
than enumerate them) to allow checking in reasonable time. The
problem is that, for complex data types with invariants, the
probability that a given value sampled from the underlying
domain meets the invariant is often very low. We have observed
situations where sampling <em>1K</em> or <em>10K</em> values from such a
domain produced <em>exactly zero</em> values meeting the invariant. In other
words, it was completely useless in these cases (though not in others).</p></li></ol><p>Whilst these may seem like serious problems, they stem from the
simplistic fashion in which we generate values for constrained types.
Actually, it is possible to generate values of constrained types directly
(i.e. without enumerating those of the underlying type) and
efficiently. The next evolution of the check functionaliy will implement
this and, hopefully, it will offer some big improvements.</p><h2 id=pros--cons>Pros / Cons</h2><p>There are several advantages to checking over static verification,
some of which may be unexpected:</p><ul><li><p><em>(Incomplete Specifications)</em>. We can check our programs even
when the specifications are incomplete. Suppose we are
developing two functions in tandem, say <code>max(int[])</code> which uses
<code>max(int,int)</code> as a subroutine. With static verification, we
cannot verify <code>max(int[])</code> before we have specified and verified
<code>max(int,int)</code>. However, we can start checking <code>max(int[])</code> as
soon as we have implementated <code>max(int,int)</code> (i.e. since
checking just executes it).</p></li><li><p><em>(Loop Invariants)</em>. We can check our programs without writing
any loop invariants. Since writing loop invariants can be
challenging, this is an important benefit. With static
verification, we cannot verify a function containing a loop
without correctly specifying the loop invariant first. That can
be a real pain, especially in the early stages of developing a
program.</p></li><li><p><em>(Counterexamples)</em>. Whenever checking finds a problem in our
program, it will also tell you the input values causing it and,
furthermore, they always correspond to real failures in your
program. Static verification, on the other hand, cannot always
generate an execution trace and, even when it does, they are not
always <em>realisable</em> traces of the program. That can make life
quite frustrating!</p></li></ul><p>Of course, there are some disadvantages with checking as well. Most
importantly, checking doesn&rsquo;t guarantee to find all problems with your
program! But, in our experience, it usually finds most of them.
There are also problems (discussed above) with generating enough
values for complex data types to properly test our functions.</p><h3 id=conclusion>Conclusion</h3><p>Overall, despite some limitations, we find checking to be incredibly
useful &mdash; <em>especially as its free</em>. Here&rsquo;s a short demo to give you
a taste:</p><center><iframe class=youtube src=https://www.youtube.com/embed/d_liFzxlpjA width=560 height=315 frameborder=0 allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></center><p>So, head on over to the <a href=http://whileylabs.com>online editor for
Whiley</a> and give it a go!</p><hr><i>Follow the discussion on
<a href=https://twitter.com/whileydave/status/1341215592733274112>Twitter</a>
or
<a href=https://www.reddit.com/r/programming/comments/khwdyb/automated_testing_for_free/>Reddit</a></i></div></div><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-5582165-7","auto"),ga("send","pageview"))</script></body></html>