<!doctype html><html lang=en><head><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta property="og:title" content="Understanding Partial Moves in Rust"><meta name=twitter:title content="Understanding Partial Moves in Rust"><meta property="og:description" content="Partial Moves in Rust are an interesting but often misunderstood feature.  To understand them, what we need is a good mental model!"><meta name=twitter:description content="Partial Moves in Rust are an interesting but often misunderstood feature.  To understand them, what we need is a good mental model!"><meta property="og:image" content="https://whileydave.com/images/2020/PartialMoves_PartialMove.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://whileydave.com/images/2020/PartialMoves_PartialMove.png"><meta name=twitter:image:alt content="https://whileydave.com/Image showing an owning reference in Rust being moved out of a tuple."><meta name=twitter:site content="@whileydave"><meta property="og:url" content="https://whileydave.com/2020/11/30/understanding-partial-moves-in-rust/"><title>David J. Pearce
(Understanding Partial Moves in Rust)</title><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css><link rel=stylesheet href=https://whileydave.com/css/page.css><link rel=stylesheet href=https://whileydave.com/css/menu.css><link rel=stylesheet href=https://whileydave.com/css/style.css><link rel=stylesheet href=https://whileydave.com/css/syntax.css></head><body><script>"use strict";function clearMenu(){var q=window.matchMedia("(max-width: 992px)");if(q.matches){var c=document.getElementById("menu-content");var m=document.getElementById("menu");c.style.display='none';m.style.filter='';}}
function toggleMenu(){var q=window.matchMedia("(max-width: 992px)");if(q.matches){var c=document.getElementById("menu-content");var m=document.getElementById("menu");if(c.style.display==='block'){c.style.display='none';m.style.filter='';}else{c.style.display='block';m.style.filter="brightness(0.8)";}}}
function toggleList(element){element.style.display="none";var parent=element.parentNode;var items=parent.childNodes;for(var i=0;i<items.length;++i){var item=items[i];if(item.classList&&item.classList.contains("hidden")){if(item.style.display==='block'){item.style.display="none";}else{item.style.display="block";}}}}</script><header class=topbar><div class=topbar-header onclick=clearMenu()><div class=topbar-title>Dr. David J. Pearce</div><div class=topbar-subtitle></div></div><div class=topbar-social onclick=clearMenu()><a href=https://github.com/DavePearce><i class="fa fa-github" aria-hidden=true></i></a><a href=https://twitter.com/WhileyDave><i class="fa fa-twitter" aria-hidden=true></i></a><a href=https://www.youtube.com/user/redjamjar/><i class="fa fa-youtube-play" aria-hidden=true></i></a><a href=https://www.linkedin.com/in/david-pearce-8592647/><i class="fa fa-linkedin-square" aria-hidden=true></i></a></div><div class=topbar-menu><div id=menu onclick=toggleMenu()><div id=menu-icon><img src=https://whileydave.com/images/menu.png alt=Menu></div><div id=menu-content><a href=https://whileydave.com/blog/>Blog</a>
<a href=https://whileydave.com/projects/>Projects</a>
<a href=https://whileydave.com/publications/>Publications</a>
<a href=https://whileydave.com/talks/>Talks</a>
<a href=https://whileydave.com/>Home</a></div></div></div></header><div class=container onclick=clearMenu()><div class=content><h1 class=post-title>Understanding Partial Moves in Rust</h1><div class=post-date>Monday, November
30th,
2020</div><hr><p>Recently I&rsquo;ve been digging into <a href=https://www.rust-lang.org/>Rust</a> and, whilst it&rsquo;s a great language on many fronts, I do find lots of hidden complexity. One example which doesn&rsquo;t get much attention is <em>partial moves</em>. So, I thought, <em>why not write an introduction?</em></p><h3 id=ownership-briefly>Ownership (Briefly)</h3><p>I&rsquo;m not going to cover all the details of <a href=https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html>ownership and borrowing</a> in Rust here. Still, we need some background for partial moves to make sense. So, here is a <em>box and arrow</em> (i.e. simplified) perspective of ownership in Rust!</p><p>In an imperative world without ownership (think Java, C/C++) we are generally allowed references to (e.g. heap) data without any restrictions around aliasing. We can have two references pointing to the same data, references which point to each other, and so on:</p><figure class=text-center><img height=150px alt="Illustrating different examples of aliasing between references." src=/images/2020/PartialMoves_Aliasing.png></figure><p>In a world with ownership (i.e. Rust) a reference can now <em>own</em> the data to which it refers. In such case, no other owning references of that data are permitted (roughly speaking). For example, if two references refer to the same thing (i.e. the middle diagram above) only one can be the owner.</p><p>The restrictions on the owning references impact on how we write programs. Suppose we tried to <em>copy</em> an owning reference from one variable <code>p</code> to another variable <code>q</code>:</p><figure class=text-center><img height=175px alt="Illustrating owning reference being copied to another variable." src=/images/2020/PartialMoves_OwnerCopy.png></figure><p>This doesn&rsquo;t make sense because it breaks the <em>ownership invariant</em>. If we allowed it, we would have two owning references to the same thing which is not permitted. So, what can we do? <em>We can move it instead</em>:</p><figure class=text-center><img height=175px alt="Illustrating owning reference being moved to another variable." src=/images/2020/PartialMoves_OwnerMove.png></figure><p>Here, the value of variable <code>p</code> has been <em>voided</em> by the move and we cannot use <code>p</code> again until we assign it something new. Yes, this does have a pretty big impact on how we go about writing programs in Rust! <em>But, I&rsquo;m not talking about that here.</em></p><h3 id=partial-moves>Partial Moves</h3><p>Thus far, we&rsquo;ve looked at moving an entire variable at a time (e.g. from <code>p</code> to <code>q</code> above). However, we can also perform a <em>partial move</em> whereby only part of a given variable is moved. Suppose now that our variable <code>p</code> is actually a pair where each element contains an owning reference. Then, we can move the second element of <code>p</code> into some other variable <code>q</code> as follows:</p><figure class=text-center><img height=180px alt="Illustrating owning reference in struct being moved to another variable." src=/images/2020/PartialMoves_PartialMove.png></figure><p>What is interesting about this case is that, unlike before, variable <code>p</code> can still be used in a limited way <em>even though part of it has been voided</em>. Specifically, we can use <code>p.0</code> but we cannot use <code>p.1</code>. Furthermore, Rust prevents us from copying or moving variable <code>p</code> as a whole (though, to my mind, that seems somewhat unnecessary). Putting the above into code looks like this:</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#069;font-weight:700>fn</span> <span style=color:#c0f>main</span>()<span style=color:#bbb> </span>{<span style=color:#bbb> 
</span><span style=color:#bbb>    </span><span style=color:#069;font-weight:700>let</span><span style=color:#bbb> </span><span style=color:#069;font-weight:700>mut</span><span style=color:#bbb> </span>x<span style=color:#bbb> </span><span style=color:#555>=</span><span style=color:#bbb> </span><span style=color:#f60>123</span>;<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#069;font-weight:700>let</span><span style=color:#bbb> </span><span style=color:#069;font-weight:700>mut</span><span style=color:#bbb> </span>y<span style=color:#bbb> </span><span style=color:#555>=</span><span style=color:#bbb> </span><span style=color:#f60>456</span>;<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#069;font-weight:700>let</span><span style=color:#bbb> </span><span style=color:#069;font-weight:700>mut</span><span style=color:#bbb> </span>p<span style=color:#bbb> </span><span style=color:#555>=</span><span style=color:#bbb> </span>(<span style=color:#555>&amp;</span><span style=color:#069;font-weight:700>mut</span><span style=color:#bbb> </span>x,<span style=color:#555>&amp;</span><span style=color:#069;font-weight:700>mut</span><span style=color:#bbb> </span>y);<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#069;font-weight:700>let</span><span style=color:#bbb> </span><span style=color:#069;font-weight:700>mut</span><span style=color:#bbb> </span>q<span style=color:#bbb> </span><span style=color:#555>=</span><span style=color:#bbb> </span>p.<span style=color:#f60>1</span>;<span style=color:#bbb>
</span><span style=color:#bbb>    </span>...<span style=color:#bbb>
</span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></code></pre></div><p>At this point, everything is fine. However, replacing the <code>...</code> with
e.g. <code>let mut z = p;</code> and we get the following error message:</p><pre><code>error[E0382]: use of partially moved value: `p`
 --&gt; src/main.rs:6:17
  |
5 | let mut q = p.1;
  |             --- value partially moved here
6 | let mut z = p;
  |             ^ value used here after partial move
</code></pre><p>This is simply telling us that we cannot use a value which has been
voided by some previous move. Personally, I don&rsquo;t see why Rust
prevents moves like this, since it could easily reason that <code>z</code> is
only partially defined in the same way that it already does for <code>p</code>.
Presumably, though, assigning <code>p</code> indirectly through some reference
would be problematic regardless.</p><h3 id=conclusion>Conclusion</h3><p>Partial moves are a pretty interesting feature of Rust which are
sometimes misunderstood. In fact, with a good mental model they are
not so hard to understand!</p><hr></div></div><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-5582165-7','auto');ga('send','pageview');}</script></body></html>