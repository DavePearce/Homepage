<!doctype html><html lang=en><head><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta property="og:title" content="The Semantics of Semantic Versioning?"><meta property="twitter:title" content="The Semantics of Semantic Versioning?"><meta property="og:description" content="Semantic versioning is a low fidelity communication channel.  However, tooling could be used to improve this situation, such as through static analysis"><meta property="twitter:description" content="Semantic versioning is a low fidelity communication channel.  However, tooling could be used to improve this situation, such as through static analysis"><meta property="og:image" content="https://whileydave.com/images/2020/semver.png"><meta property="twitter:image" content="https://whileydave.com/images/2020/semver.png"><meta property="twitter:card" content="summary_large_image"><meta property="twitter:creator" content="@whileydave"><meta property="og:url" content="https://whileydave.com/2020/09/24/the-semantics-of-semantic-versioning/"><title>David J. Pearce
(The Semantics of Semantic Versioning?)</title><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css><link rel=stylesheet href=https://whileydave.com/css/page.css><link rel=stylesheet href=https://whileydave.com/css/menu.css><link rel=stylesheet href=https://whileydave.com/css/style.css><link rel=stylesheet href=https://whileydave.com/css/syntax.css></head><body><script>"use strict";function clearMenu(){var q=window.matchMedia("(max-width: 992px)");if(q.matches){var c=document.getElementById("menu-content");var m=document.getElementById("menu");c.style.display='none';m.style.filter='';}}
function toggleMenu(){var q=window.matchMedia("(max-width: 992px)");if(q.matches){var c=document.getElementById("menu-content");var m=document.getElementById("menu");if(c.style.display==='block'){c.style.display='none';m.style.filter='';}else{c.style.display='block';m.style.filter="brightness(0.8)";}}}
function toggleList(element){element.style.display="none";var parent=element.parentNode;var items=parent.childNodes;for(var i=0;i<items.length;++i){var item=items[i];if(item.classList&&item.classList.contains("hidden")){if(item.style.display==='block'){item.style.display="none";}else{item.style.display="block";}}}}</script><header class=topbar><div class=topbar-header onclick=clearMenu()><div class=topbar-title>Dr. David J. Pearce</div><div class=topbar-subtitle></div></div><div class=topbar-social onclick=clearMenu()><a href=https://github.com/DavePearce><i class="fa fa-github" aria-hidden=true></i></a><a href=https://twitter.com/WhileyDave><i class="fa fa-twitter" aria-hidden=true></i></a><a href=https://www.youtube.com/user/redjamjar/><i class="fa fa-youtube-play" aria-hidden=true></i></a><a href=https://www.linkedin.com/in/david-pearce-8592647/><i class="fa fa-linkedin-square" aria-hidden=true></i></a></div><div class=topbar-menu><div id=menu onclick=toggleMenu()><div id=menu-icon><img src=https://whileydave.com/images/menu.png alt=Menu></div><div id=menu-content><a href=https://whileydave.com/blog/>Blog</a>
<a href=https://whileydave.com/projects/>Projects</a>
<a href=https://whileydave.com/publications/>Publications</a>
<a href=https://whileydave.com/talks/>Talks</a>
<a href=https://whileydave.com/>Home</a></div></div></div></header><div class=container onclick=clearMenu()><div class=content><h1 class=post-title>The Semantics of Semantic Versioning?</h1><div class=post-date>Thursday, September
24th,
2020</div><hr><p>Semantic versioning is a surprisingly interesting topic when you get into it. Recently, myself and a few colleagues (<a href=http://patricklam.ca/>Patrick</a> & <a href=https://sites.google.com/site/jensdietrich/>Jens</a>) have been giving it some thought (and we even wrote an <a href=https://whileydave.com/publications/ldp20/>essay on it</a>)! If you haven&rsquo;t seen it already, check out the <a href=https://semver.org/>manifesto for semantic versioning</a>. Whilst that provides a nice overview, there is a lot left unsaid. There are two different perspectives on semantic versioning:</p><ol><li><p><strong>Downstream</strong>. This is perhaps the more obvious scenario. Downstream developers (clients) want access to the library features offered by (upstream) developers! They also want both <em>stability</em> and <em>protection</em>. That is, they don&rsquo;t want future releases of a library to break their code but (ideally) they want to get future releases automatically (e.g. for critical security updates).</p></li><li><p><strong>Upstream</strong>. On the flip-side, upstream (library) developers want <em>flexibility</em> to continue improving their libraries with new features, refactorings, etc. They also want to fix bugs and security vulnerabilities as and when they arise.</p></li></ol><p>In some sense, semantic versioning is just a communication mechanism between upstream and downstream developers. Now, a three point version number is (at best) a low fidelity communication channel. <em>But, this post is not about that</em>. Rather, it is about figuring out how to make the most of semantic versioning as it is.</p><h3 id=economics>Economics</h3><p>An important aspect of semantic versioning is <em>trust</em>. Downstream developers must trust upstream developers not to break the protocol (e.g. by putting out minor releases with breaking changes). When trust is lost, clients become hesitant to upgrade and the <em>lag</em> between a new release and the client upgrading increases. This makes sense as clients balance the costs of upgrading against their benefits. For example, if upgrading requires only a few minor tweaks to your code base, but offers important security patches then it seems worth it. But, when upgrading requires significant changes to your code (e.g. because library developer decided randomly to refactor the API) and the only benefit is some features you don&rsquo;t need &mdash; it doesn&rsquo;t.</p><p><em>We can view all this through the lens of economic theory and treat it as a market system</em>. Then, trustworthy upstream developers should succeed where others fail, etc. This seems like that&rsquo;s it all sorted out! But, the reality is different as, unfortunately, mistakes are made all the time by developers we think should be trustworthy (see examples below). The problem is that the system is not yet efficient because:</p><ol><li><p><strong>Downstream developers</strong> have real difficulties determining what the costs and benefits are.</p></li><li><p><strong>Upstream developers</strong> cannot easily tell when they inadvertently make breaking changes (more on this below).</p></li></ol><p><em>In thinking about this, we&rsquo;re interested in what techniques could be brought to bear on this to make the market system more efficient.</em></p><h3 id=breaking-changes>Breaking Changes</h3><p>An important question here is: <em>what are &ldquo;breaking changes&rdquo; anyway?</em> Knowing this is somehow key to a smoothly functioning system. Some thoughts:</p><ul><li><p><em>Should a change of license be considered a breaking change?</em></p></li><li><p><em>Should a bug-fix which changes an implementation&rsquo;s behaviour be considered a breaking change?</em></p></li><li><p><em>Should a change which degrades system performance be considered breaking?</em></p></li><li><p><em>Should a change to the contract of a method be considered breaking?</em></p></li><li><p><em>Should a change in the <em>purity</em> of a method be considered breaking?</em></p></li><li><p><em>Should a change in the order of elements returned by a method be considered breaking?</em></p></li></ul><p>Most of these could be considered breaking changes in certain
situations (i.e. depending on the client):</p><p><strong>Exhibit A.</strong> Firefox (downstream developer) uses
<a href=http://fontconfig.org>fontconfig</a> (upstream developer). A
<a href="http://cgit.freedesktop.org/fontconfig/commit/?id=95af7447dba7c54ed162b667c0bb2ea6500e8f32">commit</a>
to fontconfig <code>v2.10.92</code> meant it now rejected empty filenames. It&rsquo;s
documentation didn&rsquo;t say whether empty filenames were allowed or not,
<em>so this was reasonable right?</em> Well, it <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=857922">broke
Firefox</a>.</p><p><strong>Exhibit B.</strong> <a href=https://jsoup.org/>JSoup</a> <code>v1.10.1</code> included a
performance refactoring for &ldquo;<em>reducing memory allocation and garbage
collection</em>&rdquo;. Again, this seemed reasonable but clients quickly
started <a href=https://github.com/jhy/jsoup/issues/830>reporting problems</a>.</p><p>These are just some examples and you can easily find more with a
little digging. The point is that upstream developers miss (or
ignore) changes affecting downstream clients all the time. <em>So, what
can we do?</em></p><h3 id=tooling>Tooling</h3><p><a href=https://revapi.org/>RevAPI</a> provides food-for-thought here. If you haven&rsquo;t come across it before, this tool compares two versions of a Jar file and identifies certain kinds of breaking change. Examples of breaking changes include: reducing the visibility of a method; removing a <code>public</code> declaration; or, modifying a <code>public</code> class so that it no longer implements some interface. <em>This is actually awesome!</em> <em>People should use this stuff all the time!</em></p><p>Our interest here is not what the tool thinks <em>are</em> breaking changes, but what it <em>doesn&rsquo;t</em>. For example, when a method no longer accepts <code>null</code> for some parameter, or moves from <a href=https://en.wikipedia.org/wiki/Time_complexity>linear to quadratic time</a>, or returns the elements of an array in a different order, etc. Ok, we have to be reasonable &mdash; one tool cannot do everything and these are <em>hard</em> problems. Still, RevAPI offers a glimmer of hope that semantics versioning could be much more than it currently is. And, there are others:
<a href=https://medium.com/@Max_Goldstein/how-to-publish-an-elm-package-3053b771e545>Elm Bump</a>, <a href=https://github.com/rust-dev-tools/rust-semverver>rust-semverver</a>, and <a href=http://clirr.sourceforge.net/>clirr</a> to name a few.</p><p><em>So, there should be tools, and lots of 'em!</em> Both upstream <em>and</em> downstream developers should be using them to spot inadvertent breaking changes, or to gauge the cost of upgrades. Whilst current tools are fairly shallow in their assessment of breaking changes, there is a wealth of techniques from fields like <a href=https://en.wikipedia.org/wiki/Static_program_analysis>static analysis</a> and automated testing which could be used here.</p><h3 id=conclusion>Conclusion</h3><p>Well, that&rsquo;s enough for now!! If you made it this far, then you should check out our <a href=https://whileydave.com/publications/ldp20/>essay</a> which goes into way more detail.</p><p>And finally, just to get you thinking, here&rsquo;s a cool idea for upstream
developers: <strong>know your dependencies!</strong> These days, its easy to find
your downstream clients. Before releasing a new version, just check
for breaking changes by <em>running all your clients&rsquo; tests!</em> That&rsquo;s
exactly what <a href=https://github.com/rust-lang/crater>Crater does for
Rust</a> and also what <a href=https://dl.acm.org/doi/abs/10.1145/3379597.3387476>these
folks</a> and
<a href=https://drops.dagstuhl.de/opus/volltexte/2018/9239/>these folks</a>
are suggesting.</p><h3 id=related-articles>Related Articles</h3><p>Here are a few related articles on semantic versioning which are definitely worth a read!</p><ul><li><p><a href=https://gist.github.com/jashkenas/cbd2b088e20279ae2c8e>Why Semantic Versioning Isn&rsquo;t</a></p></li><li><p><a href=https://developer.okta.com/blog/2019/12/16/semantic-versioning>Semantic Versioning Sucks! Long Live Semantic Versioning</a></p></li></ul><hr></div></div><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-5582165-7','auto');ga('send','pageview');}</script></body></html>